# é€æ­¥åˆ›å»º NFT é›†åˆçš„æ•™ç¨‹

## ğŸ‘‹ å¼•è¨€

éåŒè´¨åŒ–ä»£å¸ï¼ˆNFTï¼‰å·²æˆä¸ºæ•°å­—è‰ºæœ¯å’Œæ”¶è—å“ä¸–ç•Œä¸­æœ€çƒ­é—¨çš„è¯é¢˜ä¹‹ä¸€ã€‚NFTæ˜¯ä½¿ç”¨åŒºå—é“¾æŠ€æœ¯éªŒè¯æ‰€æœ‰æƒå’ŒçœŸå®æ€§çš„ç‹¬ç‰¹æ•°å­—èµ„äº§ã€‚å®ƒä»¬ä¸ºåˆ›ä½œè€…å’Œæ”¶è—å®¶æä¾›äº†å°†æ•°å­—è‰ºæœ¯ã€éŸ³ä¹ã€è§†é¢‘å’Œå…¶ä»–å½¢å¼çš„æ•°å­—å†…å®¹è´§å¸åŒ–å’Œäº¤æ˜“çš„æ–°å¯èƒ½æ€§ã€‚è¿‘å¹´æ¥ï¼ŒNFTå¸‚åœºçˆ†ç‚¸æ€§å¢é•¿ï¼Œä¸€äº›é«˜è°ƒçš„é”€å”®é¢è¾¾åˆ°äº†æ•°ç™¾ä¸‡ç¾å…ƒã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†é€æ­¥åœ¨TONä¸Šæ„å»ºæˆ‘ä»¬çš„NFTé›†åˆã€‚

**è¿™æ˜¯ä½ åœ¨æœ¬æ•™ç¨‹ç»“æŸæ—¶å°†åˆ›å»ºçš„é¸­å­é›†åˆçš„ç²¾ç¾å›¾ç‰‡ï¼š**

![](/img/tutorials/nft/collection.png)

## ğŸ¦„ ä½ å°†ä¼šå­¦åˆ°ä»€ä¹ˆ

1. ä½ å°†åœ¨TONä¸Šé“¸é€ NFTé›†åˆ
2. ä½ å°†ç†è§£TONä¸Šçš„NFTæ˜¯å¦‚ä½•å·¥ä½œçš„
3. ä½ å°†æŠŠNFTå‡ºå”®
4. ä½ å°†æŠŠå…ƒæ•°æ®ä¸Šä¼ åˆ°[pinata.cloud](https://pinata.cloud)

## ğŸ’¡ å¿…è¦æ¡ä»¶

ä½ å¿…é¡»å·²ç»æœ‰ä¸€ä¸ªæµ‹è¯•ç½‘é’±åŒ…ï¼Œé‡Œé¢è‡³å°‘æœ‰2 TONã€‚å¯ä»¥ä»[@testgiver_ton_bot](https://t.me/testgiver_ton_bot)è·å–æµ‹è¯•ç½‘å¸ã€‚

:::info å¦‚ä½•æ‰“å¼€æˆ‘çš„Tonkeeperé’±åŒ…çš„æµ‹è¯•ç½‘ç‰ˆæœ¬ï¼Ÿ\
è¦åœ¨tonkeeperä¸­æ‰“å¼€æµ‹è¯•ç½‘ç½‘ç»œï¼Œè¯·è½¬åˆ°è®¾ç½®å¹¶ç‚¹å‡»ä½äºåº•éƒ¨çš„tonkeeper logo 5æ¬¡ï¼Œä¹‹åé€‰æ‹©æµ‹è¯•ç½‘è€Œä¸æ˜¯ä¸»ç½‘ã€‚
:::

æˆ‘ä»¬å°†ä½¿ç”¨Pinataä½œä¸ºæˆ‘ä»¬çš„IPFSå­˜å‚¨ç³»ç»Ÿï¼Œå› æ­¤ä½ è¿˜éœ€è¦åœ¨[pinata.cloud](https://pinata.cloud)ä¸Šåˆ›å»ºä¸€ä¸ªå¸æˆ·å¹¶è·å–api_key & api_secreatã€‚å®˜æ–¹Pinata [æ–‡æ¡£æ•™ç¨‹](https://docs.pinata.cloud/pinata-api/authentication)å¯ä»¥å¸®åŠ©å®Œæˆè¿™ä¸€ç‚¹ã€‚åªè¦ä½ æ‹¿åˆ°è¿™äº›apiä»¤ç‰Œï¼Œæˆ‘å°±åœ¨è¿™é‡Œç­‰ä½ ï¼ï¼ï¼

## ğŸ’ ä»€ä¹ˆæ˜¯ TON ä¸Šçš„ NFT?

åœ¨å¼€å§‹æˆ‘ä»¬æ•™ç¨‹çš„ä¸»è¦éƒ¨åˆ†ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€ä¸‹é€šå¸¸æ„ä¹‰ä¸ŠTONä¸­NFTæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å‡ºä¹æ„æ–™çš„æ˜¯ï¼Œæˆ‘ä»¬å°†ä»è§£é‡ŠETHä¸­NFTçš„å·¥ä½œåŸç†å¼€å§‹ï¼Œä¸ºäº†ç†è§£TONä¸­NFTå®ç°çš„ç‰¹æ®Šæ€§ï¼Œä¸è¡Œä¸šä¸­å¸¸è§çš„åŒºå—é“¾ç›¸æ¯”ã€‚

### ETH ä¸Šçš„ NFT å®ç°

ETHä¸­NFTçš„å®ç°æå…¶ç®€å• - å­˜åœ¨1ä¸ªä¸»è¦çš„é›†åˆåˆçº¦ï¼Œå®ƒå­˜å‚¨ä¸€ä¸ªç®€å•çš„å“ˆå¸Œæ˜ å°„ï¼Œè¯¥å“ˆå¸Œæ˜ å°„åè¿‡æ¥å­˜å‚¨æ­¤é›†åˆä¸­NFTçš„æ•°æ®ã€‚æ‰€æœ‰ä¸æ­¤é›†åˆç›¸å…³çš„è¯·æ±‚ï¼ˆå¦‚æœä»»ä½•ç”¨æˆ·æƒ³è¦è½¬ç§»NFTã€å°†å…¶å‡ºå”®ç­‰ï¼‰éƒ½ç‰¹åˆ«å‘é€åˆ°æ­¤1ä¸ªé›†åˆåˆçº¦ã€‚

![](/img/tutorials/nft/eth-collection.png)

### åœ¨ TON ä¸­å¦‚æ­¤å®ç°å¯èƒ½å‡ºç°çš„é—®é¢˜

åœ¨TONçš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæ­¤ç±»å®ç°çš„é—®é¢˜ç”±[TONçš„NFTæ ‡å‡†](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md)å®Œç¾æè¿°ï¼š

- ä¸å¯é¢„æµ‹çš„ç‡ƒæ–™æ¶ˆè€—ã€‚åœ¨TONä¸­ï¼Œå­—å…¸æ“ä½œçš„ç‡ƒæ–™æ¶ˆè€—å–å†³äºç¡®åˆ‡çš„é”®é›†ã€‚æ­¤å¤–ï¼ŒTONæ˜¯ä¸€ä¸ªå¼‚æ­¥åŒºå—é“¾ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœä½ å‘ä¸€ä¸ªæ™ºèƒ½åˆçº¦å‘é€ä¸€ä¸ªæ¶ˆæ¯ï¼Œé‚£ä¹ˆä½ ä¸çŸ¥é“æœ‰å¤šå°‘æ¥è‡ªå…¶ä»–ç”¨æˆ·çš„æ¶ˆæ¯ä¼šåœ¨ä½ çš„æ¶ˆæ¯ä¹‹å‰åˆ°è¾¾æ™ºèƒ½åˆçº¦ã€‚å› æ­¤ï¼Œä½ ä¸çŸ¥é“å½“ä½ çš„æ¶ˆæ¯åˆ°è¾¾æ™ºèƒ½åˆçº¦æ—¶å­—å…¸çš„å¤§å°ä¼šæ˜¯å¤šå°‘ã€‚è¿™å¯¹äºç®€å•çš„é’±åŒ… -> NFTæ™ºèƒ½åˆçº¦äº¤äº’æ˜¯å¯ä»¥çš„ï¼Œä½†å¯¹äºæ™ºèƒ½åˆçº¦é“¾ï¼Œä¾‹å¦‚é’±åŒ… -> NFTæ™ºèƒ½åˆçº¦ -> æ‹å– -> NFTæ™ºèƒ½åˆçº¦ï¼Œåˆ™ä¸å¯æ¥å—ã€‚å¦‚æœæˆ‘ä»¬ä¸èƒ½é¢„æµ‹ç‡ƒæ–™æ¶ˆè€—ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šå‡ºç°è¿™æ ·çš„æƒ…å†µï¼šNFTæ™ºèƒ½åˆçº¦ä¸Šçš„æ‰€æœ‰è€…å·²ç»æ›´æ”¹ï¼Œä½†æ‹å–æ“ä½œæ²¡æœ‰è¶³å¤Ÿçš„Toncoinã€‚ä¸ä½¿ç”¨å­—å…¸çš„æ™ºèƒ½åˆçº¦å¯ä»¥æä¾›ç¡®å®šæ€§çš„ç‡ƒæ–™æ¶ˆè€—ã€‚

- ä¸å¯æ‰©å±•ï¼ˆæˆä¸ºç“¶é¢ˆï¼‰ã€‚TONçš„æ‰©å±•æ€§åŸºäºåˆ†ç‰‡çš„æ¦‚å¿µï¼Œå³åœ¨è´Ÿè½½ä¸‹è‡ªåŠ¨å°†ç½‘ç»œåˆ’åˆ†ä¸ºåˆ†ç‰‡é“¾ã€‚æµè¡ŒNFTçš„å•ä¸ªå¤§æ™ºèƒ½åˆçº¦ä¸è¿™ä¸€æ¦‚å¿µç›¸çŸ›ç›¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè®¸å¤šäº¤æ˜“å°†å¼•ç”¨ä¸€ä¸ªå•ä¸€çš„æ™ºèƒ½åˆçº¦ã€‚TONæ¶æ„ä¸ºåˆ†ç‰‡çš„æ™ºèƒ½åˆçº¦æä¾›äº†è®¾æ–½ï¼ˆå‚è§ç™½çš®ä¹¦ï¼‰ï¼Œä½†ç›®å‰å°šæœªå®ç°ã€‚

_ç®€è€Œè¨€ä¹‹ï¼ŒETHçš„è§£å†³æ–¹æ¡ˆä¸å¯æ‰©å±•ä¸”ä¸é€‚ç”¨äºåƒTONè¿™æ ·çš„å¼‚æ­¥åŒºå—é“¾ã€‚_

### TON ä¸Šçš„ NFT å®ç°

åœ¨TONä¸­ï¼Œæˆ‘ä»¬æœ‰1ä¸ªä¸»åˆçº¦-æˆ‘ä»¬é›†åˆçš„æ™ºèƒ½åˆçº¦ï¼Œå®ƒå­˜å‚¨å®ƒçš„å…ƒæ•°æ®å’Œå®ƒæ‰€æœ‰è€…çš„åœ°å€ï¼Œä»¥åŠæœ€é‡è¦çš„ - å¦‚æœæˆ‘ä»¬æƒ³è¦åˆ›å»ºï¼ˆ"é“¸é€ "ï¼‰æ–°çš„NFTé¡¹ç›® - æˆ‘ä»¬åªéœ€è¦å‘è¿™ä¸ªé›†åˆåˆçº¦å‘é€æ¶ˆæ¯ã€‚è€Œè¿™ä¸ªé›†åˆåˆçº¦å°†ä¸ºæˆ‘ä»¬éƒ¨ç½²æ–°NFTé¡¹ç›®çš„åˆçº¦ï¼Œå¹¶æä¾›æˆ‘ä»¬æä¾›çš„æ•°æ®ã€‚

![](/img/tutorials/nft/ton-collection.png)

:::info
å¦‚æœä½ æƒ³æ›´æ·±å…¥åœ°äº†è§£è¿™ä¸ªè¯é¢˜ï¼Œå¯ä»¥æŸ¥çœ‹[TONä¸Šçš„NFTå¤„ç†](/develop/dapps/asset-processing/nfts)æ–‡ç« æˆ–é˜…è¯»[NFTæ ‡å‡†](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md)
:::

## âš™ è®¾ç½®å¼€å‘ç¯å¢ƒ

è®©æˆ‘ä»¬ä»åˆ›å»ºä¸€ä¸ªç©ºé¡¹ç›®å¼€å§‹ï¼š

1. åˆ›å»ºæ–°æ–‡ä»¶å¤¹
   `mkdir MintyTON`
2. æ‰“å¼€è¿™ä¸ªæ–‡ä»¶å¤¹
   `cd MintyTON`
3. åˆå§‹åŒ–æˆ‘ä»¬çš„é¡¹ç›® `yarn init -y`
4. å®‰è£…typescript

```
yarn add typescript @types/node -D
```

5. å°†ä»¥ä¸‹é…ç½®å¤åˆ¶åˆ°tsconfig.jsonä¸­

```json
{
    "compilerOptions": {
      "module": "commonjs",
      "target": "es6",
      "lib": ["ES2022"],
      "moduleResolution": "node",
      "sourceMap": true,
      "outDir": "dist",
      "baseUrl": "src",
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "strict": true,
      "esModuleInterop": true,
      "strictPropertyInitialization": false
    },
    "include": ["src/**/*"]
}
```

6. å‘package.jsonæ·»åŠ è„šæœ¬ä»¥æ„å»ºå¹¶å¯åŠ¨æˆ‘ä»¬çš„åº”ç”¨ç¨‹åº

```json
"scripts": {
    "start": "tsc --skipLibCheck && node dist/app.js"
  },
```

7. å®‰è£…æ‰€éœ€çš„åº“

```
yarn add @pinata/sdk dotenv ton ton-core ton-crypto
```

8. åˆ›å»º`.env`æ–‡ä»¶å¹¶æ ¹æ®æ­¤æ¨¡æ¿æ·»åŠ ä½ è‡ªå·±çš„æ•°æ®

```
PINATA_API_KEY=your_api_key
PINATA_API_SECRET=your_secret_api_key
MNEMONIC=word1 word2 word3 word4
TONCENTER_API_KEY=aslfjaskdfjasasfas
```

ä½ å¯ä»¥ä»[@tonapibot](https://t.me/tonapibot)è·å–toncenter api keyå¹¶é€‰æ‹©mainnetæˆ–testnetã€‚åœ¨ `MNEMONIC` å˜é‡ä¸­å­˜å‚¨é›†åˆæ‰€æœ‰è€…é’±åŒ…ç§å­çŸ­è¯­çš„24ä¸ªå•è¯ã€‚

å¤ªå¥½äº†ï¼ç°åœ¨æˆ‘ä»¬å‡†å¤‡å¥½å¼€å§‹ä¸ºæˆ‘ä»¬çš„é¡¹ç›®ç¼–å†™ä»£ç äº†ã€‚

### ç¼–å†™è¾…åŠ©å‡½æ•°

é¦–å…ˆï¼Œè®©æˆ‘ä»¬åœ¨`src/utils.ts`ä¸­åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†é€šè¿‡åŠ©è®°è¯æ‰“å¼€æˆ‘ä»¬çš„é’±åŒ…å¹¶è¿”å›å®ƒçš„publicKey/secretKeyã€‚

æˆ‘ä»¬æ ¹æ®24ä¸ªå•è¯ï¼ˆç§å­çŸ­è¯­ï¼‰è·å–ä¸€å¯¹å¯†é’¥ï¼š

```ts
import { KeyPair, mnemonicToPrivateKey } from "ton-crypto";
import {
  beginCell,
  Cell,
  OpenedContract,
  TonClient,
  WalletContractV4,
} from "ton";

export type OpenedWallet = {
  contract: OpenedContract<WalletContractV4>;
  keyPair: KeyPair;
};

export async function openWallet(mnemonic: string[], testnet: boolean) {
  const keyPair = await mnemonicToPrivateKey(mnemonic);
}
```

åˆ›å»ºä¸€ä¸ªç±»å®ä¾‹ä»¥ä¸toncenteräº¤äº’ï¼š

```ts
const toncenterBaseEndpoint: string = testnet
  ? "https://testnet.toncenter.com"
  : "https://toncenter.com";

const client = new TonClient({
  endpoint: `${toncenterBaseEndpoint}/api/v2/jsonRPC`,
  apiKey: process.env.TONCENTER_API_KEY,
});
```

æœ€åæ‰“å¼€æˆ‘ä»¬çš„é’±åŒ…ï¼š

```ts
const wallet = WalletContractV4.create({
    workchain: 0,
    publicKey: keyPair.publicKey,
  });

const contract = client.open(wallet);
return { contract, keyPair };
```

å¾ˆå¥½ï¼Œä¹‹åæˆ‘ä»¬å°†åˆ›å»ºæˆ‘ä»¬é¡¹ç›®çš„ä¸»è¦å…¥å£ç‚¹`app.ts`ã€‚
åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†ä½¿ç”¨åˆšåˆšåˆ›å»ºçš„`openWallet`å‡½æ•°å¹¶è°ƒç”¨æˆ‘ä»¬çš„ä¸»å‡½æ•°`init`ã€‚
ç›®å‰è¶³å¤Ÿäº†ã€‚

```ts
import * as dotenv from "dotenv";

import { openWallet } from "./utils";
import { readdir } from "fs/promises";

dotenv.config();

async function init() {
  const wallet = await openWallet(process.env.MNEMONIC!.split(" "), true);  
}

void init();
```

æœ€åï¼Œè®©æˆ‘ä»¬åˆ›å»º`delay.ts`æ–‡ä»¶ï¼Œåœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥ç­‰å¾…`seqno`å¢åŠ ã€‚

```ts
import { OpenedWallet } from "utils";

export async function waitSeqno(seqno: number, wallet: OpenedWallet) {
  for (let attempt = 0; attempt < 10; attempt++) {
    await sleep(2000);
    const seqnoAfter = await wallet.contract.getSeqno();
    if (seqnoAfter == seqno + 1) break;
  }
}

export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

:::info ä»€ä¹ˆæ˜¯seqno?
ç®€å•æ¥è¯´ï¼Œseqnoå°±æ˜¯ç”±é’±åŒ…å‘é€çš„å¤–éƒ¨äº¤æ˜“çš„è®¡æ•°å™¨ã€‚
Seqnoç”¨äºé¢„é˜²é‡æ”¾æ”»å‡»ã€‚å½“äº¤æ˜“å‘é€åˆ°é’±åŒ…æ™ºèƒ½åˆçº¦æ—¶ï¼Œå®ƒå°†äº¤æ˜“çš„seqnoå­—æ®µä¸å…¶å­˜å‚¨ä¸­çš„å­—æ®µè¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœå®ƒä»¬åŒ¹é…ï¼Œäº¤æ˜“è¢«æ¥å—å¹¶ä¸”å­˜å‚¨çš„seqnoå¢åŠ ä¸€ã€‚å¦‚æœå®ƒä»¬ä¸åŒ¹é…ï¼Œäº¤æ˜“è¢«ä¸¢å¼ƒã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡å‘é€å¤–éƒ¨äº¤æ˜“åç¨ç­‰ä¸€ä¼šå„¿ã€‚
:::

## ğŸ–¼ å‡†å¤‡å…ƒæ•°æ®

å…ƒæ•°æ® - åªæ˜¯ä¸€äº›ç®€å•çš„ä¿¡æ¯ï¼Œå°†æè¿°æˆ‘ä»¬çš„NFTæˆ–é›†åˆã€‚ä¾‹å¦‚å®ƒçš„åç§°ã€å®ƒçš„æè¿°ç­‰ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨`/data/images`ä¸­å­˜å‚¨æˆ‘ä»¬NFTçš„å›¾ç‰‡ï¼Œå‘½åä¸º`0.png`ã€`1.png`...ç”¨äºç‰©å“çš„ç…§ç‰‡ï¼Œä»¥åŠ`logo.png`ç”¨äºæˆ‘ä»¬é›†åˆçš„å¤´åƒã€‚ä½ å¯ä»¥è½»æ¾[ä¸‹è½½](/img/tutorials/nft/ducks.zip)åŒ…å«é¸­å­å›¾ç‰‡çš„åŒ…æˆ–å°†ä½ çš„å›¾ç‰‡æ”¾å…¥è¯¥æ–‡ä»¶å¤¹ã€‚æˆ‘ä»¬è¿˜å°†åœ¨`/data/metadata/`æ–‡ä»¶å¤¹ä¸­å­˜å‚¨æ‰€æœ‰çš„å…ƒæ•°æ®æ–‡ä»¶ã€‚

### NFT è§„èŒƒ

TONä¸Šçš„å¤§å¤šæ•°äº§å“æ”¯æŒä»¥ä¸‹å…ƒæ•°æ®è§„èŒƒæ¥å­˜å‚¨æœ‰å…³NFTé›†åˆçš„ä¿¡æ¯ï¼š

| åç§°                                | è§£é‡Š                                          |
| --------------------------------- | ------------------------------------------- |
| name                              | é›†åˆåç§°                                        |
| description                       | é›†åˆæè¿°                                        |
| image                             | å°†æ˜¾ç¤ºä¸ºå¤´åƒçš„å›¾ç‰‡é“¾æ¥ã€‚æ”¯æŒçš„é“¾æ¥æ ¼å¼ï¼šhttpsã€ipfsã€TON Storageã€‚ |
| cover_image  | å°†æ˜¾ç¤ºä¸ºé›†åˆå°é¢å›¾ç‰‡çš„å›¾ç‰‡é“¾æ¥ã€‚                            |
| social_links | é¡¹ç›®ç¤¾äº¤åª’ä½“é…ç½®æ–‡ä»¶çš„é“¾æ¥åˆ—è¡¨ã€‚ä½¿ç”¨ä¸è¶…è¿‡10ä¸ªé“¾æ¥ã€‚                 |

![image](/img/tutorials/nft/collection-metadata.png)

æ ¹æ®è¿™äº›ä¿¡æ¯ï¼Œè®©æˆ‘ä»¬åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„å…ƒæ•°æ®æ–‡ä»¶`collection.json`ï¼Œå®ƒå°†æè¿°æˆ‘ä»¬é›†åˆçš„å…ƒæ•°æ®ï¼

```json
{
  "name": "Ducks on TON",
  "description": "This collection is created for showing an example of minting NFT collection on TON. You can support creator by buying one of this NFT.",
  "social_links": ["https://t.me/DucksOnTON"]
}
```

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬æ²¡æœ‰å†™"image"å‚æ•°ï¼Œç¨åä½ ä¼šçŸ¥é“åŸå› ï¼Œè¯·ç¨ç­‰ï¼

åœ¨åˆ›å»ºäº†é›†åˆçš„å…ƒæ•°æ®æ–‡ä»¶ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºæˆ‘ä»¬NFTçš„å…ƒæ•°æ®ã€‚

NFTé¡¹ç›®å…ƒæ•°æ®çš„è§„èŒƒï¼š

| åç§°                                | è§£é‡Š                                                                                                            |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| name                              | NFTåç§°ã€‚æ¨èé•¿åº¦ï¼šä¸è¶…è¿‡15-30ä¸ªå­—ç¬¦                                                                                        |
| description                       | NFTæè¿°ã€‚æ¨èé•¿åº¦ï¼šä¸è¶…è¿‡500ä¸ªå­—ç¬¦                                                                                          |
| image                             | NFTå›¾ç‰‡é“¾æ¥ã€‚                                                                                                      |
| attributes                        | NFTå±æ€§ã€‚å±æ€§åˆ—è¡¨ï¼Œå…¶ä¸­æŒ‡å®šäº†trait_type (å±æ€§åç§°)å’Œvalue (å±æ€§çš„ç®€çŸ­æè¿°)ã€‚ |
| lottie                            | LottieåŠ¨ç”»çš„jsonæ–‡ä»¶é“¾æ¥ã€‚å¦‚æœæŒ‡å®šï¼Œåœ¨NFTé¡µé¢å°†æ’­æ”¾æ¥è‡ªæ­¤é“¾æ¥çš„LottieåŠ¨ç”»ã€‚                                                               |
| content_url  | é¢å¤–å†…å®¹çš„é“¾æ¥ã€‚                                                                                                      |
| content_type | é€šè¿‡content_urlé“¾æ¥æ·»åŠ çš„å†…å®¹çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œè§†é¢‘/mp4æ–‡ä»¶ã€‚                                                     |

![image](/img/tutorials/nft/item-metadata.png)

```json
{
  "name": "Duck #00",
  "description": "What about a round of golf?",
  "attributes": [{ "trait_type": "Awesomeness", "value": "Super cool" }]
}
```

ä¹‹åï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦åˆ›å»ºå°½å¯èƒ½å¤šçš„NFTé¡¹ç›®åŠå…¶å…ƒæ•°æ®æ–‡ä»¶ã€‚

### ä¸Šä¼ å…ƒæ•°æ®

ç°åœ¨è®©æˆ‘ä»¬ç¼–å†™ä¸€äº›ä»£ç ï¼Œå°†æˆ‘ä»¬çš„å…ƒæ•°æ®æ–‡ä»¶ä¸Šä¼ åˆ°IPFSã€‚åˆ›å»º `metadata.ts` æ–‡ä»¶å¹¶æ·»åŠ æ‰€éœ€çš„å¯¼å…¥ï¼š

```ts
import pinataSDK from "@pinata/sdk";
import { readdirSync } from "fs";
import { writeFile, readFile } from "fs/promises";
import path from "path";
```

ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å°†æŠŠæˆ‘ä»¬æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰æ–‡ä»¶å®é™…ä¸Šä¼ åˆ°IPFSï¼š

```ts
export async function uploadFolderToIPFS(folderPath: string): Promise<string> {
  const pinata = new pinataSDK({
    pinataApiKey: process.env.PINATA_API_KEY,
    pinataSecretApiKey: process.env.PINATA_API_SECRET,
  });

  const response = await pinata.pinFromFS(folderPath);
  return response.IpfsHash;
}
```

å¤ªæ£’äº†ï¼è®©æˆ‘ä»¬å›åˆ°ä¹‹å‰çš„é—®é¢˜ï¼šä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨å…ƒæ•°æ®æ–‡ä»¶ä¸­ç•™ä¸‹äº†â€œimageâ€å­—æ®µä¸ºç©ºï¼Ÿæƒ³è±¡ä¸€ä¸‹ä½ æƒ³åœ¨ä½ çš„é›†åˆä¸­åˆ›å»º1000ä¸ªNFTï¼Œå¹¶ä¸”ä½ å¿…é¡»æ‰‹åŠ¨éå†æ¯ä¸ªé¡¹ç›®å¹¶æ‰‹åŠ¨æ’å…¥å›¾ç‰‡é“¾æ¥ã€‚
è¿™çœŸçš„å¾ˆä¸æ–¹ä¾¿ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è‡ªåŠ¨å®Œæˆè¿™ä¸ªæ“ä½œï¼

```ts
export async function updateMetadataFiles(metadataFolderPath: string, imagesIpfsHash: string): Promise<void> {
  const files = readdirSync(metadataFolderPath);

  files.forEach(async (filename, index) => {
    const filePath = path.join(metadataFolderPath, filename)
    const file = await readFile(filePath);
    
    const metadata = JSON.parse(file.toString());
    metadata.image =
      index != files.length - 1
        ? `ipfs://${imagesIpfsHash}/${index}.jpg`
        : `ipfs://${imagesIpfsHash}/logo.jpg`;
    
    await writeFile(filePath, JSON.stringify(metadata));
  });
}
```

è¿™é‡Œæˆ‘ä»¬é¦–å…ˆè¯»å–æŒ‡å®šæ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰æ–‡ä»¶ï¼š

```ts
const files = readdirSync(metadataFolderPath);
```

éå†æ¯ä¸ªæ–‡ä»¶å¹¶è·å–å…¶å†…å®¹

```ts
const filePath = path.join(metadataFolderPath, filename)
const file = await readFile(filePath);

const metadata = JSON.parse(file.toString());
```

ä¹‹åï¼Œå¦‚æœä¸æ˜¯æ–‡ä»¶å¤¹ä¸­çš„æœ€åä¸€ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä»¬å°†å›¾åƒå­—æ®µçš„å€¼åˆ†é…ä¸º `ipfs://{IpfsHash}/{index}.jpg`ï¼Œå¦åˆ™ä¸º `ipfs://{imagesIpfsHash}/logo.jpg` å¹¶å®é™…ç”¨æ–°æ•°æ®é‡å†™æˆ‘ä»¬çš„æ–‡ä»¶ã€‚

metadata.ts çš„å®Œæ•´ä»£ç ï¼š

```ts
import pinataSDK from "@pinata/sdk";
import { readdirSync } from "fs";
import { writeFile, readFile } from "fs/promises";
import path from "path";

export async function uploadFolderToIPFS(folderPath: string): Promise<string> {
  const pinata = new pinataSDK({
    pinataApiKey: process.env.PINATA_API_KEY,
    pinataSecretApiKey: process.env.PINATA_API_SECRET,
  });

  const response = await pinata.pinFromFS(folderPath);
  return response.IpfsHash;
}

export async function updateMetadataFiles(metadataFolderPath: string, imagesIpfsHash: string): Promise<void> {
  const files = readdirSync(metadataFolderPath);

  files.forEach(async (filename, index) => {
    const filePath = path.join(metadataFolderPath, filename)
    const file = await readFile(filePath);
    
    const metadata = JSON.parse(file.toString());
    metadata.image =
      index != files.length - 1
        ? `ipfs://${imagesIpfsHash}/${index}.jpg`
        : `ipfs://${imagesIpfsHash}/logo.jpg`;
    
    await writeFile(filePath, JSON.stringify(metadata));
  });
}
```

å¤ªå¥½äº†ï¼Œè®©æˆ‘ä»¬åœ¨æˆ‘ä»¬çš„ app.ts æ–‡ä»¶ä¸­è°ƒç”¨è¿™äº›æ–¹æ³•ã€‚
æ·»åŠ æˆ‘ä»¬å‡½æ•°çš„å¯¼å…¥ï¼š

```ts
import { updateMetadataFiles, uploadFolderToIPFS } from "./metadata";
```

ä¿å­˜å…ƒæ•°æ®/å›¾ç‰‡æ–‡ä»¶å¤¹è·¯å¾„å˜é‡å¹¶è°ƒç”¨æˆ‘ä»¬çš„å‡½æ•°ä¸Šä¼ å…ƒæ•°æ®ã€‚

```ts
async function init() {
  const metadataFolderPath = "./data/metadata/";
  const imagesFolderPath = "./data/images/";

  const wallet = await openWallet(process.env.MNEMONIC!.split(" "), true);

  console.log("Started uploading images to IPFS...");
  const imagesIpfsHash = await uploadFolderToIPFS(imagesFolderPath);
  console.log(
    `Successfully uploaded the pictures to ipfs: https://gateway.pinata.cloud/ipfs/${imagesIpfsHash}`
  );

  console.log("Started uploading metadata files to IPFS...");
  await updateMetadataFiles(metadataFolderPath, imagesIpfsHash);
  const metadataIpfsHash = await uploadFolderToIPFS(metadataFolderPath);
  console.log(
    `Successfully uploaded the metadata to ipfs: https://gateway.pinata.cloud/ipfs/${metadataIpfsHash}`
  );
}
```

ä¹‹åä½ å¯ä»¥è¿è¡Œ `yarn start` å¹¶æŸ¥çœ‹éƒ¨ç½²çš„å…ƒæ•°æ®é“¾æ¥ï¼

### ç¼–ç ç¦»çº¿å†…å®¹

æˆ‘ä»¬å¦‚ä½•å°†é“¾æ¥åˆ°æ™ºèƒ½åˆçº¦ä¸­å­˜å‚¨çš„å…ƒæ•°æ®æ–‡ä»¶ï¼Ÿè¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡[Token Data æ ‡å‡†](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md)å¾—åˆ°å®Œå…¨å›ç­”ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä»…ä»…æä¾›æ‰€éœ€çš„æ ‡å¿—å¹¶ä»¥ASCIIå­—ç¬¦æä¾›é“¾æ¥æ˜¯ä¸å¤Ÿçš„ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨è›‡å½¢æ ¼å¼å°†æˆ‘ä»¬çš„é“¾æ¥åˆ†æˆå‡ ä¸ªéƒ¨åˆ†çš„é€‰é¡¹ã€‚

é¦–å…ˆåˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå°†æˆ‘ä»¬çš„ç¼“å†²åŒºè½¬æ¢æˆå—ï¼š

```ts
function bufferToChunks(buff: Buffer, chunkSize: number) {
  const chunks: Buffer[] = [];
  while (buff.byteLength > 0) {
    chunks.push(buff.subarray(0, chunkSize));
    buff = buff.subarray(chunkSize);
  }
  return chunks;
}
```

å¹¶åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå°†æ‰€æœ‰å—ç»‘å®šæˆ1ä¸ªè›‡å½¢cellï¼š

```ts
function makeSnakeCell(data: Buffer): Cell {
  const chunks = bufferToChunks(data, 127);

  if (chunks.length === 0) {
    return beginCell().endCell();
  }

  if (chunks.length === 1) {
    return beginCell().storeBuffer(chunks[0]).endCell();
  }

  let curCell = beginCell();

  for (let i = chunks.length - 1; i >= 0; i--) {
    const chunk = chunks[i];

    curCell.storeBuffer(chunk);

    if (i - 1 >= 0) {
      const nextCell = beginCell();
      nextCell.storeRef(curCell);
      curCell = nextCell;
    }
  }

  return curCell.endCell();
}
```

æœ€åï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œä½¿ç”¨è¿™äº›å‡½æ•°å°†ç¦»çº¿å†…å®¹ç¼–ç ä¸ºcellï¼š

```ts
export function encodeOffChainContent(content: string) {
  let data = Buffer.from(content);
  const offChainPrefix = Buffer.from([0x01]);
  data = Buffer.concat([offChainPrefix, data]);
  return makeSnakeCell(data);
}
```

## ğŸš¢ éƒ¨ç½² NFT é›†åˆ

å½“æˆ‘ä»¬çš„å…ƒæ•°æ®å·²ç»å‡†å¤‡å¥½å¹¶ä¸”å·²ç»ä¸Šä¼ åˆ°IPFSæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹éƒ¨ç½²æˆ‘ä»¬çš„é›†åˆäº†ï¼

æˆ‘ä»¬å°†åœ¨ `/contracts/NftCollection.ts` æ–‡ä»¶ä¸­åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å°†å­˜å‚¨ä¸æˆ‘ä»¬çš„é›†åˆç›¸å…³çš„æ‰€æœ‰é€»è¾‘ã€‚æˆ‘ä»¬å°†ä»å¯¼å…¥å¼€å§‹ï¼š

```ts
import {
  Address,
  Cell,
  internal,
  beginCell,
  contractAddress,
  StateInit,
  SendMode,
} from "ton-core";
import { encodeOffChainContent, OpenedWallet } from "../utils";
```

å¹¶å£°æ˜ä¸€ä¸ªç±»å‹ï¼Œå®ƒå°†æè¿°æˆ‘ä»¬é›†åˆæ‰€éœ€çš„åˆå§‹åŒ–æ•°æ®ï¼š

```ts
export type collectionData = {
  ownerAddress: Address;
  royaltyPercent: number;
  royaltyAddress: Address;
  nextItemIndex: number;
  collectionContentUrl: string;
  commonContentUrl: string;
}
```

| åç§°                   | è§£é‡Š                             |
| -------------------- | ------------------------------ |
| ownerAddress         | å°†è¢«è®¾ç½®ä¸ºæˆ‘ä»¬é›†åˆçš„æ‰€æœ‰è€…çš„åœ°å€ã€‚åªæœ‰æ‰€æœ‰è€…èƒ½å¤Ÿé“¸é€ æ–°NFT |
| royaltyPercent       | æ¯æ¬¡é”€å”®é‡‘é¢çš„ç™¾åˆ†æ¯”ï¼Œå°†è½¬åˆ°æŒ‡å®šåœ°å€             |
| royaltyAddress       | å°†ä»è¿™ä¸ªNFTé›†åˆçš„é”€å”®ä¸­æ¥æ”¶ç‰ˆç¨çš„é’±åŒ…åœ°å€         |
| nextItemIndex        | ä¸‹ä¸€ä¸ªNFTé¡¹ç›®åº”è¯¥æœ‰çš„ç´¢å¼•                 |
| collectionContentUrl | é›†åˆå…ƒæ•°æ®çš„URL                      |
| commonContentUrl     | NFTé¡¹ç›®å…ƒæ•°æ®çš„åŸºç¡€URL                 |

é¦–å…ˆç¼–å†™ä¸€ä¸ªç§æœ‰æ–¹æ³•ï¼Œç”¨äºè¿”å›å¸¦æœ‰æˆ‘ä»¬é›†åˆä»£ç çš„cellï¼š

```ts
export class NftCollection {
  private collectionData: collectionData;

  constructor(collectionData: collectionData) {
    this.collectionData = collectionData;
  }

  private createCodeCell(): Cell {
    const NftCollectionCodeBoc =
      "te6cckECFAEAAh8AART/APSkE/S88sgLAQIBYgkCAgEgBAMAJbyC32omh9IGmf6mpqGC3oahgsQCASAIBQIBIAcGAC209H2omh9IGmf6mpqGAovgngCOAD4AsAAvtdr9qJofSBpn+pqahg2IOhph+mH/SAYQAEO4tdMe1E0PpA0z/U1NQwECRfBNDUMdQw0HHIywcBzxbMyYAgLNDwoCASAMCwA9Ra8ARwIfAFd4AYyMsFWM8WUAT6AhPLaxLMzMlx+wCAIBIA4NABs+QB0yMsCEsoHy//J0IAAtAHIyz/4KM8WyXAgyMsBE/QA9ADLAMmAE59EGOASK3wAOhpgYC42Eit8H0gGADpj+mf9qJofSBpn+pqahhBCDSenKgpQF1HFBuvgoDoQQhUZYBWuEAIZGWCqALnixJ9AQpltQnlj+WfgOeLZMAgfYBwGyi544L5cMiS4ADxgRLgAXGBEuAB8YEYGYHgAkExIREAA8jhXU1DAQNEEwyFAFzxYTyz/MzMzJ7VTgXwSED/LwACwyNAH6QDBBRMhQBc8WE8s/zMzMye1UAKY1cAPUMI43gED0lm+lII4pBqQggQD6vpPywY/egQGTIaBTJbvy9AL6ANQwIlRLMPAGI7qTAqQC3gSSbCHis+YwMlBEQxPIUAXPFhPLP8zMzMntVABgNQLTP1MTu/LhklMTugH6ANQwKBA0WfAGjhIBpENDyFAFzxYTyz/MzMzJ7VSSXwXiN0CayQ==";
    return Cell.fromBase64(NftCollectionCodeBoc);
  }
}
```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯ä»é›†åˆæ™ºèƒ½åˆçº¦çš„base64è¡¨ç¤ºä¸­è¯»å–cellã€‚

å‰©ä¸‹çš„åªæœ‰æˆ‘ä»¬é›†åˆåˆå§‹åŒ–æ•°æ®çš„celläº†ã€‚

```ts
private createDataCell(): Cell {
  const data = this.collectionData;
  const dataCell = beginCell();

  dataCell.storeAddress(data.ownerAddress);
  dataCell.storeUint(data.nextItemIndex, 64);
```

Next after that, we creating an empty cell that will store content of our collection, and after that store ref to the cell with encoded content of our collection. And right after that store ref to contentCell in our main data cell.

```ts
const contentCell = beginCell();

const collectionContent = encodeOffChainContent(data.collectionContentUrl);

const commonContent = beginCell();
commonContent.storeBuffer(Buffer.from(data.commonContentUrl));

contentCell.storeRef(collectionContent);
contentCell.storeRef(commonContent.asCell());
dataCell.storeRef(contentCell);
```

After that we just create cell of code of NFT item's, that will be created in our collection, and store ref to this cell in dataCell

```ts
const NftItemCodeCell = Cell.fromBase64(
  "te6cckECDQEAAdAAART/APSkE/S88sgLAQIBYgMCAAmhH5/gBQICzgcEAgEgBgUAHQDyMs/WM8WAc8WzMntVIAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAgEgCQgAET6RDBwuvLhTYALXDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAw8AIEs44UMGwiNFIyxwXy4ZUB+kDUMBAj8APgBtMf0z+CEF/MPRRSMLqOhzIQN14yQBPgMDQ0NTWCEC/LJqISuuMCXwSED/LwgCwoAcnCCEIt3FzUFyMv/UATPFhAkgEBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAH2UTXHBfLhkfpAIfAB+kDSADH6AIIK+vCAG6EhlFMVoKHeItcLAcMAIJIGoZE24iDC//LhkiGOPoIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHlBAqN1viDACCAo41JvABghDVMnbbEDdEAG1xcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wCTMDI04lUC8ANqhGIu"
);
dataCell.storeRef(NftItemCodeCell);
```

Royalty params stored in smart-contract by royaltyFactor, royaltyBase, royaltyAddress. Percentage of royalty can be calculated with the formula `(royaltyFactor / royaltyBase) * 100%`. So if we know royaltyPercent it's not a problem to get royaltyFactor.

```ts
const royaltyBase = 1000;
const royaltyFactor = Math.floor(data.royaltyPercent * royaltyBase);
```

After our calculations we need to store royalty data in separate cell and provide ref to this cell in dataCell.

```ts
const royaltyCell = beginCell();
royaltyCell.storeUint(royaltyFactor, 16);
royaltyCell.storeUint(royaltyBase, 16);
royaltyCell.storeAddress(data.royaltyAddress);
dataCell.storeRef(royaltyCell);

return dataCell.endCell();
}
```

Now let's actually write getter, that will return StateInit of our collection:

```ts
public get stateInit(): StateInit {
  const code = this.createCodeCell();
  const data = this.createDataCell();

  return { code, data };
}
```

And getter, that will calculate Address of our collection(address of smart-contract in TON is just hash of it's StateInit)

```ts
public get address(): Address {
    return contractAddress(0, this.stateInit);
  }
```

It remains only to write method, that will deploy the smart contract to the blockchain!

```ts
public async deploy(wallet: OpenedWallet) {
    const seqno = await wallet.contract.getSeqno();
    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.05",
          to: this.address,
          init: this.stateInit,
        }),
      ],
      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
    });
    return seqno;
  }
```

Deploy of new smart contract in our case - it's just sending a message from our wallet to the collection address(which one we can calculate if we have StateInit), with its StateInit!

åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œéƒ¨ç½²æ–°æ™ºèƒ½åˆçº¦å°±æ˜¯ä»æˆ‘ä»¬çš„é’±åŒ…å‘é›†åˆåœ°å€ï¼ˆå¦‚æœæˆ‘ä»¬æœ‰StateInitï¼Œåˆ™å¯ä»¥è®¡ç®—å‡ºæ­¤åœ°å€ï¼‰å‘é€æ¶ˆæ¯ï¼

```ts
public async topUpBalance(
    wallet: OpenedWallet,
    nftAmount: number
  ): Promise<number> {
    const feeAmount = 0.026 // approximate value of fees for 1 transaction in our case 
    const seqno = await wallet.contract.getSeqno();
    const amount = nftAmount * feeAmount;

    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: amount.toString(),
          to: this.address.toString({ bounceable: false }),
          body: new Cell(),
        }),
      ],
      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
    });

    return seqno;
  }
```

Perfect, let's now add few lines to our `app.ts` to deploy new collection:

```ts
console.log("Start deploy of nft collection...");
const collectionData = {
  ownerAddress: wallet.contract.address,
  royaltyPercent: 0.05, // 0.05 = 5%
  royaltyAddress: wallet.contract.address,
  nextItemIndex: 0,
  collectionContentUrl: `ipfs://${metadataIpfsHash}/collection.json`,
  commonContentUrl: `ipfs://${metadataIpfsHash}/`,
};
const collection = new NftCollection(collectionData);
let seqno = await collection.deploy(wallet);
console.log(`Collection deployed: ${collection.address}`);
await waitSeqno(seqno, wallet);
```

## ğŸš¢ Deploy NFT Items

When our collection is ready, we can start minting our NFT! We will store code in `src/contracts/NftItem.ts`

å½“æˆ‘ä»¬çš„æ”¶è—å‡†å¤‡å¥½åï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹é“¸é€ æˆ‘ä»¬çš„NFTï¼æˆ‘ä»¬å°†å­˜å‚¨ä»£ç åœ¨`src/contracts/NftItem.ts`

```ts
export type mintParams = {
  queryId: number | null,
  itemOwnerAddress: Address,
  itemIndex: number,
  amount: bigint,
  commonContentUrl: string
}
```

| Name             | Explanation                                                                                            |
| ---------------- | ------------------------------------------------------------------------------------------------------ |
| itemOwnerAddress | Address that will be set as owner of item                                                              |
| itemIndex        | Index of NFT Item                                                                                      |
| amount           | Amount of TON, that will be sent to the NFT with deploy                                                |
| commonContentUrl | The full link to the Item URL can be shown as "commonContentUrl" of collection + this commonContentUrl |

And create method in NftCollection class, that will construct body for the deploy of our NFT Item. Firstly store bit, that will indicate to collection smart contract that we want to create new NFT. After that just store queryId & index of this NFT Item.

```ts
public createMintBody(params: mintParams): Cell {
    const body = beginCell();
    body.storeUint(1, 32);
    body.storeUint(params.queryId || 0, 64);
    body.storeUint(params.itemIndex, 64);
    body.storeCoins(params.amount);
  }
```

Later on create an empty cell and store owner address of this NFT:

```ts
    const nftItemContent = beginCell();
    nftItemContent.storeAddress(params.itemOwnerAddress);
```

And store ref in this cell(with NFT Item content) ref to the metadata of this item:

```ts
const uriContent = beginCell();
uriContent.storeBuffer(Buffer.from(params.commonContentUrl));
nftItemContent.storeRef(uriContent.endCell());
```

Store ref to cell with item content in our body cell:

```ts
body.storeRef(nftItemContent.endCell());
return body.endCell();
```

Great! Now we can comeback to `NftItem.ts`. All we have to do is just send message to our collection contract with body of our NFT.

```ts
import { internal, SendMode } from "ton-core";
import { OpenedWallet } from "utils";
import { NftCollection, mintParams } from "./NftCollection";

export class NftItem {
  private collection: NftCollection;

  constructor(collection: NftCollection) {
    this.collection = collection;
  }

  public async deploy(
    wallet: OpenedWallet,
    params: mintParams
  ): Promise<number> {
    const seqno = await wallet.contract.getSeqno();
    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.05",
          to: this.collection.address,
          body: this.collection.createMintBody(params),
        }),
      ],
      sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
    });
    return seqno;
  }
}
```

By the end, we will write short method, that will get address of NFT by it's index.

æœ€åï¼Œæˆ‘ä»¬å°†ç¼–å†™ç®€çŸ­æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†é€šè¿‡å…¶ç´¢å¼•è·å–NFTçš„åœ°å€ã€‚

```ts
static async getAddressByIndex(
  collectionAddress: Address,
  itemIndex: number
): Promise<Address> {
  const client = new TonClient({
    endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
    apiKey: process.env.TONCENTER_API_KEY,
  });
}
```

Then we will call get-method of collection, that will return address of NFT in this collection with such index

```ts
const response = await client.runMethod(
  collectionAddress,
  "get_nft_address_by_index",
  [{ type: "int", value: BigInt(itemIndex) }]
);
```

... and parse this address!

```ts
return response.stack.readAddress();
```

Now let's add some code in `app.ts`, to automate the minting process of each NFT. Firstly read all of the files in folder with our metadata:

```ts
const files = await readdir(metadataFolderPath);
files.pop();
let index = 0;
```

Secondly top up balance of our collection:

```ts
seqno = await collection.topUpBalance(wallet, files.length);
await waitSeqno(seqno, wallet);
console.log(`Balance top-upped`);
```

Eventually, go through each file with metadata, create `NftItem` instance and call deploy method. After that we need to wait a bit, until the seqno increases:

```ts
for (const file of files) {
    console.log(`Start deploy of ${index + 1} NFT`);
    const mintParams = {
      queryId: 0,
      itemOwnerAddress: wallet.contract.address,
      itemIndex: index,
      amount: toNano("0.05"),
      commonContentUrl: file,
    };

    const nftItem = new NftItem(collection);
    seqno = await nftItem.deploy(wallet, mintParams);
    console.log(`Successfully deployed ${index + 1} NFT`);
    await waitSeqno(seqno, wallet);
    index++;
  }
```

## ğŸ· Put NFT on sale

In order to put the nft for sale, we need two smart contracts.

- Marketplace, which is responsible only for logic of creating new sales
- Sale contract, which is responsible for the logic of buying/cancelling a sale

### Deploy marketplace

Create new file in `/contracts/NftMarketplace.ts`. As usual create basic class, which will accept address of owner of this marketplace and create cell with code(we will use [basic version of NFT-Marketplace smart-contract](https://github.com/ton-blockchain/token-contract/blob/main/nft/nft-marketplace.fc)) of this smart contract & initial data.

```ts
import {
  Address,
  beginCell,
  Cell,
  contractAddress,
  internal,
  SendMode,
  StateInit,
} from "ton-core";
import { OpenedWallet } from "utils";

export class NftMarketplace {
  public ownerAddress: Address;

  constructor(ownerAddress: Address) {
    this.ownerAddress = ownerAddress;
  }


  public get stateInit(): StateInit {
    const code = this.createCodeCell();
    const data = this.createDataCell();

    return { code, data };
  }

  private createDataCell(): Cell {
    const dataCell = beginCell();

    dataCell.storeAddress(this.ownerAddress);

    return dataCell.endCell();
  }

  private createCodeCell(): Cell {
    const NftMarketplaceCodeBoc = "te6cckEBBAEAbQABFP8A9KQT9LzyyAsBAgEgAgMAqtIyIccAkVvg0NMDAXGwkVvg+kDtRND6QDASxwXy4ZEB0x8BwAGOK/oAMAHU1DAh+QBwyMoHy//J0Hd0gBjIywXLAljPFlAE+gITy2vMzMlx+wCRW+IABPIwjvfM5w==";
    return Cell.fromBase64(NftMarketplaceCodeBoc)
  }
}
```

And let's create method, that will calculate address of our smart contract based on StateInit:

```ts
public get address(): Address {
    return contractAddress(0, this.stateInit);
  }
```

After that we need to create method, that will deploy our marketplace actually:

```ts
public async deploy(wallet: OpenedWallet): Promise<number> {
    const seqno = await wallet.contract.getSeqno();
    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.5",
          to: this.address,
          init: this.stateInit,
        }),
      ],
      sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
    });
    return seqno;
  }
```

As you can see, this code does not differ from the deployment of other smart contracts (nft-item smart contract, from the deployment of a new collection). The only thing is that you can see that we initially replenish our marketplace not by 0.05 TON, but by 0.5. What is the reason for this?  When a new smart sales contract is deployed, the marketplace accepts the request, processes it, and sends a message to the new contract (yes, the situation is similar to the situation with the NFT collection). Which is why we need a little extra tone to pay fees.

å¦‚æ‚¨æ‰€è§ï¼Œè¿™æ®µä»£ç ä¸å…¶ä»–æ™ºèƒ½åˆçº¦çš„éƒ¨ç½²ï¼ˆnft-itemæ™ºèƒ½åˆçº¦ï¼Œæ–°é›†åˆçš„éƒ¨ç½²ï¼‰å¹¶æ— ä¸åŒã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯æ‚¨å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æœ€åˆä¸æ˜¯ç”¨0.05 TONè€Œæ˜¯ç”¨0.5 TONä¸ºæˆ‘ä»¬çš„å¸‚åœºå……å€¼ã€‚è¿™æ˜¯ä»€ä¹ˆåŸå› å‘¢ï¼Ÿå½“éƒ¨ç½²æ–°çš„æ™ºèƒ½é”€å”®åˆçº¦æ—¶ï¼Œå¸‚åœºæ¥å—è¯·æ±‚ï¼Œå¤„ç†å®ƒï¼Œå¹¶å‘æ–°åˆçº¦å‘é€æ¶ˆæ¯ï¼ˆæ˜¯çš„ï¼Œæƒ…å†µç±»ä¼¼äºNFTé›†åˆï¼‰ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦é¢å¤–çš„TONæ¥æ”¯ä»˜è´¹ç”¨ã€‚

```ts
console.log("Start deploy of new marketplace  ");
const marketplace = new NftMarketplace(wallet.contract.address);
seqno = await marketplace.deploy(wallet);
await waitSeqno(seqno, wallet);
console.log("Successfully deployed new marketplace");
```

### Deploy sale contract

Great! Right now we can already deploy smart contract of our NFT sale. How it will works? We need to deploy new contract, and after that "transfer" our nft to sale contract(in other words, we just need to change owner of our NFT to sale contract in item data). In this tutorial we will use [nft-fixprice-sale-v2](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v2.fc) sale smart contract.

å¤ªå¥½äº†ï¼ç°åœ¨æˆ‘ä»¬å·²ç»å¯ä»¥éƒ¨ç½²æˆ‘ä»¬NFTé”€å”®çš„æ™ºèƒ½åˆçº¦äº†ã€‚å®ƒå°†å¦‚ä½•å·¥ä½œï¼Ÿæˆ‘ä»¬éœ€è¦éƒ¨ç½²æ–°åˆçº¦ï¼Œä¹‹åå°†æˆ‘ä»¬çš„nftâ€œè½¬è®©â€ç»™é”€å”®åˆçº¦ï¼ˆæ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬åªéœ€æ”¹å˜æˆ‘ä»¬NFTçš„æ‰€æœ‰è€…ä¸ºé”€å”®åˆçº¦ä¸­çš„æ•°æ®é¡¹ï¼‰ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨[nft-fixprice-sale-v2](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v2.fc)é”€å”®æ™ºèƒ½åˆçº¦ã€‚

```ts
import {
  Address,
  beginCell,
  Cell,
  contractAddress,
  internal,
  SendMode,
  StateInit,
  storeStateInit,
  toNano,
} from "ton-core";
import { OpenedWallet } from "utils";

export type GetGemsSaleData = {
  isComplete: boolean;
  createdAt: number;
  marketplaceAddress: Address;
  nftAddress: Address;
  nftOwnerAddress: Address | null;
  fullPrice: bigint;
  marketplaceFeeAddress: Address;
  marketplaceFee: bigint;
  royaltyAddress: Address;
  royaltyAmount: bigint;
};
```

And now let's create class, and basic method, that will create init data cell for our smart-contract.

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºç±»ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªåŸºæœ¬æ–¹æ³•ï¼Œç”¨äºä¸ºæˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦åˆ›å»ºåˆå§‹åŒ–æ•°æ®cellã€‚

```ts
export class NftSale {
  private data: GetGemsSaleData;

  constructor(data: GetGemsSaleData) {
    this.data = data;
  }

  private createDataCell(): Cell {
    const saleData = this.data;

    const feesCell = beginCell();

    feesCell.storeAddress(saleData.marketplaceFeeAddress);
    feesCell.storeCoins(saleData.marketplaceFee);
    feesCell.storeAddress(saleData.royaltyAddress);
    feesCell.storeCoins(saleData.royaltyAmount);
  }
}
```

Following that we can create an empty cell and just store in it information from saleData in correct order and right after that store ref to the cell with the fees information:

```ts
const dataCell = beginCell();

dataCell.storeUint(saleData.isComplete ? 1 : 0, 1);
dataCell.storeUint(saleData.createdAt, 32);
dataCell.storeAddress(saleData.marketplaceAddress);
dataCell.storeAddress(saleData.nftAddress);
dataCell.storeAddress(saleData.nftOwnerAddress);
dataCell.storeCoins(saleData.fullPrice);
dataCell.storeRef(feesCell.endCell());

return dataCell.endCell();
```

And as always add method's to get stateInit, init code cell and address of our smart contract.

```ts
public get address(): Address {
  return contractAddress(0, this.stateInit);
}

public get stateInit(): StateInit {
  const code = this.createCodeCell();
  const data = this.createDataCell();

  return { code, data };
}

private createCodeCell(): Cell {
  const NftFixPriceSaleV2CodeBoc =
    "te6cckECDAEAAikAART/APSkE/S88sgLAQIBIAMCAATyMAIBSAUEAFGgOFnaiaGmAaY/9IH0gfSB9AGoYaH0gfQB9IH0AGEEIIySsKAVgAKrAQICzQgGAfdmCEDuaygBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkHCAEMjLBVADzxYB+gLLaslx+wAlwgAl10nCArCOF1BFcIAQyMsFUAPPFgH6AstqyXH7ABAjkjQ04lpwgBDIywVQA88WAfoCy2rJcfsAcCCCEF/MPRSBwCCIYAYyMsFKs8WIfoCy2rLHxPLPyPPFlADzxbKACH6AsoAyYMG+wBxVVAGyMsAFcsfUAPPFgHPFgHPFgH6AszJ7VQC99AOhpgYC42EkvgnB9IBh2omhpgGmP/SB9IH0gfQBqGBNgAPloyhFrpOEBWccgGRwcKaDjgskvhHAoomOC+XD6AmmPwQgCicbIiV15cPrpn5j9IBggKwNkZYAK5Y+oAeeLAOeLAOeLAP0BZmT2qnAbE+OAcYED6Y/pn5gQwLCQFKwAGSXwvgIcACnzEQSRA4R2AQJRAkECPwBeA6wAPjAl8JhA/y8AoAyoIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxnLPyfPFifPFhjKACf6AhfKAMmAQPsAcQZQREUVBsjLABXLH1ADzxYBzxYBzxYB+gLMye1UABY3EDhHZRRDMHDwBTThaBI=";

  return Cell.fromBase64(NftFixPriceSaleV2CodeBoc);
}
```

It remains only to form a message that we will send to our marketplace to deploy sale contract and actually send this message

åªå‰©ä¸‹åˆ›å»ºæˆ‘ä»¬å°†å‘é€åˆ°æˆ‘ä»¬å¸‚åœºçš„æ¶ˆæ¯ä»¥éƒ¨ç½²é”€å”®åˆçº¦ï¼Œå¹¶å®é™…å‘é€æ­¤æ¶ˆæ¯

```ts
public async deploy(wallet: OpenedWallet): Promise<number> {
    const stateInit = beginCell()
      .store(storeStateInit(this.stateInit))
      .endCell();
}
```

Create cell with the body for our message. Firstly we need to set op-code to 1(to indicate marketplace, that we want to deploy new sale smart-contract). After that we need to store coins, that will be sent to our new sale smart-contract. And last of all we need to store 2 ref to stateInit of new smart-contract, and a body, that will be sent to this new smart-contract.

```ts
const payload = beginCell();
payload.storeUint(1, 32);
payload.storeCoins(toNano("0.05"));
payload.storeRef(stateInit);
payload.storeRef(new Cell());
```

And at the end let's send our message:

```ts
const seqno = await wallet.contract.getSeqno();
await wallet.contract.sendTransfer({
  seqno,
  secretKey: wallet.keyPair.secretKey,
  messages: [
    internal({
      value: "0.05",
      to: this.data.marketplaceAddress,
      body: payload.endCell(),
    }),
  ],
  sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
});
return seqno;
```

Perfect, when sale smart-contract is deployed all that's left is to change owner of our NFT Item to address of this sale.

### Transfer item

What does it mean to transfer an item? Simply send a message from the owner's wallet to the smart contract with information about who the new owner of the item is.

è½¬ç§»ä¸€ä¸ªé¡¹ç›®æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿåªéœ€ä»æ‰€æœ‰è€…çš„é’±åŒ…å‘æ™ºèƒ½åˆçº¦å‘é€æ¶ˆæ¯ï¼Œå‘ŠçŸ¥è°æ˜¯è¯¥é¡¹ç›®çš„æ–°æ‰€æœ‰è€…å³å¯ã€‚

è½¬åˆ°`NftItem.ts`ï¼Œå¹¶åœ¨NftItemç±»ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„é™æ€æ–¹æ³•ï¼Œç”¨äºåˆ›å»ºæ­¤ç±»æ¶ˆæ¯çš„ä¸»ä½“ï¼š

```ts
static createTransferBody(params: {
    newOwner: Address;
    responseTo?: Address;
    forwardAmount?: bigint;
  }): Cell {
    const msgBody = beginCell();
    msgBody.storeUint(0x5fcc3d14, 32); // op-code 
    msgBody.storeUint(0, 64); // query-id
    msgBody.storeAddress(params.newOwner);

  }
```

In addition to the op-code, query-id and address of the new owner, we must also store the address where to send a response with confirmation of a successful transfer and the rest of the incoming message coins. The amount of TON that will come to the new owner and whether he will receive a text payload.

```ts
msgBody.storeAddress(params.responseTo || null);
msgBody.storeBit(false); // no custom payload
msgBody.storeCoins(params.forwardAmount || 0);
msgBody.storeBit(0); // no forward_payload 

return msgBody.endCell();
```

And create a transfer function to transfer the NFT.

```ts
static async transfer(
    wallet: OpenedWallet,
    nftAddress: Address,
    newOwner: Address
  ): Promise<number> {
    const seqno = await wallet.contract.getSeqno();

    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.05",
          to: nftAddress,
          body: this.createTransferBody({
            newOwner,
            responseTo: wallet.contract.address,
            forwardAmount: toNano("0.02"),
          }),
        }),
      ],
      sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
    });
    return seqno;
  }
```

Nice, now we can we are already very close to the end. Back to the `app.ts` and let's get address of our nft, that we want to put on sale:

```ts
const nftToSaleAddress = await NftItem.getAddressByIndex(collection.address, 0);
```

Create variable, that will store information about our sale:

```ts
const saleData: GetGemsSaleData = {
  isComplete: false,
  createdAt: Math.ceil(Date.now() / 1000),
  marketplaceAddress: marketplace.address,
  nftAddress: nftToSaleAddress,
  nftOwnerAddress: null,
  fullPrice: toNano("10"),
  marketplaceFeeAddress: wallet.contract.address,
  marketplaceFee: toNano("1"),
  royaltyAddress: wallet.contract.address,
  royaltyAmount: toNano("0.5"),
};
```

Note, that we set nftOwnerAddress to null, because if we will do so, our sale contract would just accept our coins on deploy.

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å°†nftOwnerAddressè®¾ç½®ä¸ºnullï¼Œå› ä¸ºå¦‚æœè¿™æ ·åšï¼Œæˆ‘ä»¬çš„é”€å”®åˆçº¦å°†åªæ¥å—æˆ‘ä»¬éƒ¨ç½²æ—¶çš„å¸å€¼ã€‚

```ts
const nftSaleContract = new NftSale(saleData);
seqno = await nftSaleContract.deploy(wallet);
await waitSeqno(seqno, wallet);
```

... and transfer it!

```ts
await NftItem.transfer(wallet, nftToSaleAddress, nftSaleContract.address);
```

Now we can launch our project and enjoy the process!

```
yarn start
```

Go to https://testnet.getgems.io/collection/\<YOUR_COLLECTION_ADDRESS_HERE> and look to this perfect ducks!

## Conclusion

Today you have learned a lot of new things about TON and even created your own beautiful NFT collection in the testnet! If you still have any questions or have noticed an error - feel free to write to the author - [@coalus](https://t.me/coalus)

## References

- [GetGems NFT-contracts](https://github.com/getgems-io/nft-contracts)
- [NFT Standart](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md)

## About the author

- Coalus on [Telegram](https://t.me/coalus) or [GitHub](https://github.com/coalus)
