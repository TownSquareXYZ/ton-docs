import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 正在准备消息

使用 TON 连接时，您应该构造用于各种交易的有效载荷的消息机构。 在这个页面上，您可以找到最相关的有效载荷示例与TON Connect SDK一起使用。

:::info
预计您会在创建TON Connect连接时学习基础知识。 了解更多关于[集成手册](/develop/dapps/ton-connect/integration)
:::

## TON Connect JSSDK 示例

### 交易模板

无论任务开发者的解决级别如何，通常都需要使用来自@tonconnect/sdk或@tonconnect/ui的连接器实体。
基于 @tonconnect/sdk 和 @tonconnect/ui 创建的示例：

<Tabs groupId="TON Connect template">

<TabItem value="tonconnect-react" label="@tonconnect/ui-react">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
const [tonConnectUI] = useTonConnectUI();

const transaction = {
    //transaction body
})

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(transaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>
<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui';

const tonConnectUI = new TonConnectUI({ //connect application
    manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json',
    buttonRootId: '<YOUR_CONNECT_BUTTON_ANCHOR_ID>'
});

const transaction = {
    //transaction body
}

const result = await tonConnectUI.sendTransaction(transaction)

```

</TabItem>
<TabItem value="tonconnect-js" label="@tonconnect/sdk">

```js
从 '@tonconnect/sdk'导入TonConnect ;
const connector = new TonConnect();

等待connector.sendTransaction(w
    /交易正文
})

```

</TabItem>

</Tabs>

### 正则TON 传输

TON Connect SDK包括发送消息的包装器，这样就很容易准备两个钱包之间的常规Toncoins 作为没有有效载荷的默认交易。

使用 TON Connect JS SDK的常规TON 传输可以执行如下：

<Tabs groupId="Regular Transfer">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
const [tonConnectUI] = useTonConnectUI();

const transaction = {
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]

}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(transaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui';

const tonConnectUI = new TonConnectUI({ //connect application
    manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json',
    buttonRootId: '<YOUR_CONNECT_BUTTON_ANCHOR_ID>'
});

const transaction = {
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
const connector = new TonConnect();

await connector.sendTransaction({
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]
})

```

</TabItem>
</Tabs>

:::tip
了解更多关于 [TON Smart Contractions](/learn/overviews/addresses)
:::

对于特定的自定义交易，必须定义特定的有效载荷。

### 带有评论的传输

最简单的例子是添加一条带有评论的有效载荷。 详见[本页](/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)。
在交易之前，它必须通过[@ton/ton](https://github.com/ton-org/ton) JavaScript库准备一个 \`body' [cell](/develop/data-forms/cell-boc)。

```js
import { beginCell } from '@ton/ton'

const body = beginCell()
  .storeUint(0, 32) // write 32 zero bits to indicate that a text comment will follow
  .storeStringTail("Hello, TON!") // write our text comment
  .endCell();
```

交易机构由下列机构创建：

<Tabs groupId="Transfer With a Comment">

<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: destination,
            amount: toNano("0.05"),
            payload: body.toBoc().toString("base64") // payload with comment in body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
从 '@tonconnect/ui'

const transaction = 许诺.
    validUntil: Math.floor(Date). ow() / 1000) + 360,
    消息：[
        Power
            地址：目的地。
            金额: toNano("0" 同上，第5段，
            payload：body.toBoc()。 oString("base64") // payload, with comment in body
        }
    ]
}

const results = 等待tonConnectUI. 端交易(交易)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
const connector = new TonConnect();

await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: destination,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64") // payload with comment in body
    }
  ]
})
```

</TabItem>
</Tabs>

### Jetton Transfer

Jetton Transfer([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)) 通常应该按照以下方式进行：

```js
    import {beginCell, toNano} from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32)                 // jetton transfer op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(1000000)                      // amount:(VarUInteger 16) -  Jetton amount for transfer (decimals = 6 - jUSDT, 9 - default)
        .storeAddress(Wallet_DST)                 // destination:MsgAddress
        .storeAddress(Wallet_SRC)                 // response_destination:MsgAddress
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano(0.05))                 // forward_ton_amount:(VarUInteger 16) - if >0, will send notification message
        .storeUint(0,1)                           // forward_payload:(Either Cell ^Cell)
        .endCell();
```

接下来，将与该机构的交易发送给发送者的jettonWalletContract执行：

<Tabs groupId="Jetton Transfer">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract, // sender jetton wallet
            amount: toNano("0.05"), // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with jetton transfer body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
从 '@tonconnect/ui'

const transaction = 许诺.
    validUntil: Math.floor(Date). ow() / 1000) + 360,
    电文：[
        Power
            地址：jettonWallet Contract, // 发送者jetton钱包
            金额: toNano("0"). 5", // 收取佣金， 超量将返回
            有效载荷：体. oBoc(). oString("base64") // payload with jeton transfer body
        }
    ]
}

const results = 等待tonConnectUI. 端交易(交易)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
const connector = new TonConnect();
//...
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,            // sender jetton wallet
      amount: toNano("0.05"),                   // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64")  // payload with jetton transfer body
    }
  ]
})
```

</TabItem>
</Tabs>

- \`validUntil - UNIXtime 直到消息有效
- `jettonWalletAddress` - 地址，JettonWallet 地址，它是基于 JettonMaser 和 Wallet 合同定义的
- `balanc` - Integer, toncoin for gas paiement in nanton.
- `body` - jetton合同的payload

<details>
    <summary>Jetton Wallet State Init and Address preparing example</summary>

```js
Import Windows Address, TonClient, beginCell, StateInit, '@ton/ton'

async 函数main() 中的 storeStateInit }。请注意，
    const client = new TonClient(哇，
        endpoint: 'https://toncenter. om/api/v2/jsonRPC
        apiKey: '放置您的 api key'
    })

    const jettonWalletAddress = 地址。 arse('Sender_Jetton_Wallet');
    let jettonWalletDataResult = 等待client.runMethod(jettonWalletAddress, 'get_wallet_data');
    jettonWalletDataResult. tack.readNumber();
    const owners 地址 = jettonWalletDataResult.stack.readAddress();
    const jettonMasterAddress = jettonWalletDataResult. tack.readAddress();
    const jettonCode = jettonWalletDataResult.stack. eadCell();
    const jettonData = beginCell()
        . toreCoins(0)
        .storeAddress(所有者地址)
        toreAddress(jettonMasterAddress)
        toreRef(jettonCode)
        ndCell();

    const stateIn:StateInit = {
        code: jettonCode,
        data: jettonData
    }

    const stateInitcell = beginCell()
        tore(storeStateInit(stateInit))
        .endCell();

    console.log(new Address(0, stateInitCell.hash());
}
```

</details>

### 有评论的Jetton Transfer

Jetton Transfer（[TEP-74]（https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer））的消息，我们应该在常规传输的 `body` 序列化评论，并将其包装在 `forwardPayload` 中：

```js
    import {beginCell, toNano, Address} from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const destinationAddress = Address.parse('put destination wallet address');

    const forwardPayload = beginCell()
        .storeUint(0, 32) // 0 opcode means we have a comment
        .storeStringTail('Hello, TON!')
        .endCell();

    const body = beginCell()
        .storeUint(0x0f8a7ea5, 32) // opcode for jetton transfer
        .storeUint(0, 64) // query id
        .storeCoins(toNano(5)) // jetton amount, amount * 10^9
        .storeAddress(destinationAddress) // TON wallet destination address
        .storeAddress(destinationAddress) // response excess destination
        .storeBit(0) // no custom payload
        .storeCoins(toNano('0.02')) // forward amount (if >0, will send notification message)
        .storeBit(1) // we store forwardPayload as a reference
        .storeRef(forwardPayload)
        .endCell();

```

接下来，将与该机构的交易发送给发送者的jettonWalletContract执行：

<Tabs groupId="Jetton Transfer">
  <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
    import { useTonConnectUI } from '@tonconnect/ui-react';


    const jettonWalletContract = Address.parse('put your jetton wallet address');

    const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
  {
    address: jettonWalletContract, // sender jetton wallet
    amount: toNano("0.05"), // for commission fees, excess will be returned
    payload: body.toBoc().toString("base64") // payload with jetton transfer and comment body
  }
    ]
  }

    export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
    <div>
    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
    Send transaction
  </button>
</div>
);
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
  import TonConnectUI from '@tonconnect/ui'

  const transaction = {
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
{
  address: jettonWalletContract,  // sender jetton wallet
  amount: toNano("0.05"),         // for commission fees, excess will be returned
  payload: body.toBoc().toString("base64") // payload with jetton transfer and comment body
}
  ]
}

  const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
  import TonConnect from '@tonconnect/sdk';
  const connector = new TonConnect();
  //...
  await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
{
  address: jettonWalletContract,            // sender jetton wallet
  amount: toNano("0.05"),                   // for commission fees, excess will be returned
  payload: body.toBoc().toString("base64")  // payload with jetton transfer and comment body
}
  ]
})
```

</TabItem>
</Tabs>

- \`validUntil - UNIXtime 直到消息有效
- `jettonWalletAddress` - 地址，JettonWallet 地址，它是基于 JettonMaser 和 Wallet 合同定义的
- `balanc` - Integer, toncoin for gas paiement in nanton.
- `body` - jetton合同的payload

<details>
  <summary>Jetton Wallet State Init and Address preparing example</summary>

```js
  Import Windows Address, TonClient, beginCell, StateInit, '@ton/ton'

  async 函数main() 中的 storeStateInit }。请注意，
  const client = new TonClient(哇，
  endpoint: 'https://toncenter. om/api/v2/jsonRPC'，
  apiKey：“放您的 api 密钥”
})

  const jettonWalletAddress = 地址。 arse('Sender_Jetton_Wallet');
  let jettonWalletDataResult = required client.runMethod(jettonWalletAddress, 'get_wallet_data');
  jettonWalletDataResult.stack.readNumber();
  const owners address = jettonWalletDataResult.stack. stack. eadAddress();
  const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
  const jettonCode = jettonWalletDataResult.stack. eadCell();
  const jettonData = beginCell()
  .storeCoins(0)
  .storAddress(地址)
  .storAddress(jettonMasterAddress)
  . toreRef(jettonCode)
  ndCell();

  const stateInit: StateInt = {
  code: jettonCode,
  data: jettonData
}

  const stateInitcell = beginCell()
  tore(storeStateInit(stateInit))
  .endCell();

  console.log(new Address(0, stateInitCell.hash());
}
```

</details>

### Jeton Burn

Jetton Burn([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#2-burn)) 的`body` 通常应该按照以下方式进行：

```js
    import {beginCell} from '@ton/ton'
// burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
//               response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//               = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x595f07bc, 32)                // jetton burn op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(1000000)                      // amount:(VarUInteger 16) -  Jetton amount in decimal
        .storeAddress(Wallet_SRC)                 // response_destination:MsgAddress - owner's wallet
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell) - w/o payload typically
        .endCell();
```

消息放置在以下请求中：

<Tabs groupId="Jetton Burn">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract, // owner's jetton wallet
            amount: toNano("0.05"),  // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a jetton burn body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
从 '@tonconnect/ui'

const transaction = 许诺.
    validUntil: Math.floor(Date). ow() / 1000) + 360,
    电文：[
        Power
            地址：jettonWallet Contract, // 所有者的杰顿钱包
            金额: toNano("0"). 5", // 收取佣金， 超量将返回
            有效载荷：体. oBoc(). oString("base64") // payload with a jeton burn body
        }
    ]
}

const results = 等待tonConnectUI 端交易(交易)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract, // owner's jetton wallet
      amount: toNano("0.05"), // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64") // payload with a jetton burn body
    }
  ]
})
```

</TabItem>
</Tabs>

- `jettonWalletAddress` - Jetton Wallet 合同地址，该地址是基于 JettonMaser 和 Wallet 合同定义的
- `amount` - Integer, Toncoin for gas paiement in nanoton.
- `body` - 用 `burn#595f07bc` 代码为杰顿钱包的payload

### NFT 传输

`body`消息通常应按照以下方式完成：

```js
import { beginCell, toNano} from '@ton/ton'

//  transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//   forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x5fcc3d14, 32)               // NFT transfer op code 0x5fcc3d14
        .storeUint(0, 64)                        // query_id:uint64
        .storeAddress(NEW_OWNER_WALLET)          // new_owner:MsgAddress
        .storeAddress(Wallet_DST)                // response_destination:MsgAddress
        .storeUint(0, 1)                         // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano('0.000000001'))       // forward_amount:(VarUInteger 16)
        .storeUint(0,1)                          // forward_payload:(Either Cell ^Cell)
        .endCell();
```

`WALLET_DST` - 地址 - 接收超量
接收的 NFTitem` 第一个NFT 所有者的地址。将`NFTitem` 传给新的所有者`NEW_OWNER_WALLET\` 。

<Tabs groupId="NFT Transfer">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract, // NFT Item address, which will be transferred
            amount: toNano("0.05"),  // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a NFT transfer body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: NFTitem,  // NFT Item address, which will be transferred
            amount: toNano("0.05"),  // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a NFT transfer body
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: NFTitem, // NFT Item address, which will be transferred
      amount: toNano("0.05"),  // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64") // payload with a NFT transfer body
    }
  ]
})
```

</TabItem>
</Tabs>

- `NFTitem` - 地址 - 我们想要传输给新所有者的 NFT 智能合同的地址 `NEW_OWNER_WALLET`.
- `balanc` - Integer, toncoin for gas paiement in nanton.
- `body` - NFT合同的payload

### NFT 销售 (GetGems)

根据合同 [nft-fixprice-sale-v3r2](https://github.com/getgems-io/nft-contracts/blob/main/packes/contracts/sources/nft-fixe-sale-v3r2.fc)，这是准备在GetGems市场上销售消息和交易的一个例子。

为了在 GetGems 销售合同中放置NFT ，我们应该准备特殊消息机构 `transferNftBody` ，它将传输NFT 到特殊的 NFT 销售合同。

```js
    const transferNftBody = beginCell()
        .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
        .storeUint(0, 64) // query_id
        .storeAddress(destinationAddress) // new_owner - GetGems sale contracts deployer, should never change for this operation
        .storeAddress(walletAddress) // response_destination for excesses
        .storeBit(0) // we do not have custom_payload
        .storeCoins(toNano("1")) // forward_amount
        .storeBit(0) // we store forward_payload is this cell
        .storeUint(0x0fe0ede, 31) // not 32, because previous 0 will be read as do_sale opcode in deployer
        .storeRef(stateInitCell)
        .storeRef(saleBody)
        .endCell();
```

因为消息需要很多步骤，所以整个算法是巨大的，可以在这里找到：

<details>
    <summary>Show entire algorithm for the creating NFT Sale message body</summary>

```js
import { Address, beginCell, StateInit, storeStateInit, toNano, Cell } from '@ton/ton'

async function main() {
    const fixPriceV3R2Code = Cell.fromBase64('te6cckECCwEAArkAART/APSkE/S88sgLAQIBIAIDAgFIBAUAfvIw7UTQ0wDTH/pA+kD6QPoA1NMAMMABjh34AHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOBfB4IA//7y8AICzQYHAFegOFnaiaGmAaY/9IH0gfSB9AGppgBgYaH0gfQB9IH0AGEEIIySsKAVgAKrAQH30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEqYhOmPhW8Q4YBKGATpn8cIxbMbC3MbK2QV44LJOZlvKAVxFWAAyS+G8BJrpOEBFcCBFd0VYACRWdjYKdxjgthOjq+G6hhoaYPqGAD9gHAU4ADAgB92YIQO5rKAFJgoFIwvvLhwiTQ+kD6APpA+gAwU5KhIaFQh6EWoFKQcIAQyMsFUAPPFgH6AstqyXH7ACXCACXXScICsI4XUEVwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWnCAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FIKAejy0ZSzjkIxMzk5U1LHBZJfCeBRUccF8uH0ghAFE42RFrry4fUD+kAwRlAQNFlwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgMDcowAPjAijAAJw2NxA4R2UUQzBw8AXgCMACmFVEECQQI/AF4F8KhA/y8AkA1Dg5ghA7msoAGL7y4clTRscFUVLHBRWx8uHKcCCCEF/MPRQhgBDIywUozxYh+gLLassfFcs/J88WJ88WFMoAI/oCE8oAyYMG+wBxUGZFFQRwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VQAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVNZeZYk=');

    const marketplaceAddress = Address.parse('EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS'); // GetGems Address
    const marketplaceFeeAddress = Address.parse('EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS'); // GetGems Address for Fees
    const destinationAddress = Address.parse("EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR"); // GetGems sale contracts deployer

    const walletAddress = Address.parse('EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162');
    const royaltyAddress = Address.parse('EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162');
    const nftAddress = Address.parse('EQCUWoe7hLlklVxH8gduCf45vPNocsjRP4wbX42UJ0Ja0S2f');
    const price = toNano('5'); // 5 TON

    const feesData = beginCell()
        .storeAddress(marketplaceFeeAddress)
        // 5% - GetGems fee
        .storeCoins(price / BigInt(100) * BigInt(5))
        .storeAddress(royaltyAddress)
        // 5% - Royalty, can be changed
        .storeCoins(price / BigInt(100) * BigInt(5))
        .endCell();

    const saleData = beginCell()
        .storeBit(0) // is_complete
        .storeUint(Math.round(Date.now() / 1000), 32) // created_at
        .storeAddress(marketplaceAddress) // marketplace_address
        .storeAddress(nftAddress) // nft_address
        .storeAddress(walletAddress) // previous_owner_address
        .storeCoins(price) // full price in nanotons
        .storeRef(feesData) // fees_cell
        .storeBit(0) // can_be_deployed_externally
        .endCell();

    const stateInit: StateInit = {
        code: fixPriceV3R2Code,
        data: saleData
    };
    const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

    // not needed, just for example
    const saleContractAddress = new Address(0, stateInitCell.hash());

    const saleBody = beginCell()
        .storeUint(1, 32) // just accept coins on deploy
        .storeUint(0, 64)
        .endCell();

    const transferNftBody = beginCell()
        .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
        .storeUint(0, 64) // query_id
        .storeAddress(destinationAddress) // new_owner
        .storeAddress(walletAddress) // response_destination for excesses
        .storeBit(0) // we do not have custom_payload
        .storeCoins(toNano("1")) // forward_amount
        .storeBit(0) // we store forward_payload is this cell
        // not 32, because we stored 0 bit before | do_sale opcode for deployer
        .storeUint(0x0fe0ede, 31)
        .storeRef(stateInitCell)
        .storeRef(saleBody)
        .endCell();
```

</details>

准备`transferNftBody`应该发送到至少`1.08`TON'的NFT项目合同，预计它将成功处理。 过剩将返回发件人的钱包。

<Tabs groupId="NFT Sale Fix Price">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: NFTitem, //address of the NFT Item contract, that should be placed on market
            amount: toNano("1.08"), // amount that will require on gas fees, excess will be return
            payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
从 '@tonconnect/ui'

const transaction = 许诺.
    validUntil: Math.floor(Date). ow() / 1000) + 360,
    消息：[
        Power
            地址：NFTitem, / NFT 项目合约的地址， 应放置在市场上的
            金额：toNano("1)。 8", // 气费所需的数量. 超量将返回
            有效载荷：transferNftBody。 oBoc(). oString("base64") // payload with the transferNftBody message
        }
    ]
}

const results = 等待tonConnectUI. 端交易(交易)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: NFTitem, //address of NFT Item contract, that should be placed on market
      amount: toNano("1.08"), // amount that will require on gas fees, excess will be return
      payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
    }
  ]
})
```

</TabItem>
</Tabs>

### NFT 购买 (GetGems)

为 [nft-fixprice-sale-v3r2]购买NFT 的过程(https://github.com/getgems-io/nft-contracts/blob/main/packses/contracts/sources/nft-fixed price-sale-v3r2)。 (c) 销售合同可以在没有有效载荷的情况下定期转让， 唯一重要的事情是准确的 TON 金额，它计算如下：
\`buyAmount = Nftprice TON + 1。 TON。

<Tabs groupId="NFT Buy">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
            amount: toNano(buyAmount), // NFT Price + exactly 1 TON, excess will be returned
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
            amount: toNano(buyAmount), // NFT Price + exactly 1 TON, excess will be returned
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>
<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
validUntil: Math.floor(Date.now() / 1000) + 360,
messages: [
    {
        address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
        amount: toNano(buyAmount), // NFT Price + exactly 1 TON, excess will be returned
    }
]
})
```

</TabItem>
</Tabs>

## TON 连接 Python SDK

Python 示例正在使用 [PyTonConnect](https://github.com/XaBbl4/pytonconnect) 和 [pytoniq](https://github.com/yungwine/pytoniq)。

```python
    从 pytoniq_core 导入地址
    从 pytonconnect 导入 TonConnect
```

:::tip
阅读示例 [source](https://github.com/yungwine/ton-connect-examples es/blob/master/main.py).
:::

### 正则TON 传输

```python
connector = TonConnect(
    manifest_url='https://raw.githubusercontent.com/XaBbl4/pytonconnect/main/pytonconnect-manifest.json')
is_connected = await connector.restore_connection()

transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
            'address' :'0:0000000000000000000000000000000000000000000000000000000000000000', # destination address
            'amount' : 1000000000,  # amount should be specified in nanocoins, 1 TON
        )
    ]
}
```

### 带评论的传输

首先，通过以下函数执行带有评论的消息：

```python
    def get_comment_message(destination_address: str, amount: int, 评论：str) -> dict:

        data = Power
            'address': destination_address'
            '金额': str(金额),
            'payload': urlsafe_b64encode(
                begin_cell()
                tore_uint(0) 32) # 评论消息
                的操作码。 tore_string(评论) # 存储评论
                nd_cell() # 结尾单元格
                。 o_boc() # 将其转换为boc
            )
            ecode() # 编码它为 urlsafe base64
        }

        返回数据
```

传输的最终交易机构，附有评论：

```python
交易 = Power
    'valid_until': int(time). ime() + 3600，
    'messages': [
        get_comment_message(
            destination_address='0:000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
            金额=int(0)。 1 * 10**9， # 金额应该在 nanocoins
            comment='hello world!

    []
}
```

:::tip
了解更多关于 [TON Smart Contractions](/learn/overviews/addresses)
:::

### Jetton Transfer

构建jetton传输交易功能示例：

```python
from pytoniq_core import begin_cell
from base64 import urlsafe_b64encode

def get_jetton_transfer_message(jetton_wallet_address: str, recipient_address: str, transfer_fee: int, jettons_amount: int, response_address: str = None) -> dict:
    data = {
        'address': jetton_wallet_address,
        'amount': str(transfer_fee),
        'payload': urlsafe_b64encode(
        begin_cell()
        .store_uint(0xf8a7ea5, 32)  # op code for jetton transfer message
        .store_uint(0, 64)  # query_id
        .store_coins(jettons_amount)
        .store_address(recipient_address)  # destination address
        .store_address(response_address or recipient_address)  # address send excess to
        .store_uint(0, 1)  # custom payload
        .store_coins(1)  # forward amount
        .store_uint(0, 1)  # forward payload
        .end_cell()  # end cell
        .to_boc()  # convert it to boc
        )
        .decode()  # encode it to urlsafe base64
    }

    return data
```

最后交易机构：

```python
交易 = Power
    'valid_until': int(time). ime() + 3600，
    'messages': [
        get_jetton_transfer_message(
        jetton_wallet_address='EQCXsVdxTVmSIvYv4tTQoQ-0Yq9mERGTKfbsIhedbN5vTVVV',
        收件人地址='0:00000000000000000000000000000000000000000000000000000000000000',
        transfer_fee=int(0)。 7 * 10**9)，
        jettons_amount=int(0.01 * 10**9)，# 以jeton decimal替换9。 例如，jUSDT 应该是 (amount * 10**6)
        response_address=wallet_address
        ),
    ]
}

```

### Jeton Burn

构建珠宝燃烧交易功能示例：

```python
from pytoniq_core import begin_cell
from base64 import urlsafe_b64encode

def get_jetton_burn_message(jetton_wallet_address: str, transfer_fee: int, jettons_amount: int, response_address: str = None) -> dict:
    data = {
        'address': jetton_wallet_address,
        'amount': str(transfer_fee),
        'payload': urlsafe_b64encode(
            begin_cell()
            .store_uint(0x595f07bc, 32)  # op code for jetton transfer message
            .store_uint(0, 64)  # query_id
            .store_coins(jettons_amount)
            .store_address(response_address)  # address send excess to
            .end_cell()  # end cell
            .to_boc()  # convert it to boc
        )
        .decode()  # encode it to urlsafe base64
    }
    return data
```

最后交易机构：

```python
交易 = Power
    'valid_until': int(time). ime() + 3600，
    'messages': [
        get_jetton_burn_message(
            jetton_wallet_address='EQCXsVdxTVmSIvYv4tTQoQ-0Yq9mERGTKfbsIhedbN5vTVVV',
            transfer_fee=int(0)。 7 * 10 ** 9,
            jettons_amount=int(0)。 1 * 10 ** 9, # 替换9个喷嘴小麦。 例如，jUSDT 应该是 (amount * 10**6)
            response_address=wallet_address
        ),
    ]
}
```

### NFT 传输

NFT 转移交易函数示例：

```python
从pytoniq_core importing bin_cell
from base64 import urlsafe_b64encode


def get_nft_transfer_message(nft_address：str, receivent_address：str, transfer_fe：int, 响应地址：str = None) -> dict:
    data = Power
        'address': nft_address'
        'amount': str(transfer_fee),
        'payload': urlsafe_b64encode(
            begin_cell()
            tore_uint(0x5fcc3d14, 32) # nft transfer message
            tore_uint(0, 64) # query_id
            tore_address(收件人地址) # 新所有者
            tore_address(响应地址或收件人地址) # 发送超过
            的地址。 tore_uint(0, 1) # 自定义payload
            。 tore_coins(1) # 前进金额
            tore_uint(0, 1) # 前进有效载荷
            。 nd_cell() # 结尾单元格
            o_boc() # 将其转换为 boc
        )
        。 ecode() # 编码它为 urlsafe base64
    }
    return data

```

最后交易机构：

```python
交易 = Power
    'valid_until': int(time). ime() + 3600，
    'messages': [
        get_nft_transfer_message(
            nft_address='EQDrA-3zsJXTfGo_Vdzg8d07Da4vSdHZllc6W9qvoNoMstF-',
            收件人地址='0:0000000000000000000000000000000000000000000000000000000000000000',
            transfer_fee=int(0)。 7 * 10**9，
            response_address=wallet_address

    ]
}
```

### NFT 销售 (GetGems)

根据合同 [nft-fixprice-sale-v3r2](https://github.com/getgems-io/nft-contracts/blob/main/packes/contracts/sources/nft-fixe-sale-v3r2.fc)，这是准备在GetGems市场上销售消息和交易的一个例子。

为了在 GetGems 销售合同中放置NFT ，我们应该准备特殊消息机构 `transferNftBody` ，它将传输NFT 到特殊的 NFT 销售合同。

<details>
<summary>Example of creating NFT Sale Body</summary>

```python
    import time
from base64 import urlsafe_b64encode

from pytoniq_core.boc import Cell, begin_cell, Address
from pytoniq_core.tlb import StateInit


def get_sale_body(wallet_address: str, royalty_address: str, nft_address: str, price: int, amount: int):

    # contract code
    nft_sale_code_cell = Cell.one_from_boc('te6cckECCwEAArkAART/APSkE/S88sgLAQIBIAIDAgFIBAUAfvIw7UTQ0wDTH/pA+kD6QPoA1NMAMMABjh34AHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOBfB4IA//7y8AICzQYHAFegOFnaiaGmAaY/9IH0gfSB9AGppgBgYaH0gfQB9IH0AGEEIIySsKAVgAKrAQH30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEqYhOmPhW8Q4YBKGATpn8cIxbMbC3MbK2QV44LJOZlvKAVxFWAAyS+G8BJrpOEBFcCBFd0VYACRWdjYKdxjgthOjq+G6hhoaYPqGAD9gHAU4ADAgB92YIQO5rKAFJgoFIwvvLhwiTQ+kD6APpA+gAwU5KhIaFQh6EWoFKQcIAQyMsFUAPPFgH6AstqyXH7ACXCACXXScICsI4XUEVwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWnCAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FIKAejy0ZSzjkIxMzk5U1LHBZJfCeBRUccF8uH0ghAFE42RFrry4fUD+kAwRlAQNFlwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgMDcowAPjAijAAJw2NxA4R2UUQzBw8AXgCMACmFVEECQQI/AF4F8KhA/y8AkA1Dg5ghA7msoAGL7y4clTRscFUVLHBRWx8uHKcCCCEF/MPRQhgBDIywUozxYh+gLLassfFcs/J88WJ88WFMoAI/oCE8oAyYMG+wBxUGZFFQRwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VQAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVNZeZYk=')

    # fees cell

    marketplace_address = Address('EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS')
    marketplace_fee_address = Address('EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS')
    destination_address = Address('EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR')

    wallet_address = Address(wallet_address)
    royalty_address = Address(royalty_address)
    nft_address = Address(nft_address)

    marketplace_fee = int(price * 5 / 100)  # 5%
    royalty_fee = int(price * 5 / 100)  # 5%

    fees_data_cell = (begin_cell()
                      .store_address(marketplace_fee_address)
                      .store_coins(marketplace_fee)
                      .store_address(royalty_address)
                      .store_coins(royalty_fee)
                      .end_cell())


    sale_data_cell = (begin_cell()
                      .store_bit_int(0)
                      .store_uint(int(time.time()), 32)
                      .store_address(marketplace_address)
                      .store_address(nft_address)
                      .store_address(wallet_address)
                      .store_coins(price)
                      .store_ref(fees_data_cell)
                      .store_bit_int(0)
                      .end_cell())

    state_init_cell = StateInit(code=nft_sale_code_cell, data=sale_data_cell).serialize()

    sale_body = (begin_cell()
                 .store_uint(1, 32)
                 .store_uint(0, 64)
                 .end_cell())

    transfer_nft_body = (begin_cell()
                         .store_uint(0x5fcc3d14, 32)
                         .store_uint(0, 64)
                         .store_address(destination_address)
                         .store_address(wallet_address)
                         .store_bit_int(0)
                         .store_coins(int(1 * 10**9))
                         .store_bit_int(0)
                         .store_uint(0x0fe0ede, 31)
                         .store_ref(state_init_cell)
                         .store_ref(sale_body)
                         .end_cell())

    data = {
        'address': nft_address.to_str(),
        'amount': str(amount),
        'payload': urlsafe_b64encode(transfer_nft_body.to_boc()).decode()
    }

    return data
```

</details>

最后交易机构：

```python
交易 = Power
    'valid_until': int(time). ime() + 3600，
    'messages': [
        get_nft_transfer_message(
            nft_address='EQDrA-3zsJXTfGo_Vdzg8d07Da4vSdHZllc6W9qvoNoMstF-',
            收件人地址='0:0000000000000000000000000000000000000000000000000000000000000000',
            transfer_fee=int(0)。 7 * 10**9，
            response_address=wallet_address

    ]
}
```

### NFT 购买 (GetGems)

为 [nft-fixprice-sale-v3r2]购买NFT 的过程(https://github.com/getgems-io/nft-contracts/blob/main/packses/contracts/sources/nft-fixed price-sale-v3r2)。 (c) 销售合同可以在没有有效载荷的情况下定期转让， 唯一重要的事情是准确的 TON 金额，它计算如下：
\`buyAmount = Nftprice TON + 1。 TON。

```python
交易 = Power
    'valid_until': int(time.time() + 3600),
    'messages': [
        own
            'address': nft_address,
            'amount': buyamount',
    ]
}
```

## 作者

- JavaScript 示例由 [@aSpite](https://t.me/aspite) 提供
- 由[@yunwine]提供的 Python 示例(https://t.me/yungwine)

## 另见：

- [TON Connect SDK](/develop/dapps/ton-connect/developers)
- [TON Connect - 发送消息](/develop/dapps/ton-connect/transactions)
- [智能合同开发-发送消息(低级)](/develop/smart-contracts/messages)
