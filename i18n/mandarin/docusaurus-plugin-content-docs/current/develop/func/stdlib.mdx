---
toc_min_heading_level: 2
toc_max_heading_level: 6
---

# FunC 标准库

:::info
本节讨论了 [stdlib.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc) 库，它包含了在 FunC 中使用的标准函数。
:::

目前，该库只是最常用的 TVM 命令的汇编器的包装，这些命令不是内置的。库中使用的每个 TVM 命令的描述都可以在 [TVM 文档](/learn/tvm-instructions/tvm-overview)部分找到。本文档也借用了一些描述。

文件中的一些函数被注释掉了。这意味着它们已经成为了优化目的的内置函数。然而，类型签名和语义保持不变。

请注意，stdlib 中没有呈现一些不太常见的命令。总有一天它们也会被添加。

## 元组操作原语

名称和类型大多是自解释的。有关多态函数的更多信息，请参见 [多态性与 forall](/develop/func/functions#polymorphism-with-forall)。

请注意，目前原子类型 `tuple` 的值不能转换为复合元组类型（例如 `[int, cell]`），反之亦然。

### Lisp 类型列表

列表可以表示为嵌套的 2 元组。空列表通常表示为 TVM `null` 值（可以通过调用 `null()` 获得）。例如，元组 `(1, (2, (3, null)))` 表示列表 `[1, 2, 3]`。列表的元素可以是不同类型。

#### cons

```func
forall X -> tuple cons(X head, tuple tail) asm "CONS";
```

在 Lisp 类型列表的开头添加一个元素。

#### uncons

```func
forall X -> (X, tuple) uncons(tuple list) asm "UNCONS";
```

提取 Lisp 类型列表的头和尾。

#### list_next

```func
forall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) "UNCONS";
```

提取 Lisp 类型列表的头和尾。可用作 [(非)修改方法](/develop/func/statements#methods-calls)。

```func
() foo(tuple xs) {
    (_, int x) = xs.list_next(); ;; get the first element, `_` means do not use tail list
    int y = xs~list_next(); ;; pop the first element
    int z = xs~list_next(); ;; pop the second element
}
```

#### car

```func
forall X -> X car(tuple list) asm "CAR";
```

返回 Lisp 类型列表的头部。

#### cdr

```func
tuple cdr(tuple list) asm "CDR";
```

返回 Lisp 类型列表的尾部。

### 其他元组原语

#### empty_tuple

```func
tuple empty_tuple() asm "NIL";
```

创建 0 元素元组。

#### tpush

```func
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
```

将值 `x` 追加到 `Tuple t = (x1, ..., xn)`，但只有在结果 `Tuple t' = (x1, ..., xn, x)` 不超过 255 个字符时才有效。否则，会抛出类型检查异常。

#### single

```func
forall X -> [X] single(X x) asm "SINGLE";
```

创建单例，即长度为一的元组。

#### unsingle

```func
forall X -> X unsingle([X] t) asm "UNSINGLE";
```

解包单例。

#### pair

```func
forall X, Y -> [X, Y] pair(X x, Y y) asm "PAIR";
```

创建一对。

#### unpair

```func
forall X, Y -> (X, Y) unpair([X, Y] t) asm "UNPAIR";
```

解包一对。

#### triple

```func
forall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm "TRIPLE";
```

创建三元组。

#### untriple

```func
forall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm "UNTRIPLE";
```

解包三元组。

#### tuple4

```func
forall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm "4 TUPLE";
```

创建四元组。

#### untuple4

```func
forall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm "4 UNTUPLE";
```

解包四元组。

#### first

```func
forall X -> X first(tuple t) asm "FIRST";
```

返回元组的第一个元素。

#### second

```func
forall X -> X second(tuple t) asm "SECOND";
```

返回元组的第二个元素。

#### third

```func
forall X -> X third(tuple t) asm "THIRD";
```

返回元组的第三个元素。

#### fourth

```func
forall X -> X fourth(tuple t) asm "3 INDEX";
```

返回元组的第四个元素。

#### pair_first

```func
forall X, Y -> X pair_first([X, Y] p) asm "FIRST";
```

返回一对的第一个元素。

#### pair_second

```func
forall X, Y -> Y pair_second([X, Y] p) asm "SECOND";
```

返回一对的第二个元素。

#### triple_first

```func
forall X, Y, Z -> X triple_first([X, Y, Z] p) asm "FIRST";
```

返回三元组的第一个元素。

#### triple_second

```func
forall X, Y, Z -> Y triple_second([X, Y, Z] p) asm "SECOND";
```

返回三元组的第二个元素。

#### triple_third

```func
forall X, Y, Z -> Z triple_third([X, Y, Z] p) asm "THIRD";
```

返回三元组的第三个元素。

## 特定领域原语

### 从 c7 提取信息

关于智能合约调用的一些有用信息可以在 [c7 特殊寄存器](/learn/tvm-instructions/tvm-overview#control-registers)中找到。这些原语用于方便地提取数据。

#### now

```func
int now() asm "NOW";
```

返回当前 Unix 时间作为整数。

#### my_address

```func
slice my_address() asm "MYADDR";
```

以 Slice 形式返回当前智能合约的内部地址，其中包含 `MsgAddressInt`。如果需要，可以进一步使用诸如 `parse_std_addr` 之类的原语进行解析。

#### get_balance

```func
[int, cell] get_balance() asm "BALANCE";
```

以 `tuple` 形式返回智能合约的剩余余额，其中包括 `int`（剩余余额，以nanoton计）和 `cell`（一个包含 32 位键的字典，代表“额外代币”的余额）。注意，RAW 原语（如 `send_raw_message`）不会更新此字段。

#### cur_lt

```func
int cur_lt() asm "LTIME";
```

返回当前交易的逻辑时间。

#### block_lt

```func
int block_lt() asm "BLOCKLT";
```

返回当前区块的起始逻辑时间。

#### config_param

```func
cell config_param(int x) asm "CONFIGOPTPARAM";
```

以 `cell` 或 `null` 值的形式返回全局配置参数的值，其中整数索引为 `i`。

### 哈希

#### cell_hash

```func
int cell_hash(cell c) asm "HASHCU";
```

计算`cell c`的 representation hash ，并将其作为一个256位无符号整数`x`返回。用于签名和检查由cell树表示的任意实体的签名。

#### slice_hash

```func
int slice_hash(slice s) asm "HASHSU";
```

计算`slice s`的哈希，并将其作为一个256位无符号整数`x`返回。结果与创建一个只包含`s`的数据和引用的普通cell，并通过`cell_hash`计算其哈希的情况相同。

#### string_hash

```func
int string_hash(slice s) asm "SHA256U";
```

计算`slice s`数据位的sha256。如果`s`的位长度不能被八整除，则抛出一个cell下溢异常。哈希值作为一个256位无符号整数`x`返回。

### 签名检查

#### check_signature

```func
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";
```

使用`public_key`（也表示为一个256位无符号整数）检查`hash`（通常作为某些数据的哈希计算得出的256位无符号整数）的Ed25519 `signature`。签名必须包含至少512个数据位；只使用前512位。如果签名有效，结果为`-1`；否则，为`0`。请注意，`CHKSIGNU`创建一个包含哈希的256位切片，并调用`CHKSIGNS`。也就是说，如果`hash`是作为某些数据的哈希计算的，这些数据会被_两次_哈希，第二次哈希发生在`CHKSIGNS`内部。

#### check_data_signature

```func
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNS";
```

检查`signature`是否是使用`public_key`的`slice data`数据部分的有效Ed25519签名，类似于`check_signature`。如果`data`的位长度不能被八整除，则抛出一个cell下溢异常。Ed25519签名的验证是标准的，使用sha256将`data`简化为实际签名的256位数字。

### 计算boc大小

下面的原语可能对于计算用户提供数据的存储费用有用。

#### compute_data_size?

```func
(int, int, int, int) compute_data_size?(cell c, int max_cells) asm "CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

返回`(x, y, z, -1)`或`(null, null, null, 0)`。递归地计算以`cell c`为根的DAG中不同cell的数量`x`、数据位`y`和cell引用`z`，有效地返回此DAG使用的总存储量，同时考虑到相等cell的识别。`x`、`y`和`z`的值通过对此DAG进行深度优先遍历来计算，并使用访问过的cell哈希的哈希表来防止已访问cell的重复访问。访问的cell总数`x`不能超过非负的`max_cells`；否则，在访问第`(max_cells + 1)`个cell之前，计算将被中止，并返回零标志以指示失败。如果`c`为`null`，则返回`x = y = z = 0`。

#### slice_compute_data_size?

```func
(int, int, int, int) slice_compute_data_size?(slice s, int max_cells) asm "SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

类似于`compute_data_size?`，但接受的是`slice s`而不是`cell`。返回的`x`值不考
虑包含切片`s`本身的cell；然而，`s`的数据位和cell引用在`y`和`z`中要被考虑。

#### compute_data_size

```func
(int, int, int) compute_data_size(cell c, int max_cells) impure asm "CDATASIZE";
```

`compute_data_size?`的非静默版本，失败时抛出cell溢出异常（8）。

#### slice_compute_data_size

```func
(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm "SDATASIZE";
```

`slice_compute_data_size?`的非静默版本，失败时抛出cell溢出异常（8）。

### 持久存储保存和加载

#### get_data

```func
cell get_data() asm "c4 PUSH";
```

返回持久化合约存储cell。稍后可以使用切片和构建器原语对其进行解析或修改。

#### set_data

```func
() set_data(cell c) impure asm "c4 POP";
```

将cell`c`设置为持久化合约数据。您可以使用这个原语更新持久化合约存储。

### Continuation 原语

#### get_c3

```func
cont get_c3() impure asm "c3 PUSH";
```

通常`c3`有一个由合约的整个代码初始化的continuation。它用于函数调用。原语返回`c3`的当前值。

#### set_c3

```func
() set_c3(cont c) impure asm "c3 POP";
```

更新`c3`的当前值。通常，它用于实时更新智能合约代码。请注意，在执行此原语之后，当前代码（以及递归函数调用堆栈）不会改变，但任何其他函数调用将使用新代码中的函数。

#### bless

```func
cont bless(slice s) impure asm "BLESS";
```

将`slice s`转换为一个简单的普通 continuation `c`，其中`c.code = s`，堆栈和保存列表为空。

### 与 gas 相关的原语

#### accept_message

```func
() accept_message() impure asm "ACCEPT";
```

将当前 gas 限制`gl`设置为其允许的最大值`gm`，并将 gas 信用`gc`重置为零，同时减少`gr`的值`gc`。换句话说，当前智能合约同意购买一些 gas 以完成当前交易。这个动作是处理不携带价值（因此不含 gas ）的外部消息所必需的。

有关更多详细信息，请查看[accept_message effects](/develop/smart-contracts/guidelines/accept)

#### set_gas_limit

```func
() set_gas_limit(int limit) impure asm "SETGASLIMIT";
```

将当前 gas 限制`gl`设置为`limit`和`gm`的最小值，并将 gas 信用`gc`重置为零。此时，如果消耗的 gas 量（包括当前指令）超过`gl`的结果值，则在设置新 gas 限制之前会抛出（未处理的） gas 不足异常。请注意，带有`limit ≥ 2^63 − 1`参数的`set_gas_limit`等同于`accept_message`。

有关更多详细信息，请查看[accept_message effects](/develop/smart-contracts/guidelines/accept)

#### commit

```func
() commit() impure asm "COMMIT";
```

提交寄存器`c4`（“持久数据”）和`c5`（“动作”）的当前状态，以便即使稍后抛出异常，当前执行也被视为“成功”，并保存这些值。

#### buy_gas

```func
() buy_gas(int gram) impure asm "BUYGAS";
```

:::caution
`BUYGAS`操作码目前尚未实现
:::

计算可以用`gram`nanoton币购买的gas 量，并以与`set_gas_limit`相同的方式相应地设置`gl`。

### 动作原语

#### raw_reserve

```func
() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
```

创建一个输出动作，该动作将准确地预留`amount` nanoton 币（如果`mode = 0`），最多`amount` nanoton 币（如果`mode = 2`），或除`amount` nanoton 币以外的所有 nanoton 币（如果`mode = 1`或`mode = 3`）从账户的剩余余额中。它大致等同于创建一个携带`amount` nanoton 币（或`b − amount` nanoton 币，其中`b`是剩余余额）的出站消息发送给自己，这样随后的输出动作就不会花费超过剩余部分的金额。`mode`中的+2位意味着外部动作在无法预留指定金额时不会失败；相反，将预留所有剩余余额。`mode`中的+8位意味着`amount <- -amount`在进行任何进一步的动作之前。`mode`中的+4位意味着在进行任何其他检查和动作之前，`amount`会增加当前账户的原始余额（在 Compute Phase 之前），包括所有额外代币。目前，`amount`必须是非负整数，`mode`必须在`0..15`范围内。

#### raw_reserve_extra

```func
() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm "RAWRESERVEX";
```

类似于`raw_reserve`，但还接受一个由`cell`或`null`表示的额外代币字典`extra_amount`。这样，除了Toncoin以外的其他代币也可以被预留。

#### send_raw_message

```func
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";
```

发送包含在`msg`中的原始消息，它应该包含一个正确序列化的消息对象X，唯一的例外是源地址可以有一个虚拟值`addr_none`（自动替换为当前智能合约地址），以及`ihr_fee`、`fwd_fee`、`created_lt`和`created_at`字段可以有任意值（在当前交易的 Action Phase 期间用正确的值重写）。整数参数`mode`包含标志。

目前有3种消息Modes和3种消息Flags。您可以将单一Mode与多个（也许没有）标志组合以获得所需的`mode`。组合只是意味着获取它们值的总和。下面给出了Modes和Flags的描述表格。

| Mode  | 描述                             |
| :---- | :----------------------------- |
| `0`   | 普通消息                           |
| `64`  | 除了最初在新消息中指示的值之外，还携带入站消息的所有剩余价值 |
| `128` | 携带当前智能合约的所有剩余余额，而不是最初在消息中指示的值  |

| Flag  | 描述                                               |
| :---- | :----------------------------------------------- |
| `+1`  | 单独支付消息价值之外的转移费用                                  |
| `+2`  | 忽略在 Action Phase 处理此消息时出现的任何错误                   |
| `+16` | 在动作失败的情况下 - 弹回交易。如果使用`+2`，则无效。                   |
| `+32` | 如果当前账户的最终余额为零，则必须销毁该账户（通常与模式128一起使用）             |

例如，如果您想发送常规消息并单独支付转账费用，请使用Mode`0`和Flag`+1`以获得`mode = 1`。如果

#### set_code

```func
() set_code(cell new_code) impure asm "SETCODE";
```

Creates an output action that would change this smart contract code to that given by cell `new_code`. Notice that this change will take effect only after the successful termination of the current run of the smart contract. (Cf. [set_c3](/develop/func/stdlib#set_c3.))

### Random number generator primitives

The pseudo-random number generator uses the random seed, an unsigned 256-bit Integer, and (sometimes) other data kept in [c7](/learn/tvm-instructions/tvm-overview#control-registers). The initial value of the random seed before a smart contract is executed in TON Blockchain is a hash of the smart contract address and the global block random seed. If there are several runs of the same smart contract inside a block, then all of these runs will have the same random seed. This can be fixed, for example, by running `randomize_lt` before using the pseudo-random number generator for the first time.

:::caution
Keep in mind that random numbers generated by the functions below can be predicted if you do not use additional tricks.

- [Random number generation](/develop/smart-contracts/guidelines/random-number-generation)
  :::

#### random

```func
int random() impure asm "RANDU256";
```

Generates a new pseudo-random unsigned 256-bit integer `x`. The algorithm is as follows: if `r` is the old value of the random seed considered a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its `sha512(r)` is computed; the first 32 bytes of this hash are stored as the new value `r'` of the random seed, and the remaining 32 bytes are returned as the next random value `x`.

#### rand

```func
int rand(int range) impure asm "RAND";
```

Generates a new pseudo-random integer `z` in the range `0..range−1` (or `range..−1` if `range < 0`). More precisely, an unsigned random value `x` is generated as in `random`; then `z := x * range / 2^256` is
computed.

#### get_seed

```func
int get_seed() impure asm "RANDSEED";
```

Returns the current random seed as an unsigned 256-bit integer.

#### set_seed

```func
int set_seed(int seed) impure asm "SETRAND";
```

Sets a random seed to an unsigned 256-bit `seed`.

#### randomize

```func
() randomize(int x) impure asm "ADDRAND";
```

Mixes an unsigned 256-bit integer `x` into a random seed `r` by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with a big-endian representation of the old seed `r`, and the second with a big-endian representation of `x`.

#### randomize_lt

```func
() randomize_lt() impure asm "LTIME" "ADDRAND";
```

Equivalent to `randomize(cur_lt());`.

### Address manipulation primitives

The address manipulation primitives listed below serialize and deserialize values according to the following TL-B scheme.

```func
addr_none$00 = MsgAddressExt;

addr_extern$01 len:(## 8) external_address:(bits len)
             = MsgAddressExt;

anycast_info$_ depth:(#<= 30) { depth >= 1 }
  rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)
  workchain_id:int8 address:bits256 = MsgAddressInt;

addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
  workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
```

A deserialized `MsgAddress` is represented by the tuple `t` as follows:

- `addr_none` is represented by `t = (0)`, i.e., a tuple containing exactly
  one integer that equals zero
- `addr_extern` is represented by `t = (1, s)`, where slice `s` contains the
  field `external_address`. In other words, `t` is a pair (a tuple consisting of two entries), containing an integer equal to one and slice `s`
- `addr_std` is represented by `t = (2, u, x, s)`, where `u` is either `null` (if `anycast` is absent) or a slice `s'` containing `rewrite_pfx` (if `anycast` is present). Next, integer `x` is the `workchain_id`, and slice `s` contains the address
- `addr_var` is represented by `t = (3, u, x, s)`, where `u`, `x`, and `s` have the same meaning as for `addr_std`

#### load_msg_addr

```func
(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";
```

Loads from `slice s` the only prefix that is a valid `MsgAddress` and returns both this prefix `s'` and the remainder `s''` of `s` as slices.

#### parse_addr

```func
tuple parse_addr(slice s) asm "PARSEMSGADDR";
```

Decomposes `slice s` containing a valid `MsgAddress` into `tuple t` with separate fields of this `MsgAddress`. If `s` is not a valid `MsgAddress`, a cell deserialization exception is thrown.

#### parse_std_addr

```func
(int, int) parse_std_addr(slice s) asm "REWRITESTDADDR";
```

Parses slice `s` containing a valid `MsgAddressInt` (usually `msg_addr_std`), applies rewriting from the `anycast` (if present) to the same-length prefix of the address, and returns both the workchain and the 256-bit address as integers. If the address is not 256-bit or if `s` is not a valid serialization of `MsgAddressInt`, throws a cell `deserialization` exception.

#### parse_var_addr

```func
(int, slice) parse_var_addr(slice s) asm "REWRITEVARADDR";
```

A variant of `parse_std_addr` that returns the (rewritten) address as a slice `s`, even if it is not exactly 256 bit long (represented by `msg_addr_var`).

## Debug primitives

Currently, only one function is available.

#### dump_stack

```func
() dump_stack() impure asm "DUMPSTK";
```

Dumps the stack (at most the top 255 values) and shows the total stack depth.

## Slice primitives

It is said that a primitive _loads_ some data if it returns the data and the remainder of the slice (so it can also be used as a [modifying method](/develop/func/statements#modifying-methods)).

据说，如果原语返回数据及其余部分的切片，则称其为_加载_数据（因此也可用作[修改方法](/develop/func/statements#modifying-methods)）。

据说，如果原语仅返回数据，则称其为_预加载_数据（可用作[非修改方法](/develop/func/statements#non-modifying-methods)）。

#### begin_parse

```func
slice begin_parse(cell c) asm "CTOS";
```

Converts `cell` into `slice`. Notice that `c` must be either an ordinary cell or an exotic cell (see [TVM.pdf](https://ton.org/tvm.pdf), 3.1.2) which is automatically loaded to yield an ordinary cell `c'`converted into `slice` afterwards.

#### end_parse

```func
() end_parse(slice s) impure asm "ENDS";
```

Checks if `s` is empty. If not, throws an exception.

#### load_ref

```func
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
```

Loads the first reference from a slice.

#### preload_ref

```func
cell preload_ref(slice s) asm "PLDREF";
```

Preloads the first reference from a slice.

#### load_int

```func
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
```

Loads a signed `len`-bit integer from a slice.

#### load_uint

```func
;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";
```

Loads an unsigned `len`-bit integer from a slice.

#### preload_int

```func
;; int preload_int(slice s, int len) asm "PLDIX";
```

Preloads a signed `len`-bit integer from a slice.

#### preload_uint

```func
;; int preload_uint(slice s, int len) asm "PLDUX";
```

Preloads an unsigned `len`-bit integer from a slice.

#### load_bits

```func
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";
```

Loads the first `0 ≤ len ≤ 1023` bits from slice `s` into a separate slice `s''`.

#### preload_bits

```func
;; slice preload_bits(slice s, int len) asm "PLDSLICEX";
```

Preloads the first `0 ≤ len ≤ 1023` bits from slice `s` into a separate slice `s''`.

#### load_coins

```func
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";
```

Loads serialized amount of Toncoins (any unsigned integer up to `2^120 - 1`).

#### skip_bits

```func
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
```

Returns all but the first `0 ≤ len ≤ 1023` bits of `s`.

#### first_bits

```func
slice first_bits(slice s, int len) asm "SDCUTFIRST";
```

Returns the first `0 ≤ len ≤ 1023` bits of `s`.

#### skip_last_bits

```func
slice skip_last_bits(slice s, int len) asm "SDSKIPLAST";
(slice, ()) ~skip_last_bits(slice s, int len) asm "SDSKIPLAST";
```

Returns all but the last `0 ≤ len ≤ 1023` bits of `s`.

#### slice_last

```func
slice slice_last(slice s, int len) asm "SDCUTLAST";
```

Returns the last `0 ≤ len ≤ 1023` bits of `s`.

#### load_dict

```func
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";
```

Loads a dictionary `D` from slice `s`. May be applied to dictionaries or to values of arbitrary `Maybe ^Y` types (returns `null` if `nothing` constructor is used).

#### preload_dict

```func
cell preload_dict(slice s) asm "PLDDICT";
```

Preloads a dictionary `D` from slice `s`.

#### skip_dict

```func
slice skip_dict(slice s) asm "SKIPDICT";
```

Loads a dictionary as `load_dict` but returns only the remainder of the slice.

### Slice size primitives

#### 切片大小原语

```func
int slice_refs(slice s) asm "SREFS";
```

Returns the number of references in slice `s`.

#### slice_bits

```func
int slice_bits(slice s) asm "SBITS";
```

Returns the number of data bits in slice `s`.

#### slice_bits_refs

```func
(int, int) slice_bits_refs(slice s) asm "SBITREFS";
```

Returns both the number of data bits and the number of references in `s`.

#### slice_empty?

```func
int slice_empty?(slice s) asm "SEMPTY";
```

Checks whether slice `s` is empty (i.e., contains no bits of data and no cell references).

#### slice_data_empty?

```func
int slice_data_empty?(slice s) asm "SDEMPTY";
```

Checks whether slice `s` has no bits of data.

#### slice_refs_empty?

```func
int slice_refs_empty?(slice s) asm "SREMPTY";
```

Checks whether slice `s` has no references.

#### slice_depth

```func
int slice_depth(slice s) asm "SDEPTH";
```

Returns the depth of slice `s`. If `s` has no references, then returns `0`; otherwise, the returned value is one plus the maximum of depths of cells referred to from `s`.

## Builder primitives

It is said that a primitive _stores_ a value `x` into a builder `b` if it returns a modified version of the builder `b'` with the value `x` stored at the end of it. It can be used as a [non-modifying method](/develop/func/statements#non-modifying-methods).

据说，如果原语将值 `x` 存储到构建器 `b` 中，则返回构建器 `b'` 的修改版本，并在其末尾存储值 `x`。这可以用作[非修改方法](/develop/func/statements#non-modifying-methods)。

#### begin_cell

```func
builder begin_cell() asm "NEWC";
```

Creates a new empty `builder`.

#### end_cell

```func
cell end_cell(builder b) asm "ENDC";
```

Converts `builder` into an ordinary `cell`.

#### store_ref

```func
builder store_ref(builder b, cell c) asm(c b) "STREF";
```

Stores a reference to cell `c` into builder `b`.

#### store_uint

```func
builder store_uint(builder b, int x, int len) asm(x b len) "STUX";
```

Stores an unsigned `len`-bit integer `x` into `b` for `0 ≤ len ≤ 256`.

#### store_int

```func
builder store_int(builder b, int x, int len) asm(x b len) "STIX";
```

Stores a signed `len`-bit integer `x` into `b` for `0 ≤ len ≤ 257`.

#### store_slice

```func
builder store_slice(builder b, slice s) asm "STSLICER";
```

Stores slice `s` into builder `b`.

#### store_grams

```func
builder store_grams(builder b, int x) asm "STGRAMS";
```

#### store_coins

```func
builder store_coins(builder b, int x) asm "STGRAMS";
```

Stores (serializes) an integer `x` in the range `0..2^120 − 1` into builder `b`. The serialization of `x` consists of a 4-bit unsigned big-endian integer `l`, which is the smallest integer `l ≥ 0`, such that `x < 2^8l`, followed by an `8l`-bit unsigned big-endian representation of `x`. If `x` does not belong to the supported range, a range check exception is thrown.

将范围 `0..2^120 − 1` 内的整数 `x` 存储（序列化）到构建器 `b` 中。`x` 的序列化包含一个4位无符号大端整数 `l`，它是最小的整数 `l ≥ 0`，使得 `x < 2^8l`，后跟 `8l` 位无符号大端表示的 `x`。如果 `x` 不属于支持范围，则抛出范围检查异常。

#### store_dict

```func
builder store_dict(builder b, cell c) asm(c b) "STDICT";
```

Stores dictionary `D` represented by cell `c` or `null` into builder `b`. In other words, stores `1`-bit and a reference to `c` if `c` is not `null` and `0`-bit otherwise.

#### store_maybe_ref

```func
builder store_maybe_ref(builder b, cell c) asm(c b) "STOPTREF";
```

Equivalent to `store_dict`.

### Builder size primitives

#### 构建器大小原语

```func
int builder_refs(builder b) asm "BREFS";
```

Returns the number of cell references already stored in builder `b`.

#### builder_bits

```func
int builder_bits(builder b) asm "BBITS";
```

Returns the number of data bits already stored in builder `b`.

#### builder_depth

```func
int builder_depth(builder b) asm "BDEPTH";
```

Returns the depth of builder `b`. If no cell references are stored in `b`, then returns `0`; otherwise, the returned value is one plus the maximum of depths of cells referred to from `b`.

## Cell primitives

#### Cell原语

```func
int cell_depth(cell c) asm "CDEPTH";
```

Returns the depth of cell `c`. If `c` has no references, then return `0`; otherwise, the returned value is one plus the maximum of depths of cells referred to from `c`. If `c` is a `null` instead of a cell, it returns zero.

#### cell_null?

```func
int cell_null?(cell c) asm "ISNULL";
```

Checks whether `c` is a `null`. Usually a `null`-cell represents an empty dictionary. FunC also has polymorphic `null?` built-in. (See [built-ins](/develop/func/builtins#other-primitives).)

## Dictionaries primitives

:::caution
The dictionary primitives below are low-level and do not check that the structure of the cell, they are applied to, matches the operation signature. Applying a dictionary operation to a "non-dictionary" or applying an operation corresponding to one key length/sign to a dictionary with a different kind of keys, for instance simultaneous writing to one dictionary key-values with 8bit-signed key and 7bit-unsigned key, is **Undefined Behavior**. Often in such cases an exception is thrown, but in rare cases the wrong value can be written / read. Developers are strongly encouraged to avoid such code.
:::

As said in [TVM.pdf](https://ton.org/tvm.pdf):

> Dictionaries admit two different representations as TVM stack values:
>
> - A slice `s` with a serialization of a TL-B value of type `HashmapE(n, X)`. In other words, `s` consists either of one bit equal to zero (if the dictionary is empty) or of one bit equal to one and a reference to a cell containing the root of the binary tree, i.e., a serialized value of type `Hashmap(n, X)`.
> - A “Maybe cell” `c^?`, i.e., a value that is either a cell (containing a serialized value of type `Hashmap(n, X)` as before) or a `null` (corresponding to an empty dictionary, cf. [null values](/develop/func/types#null-values)). When a “Maybe cell” `c^?` is used to represent a dictionary, we usually denote it by `D`.
>
> Most of the dictionary primitives listed below accept and return dictionaries in the second form, which is more convenient for stack manipulation. However, serialized dictionaries inside larger TL-B objects use the first representation.

In FunC dictionaries are also represented by the `cell` type with the implicit assumption that it may be a `null` value. There are no separate types for dictionaries with different key lengths or value types (after all, it's FunC, not FunC++).

### Taxonomy note

A dictionary primitive may interpret the keys of the dictionary either as unsigned `l`-bit integers, as signed `l`-bit integers, or as `l`-bit slices. The primitives listed below differ by the prefix before the word `dict` in their names. `i` stands for signed integer keys, `u` stands for unsigned integer keys, and an empty prefix stands for slice keys.

字典原语可能将字典的键解释为无符号 `l` 位整数、有符号 `l` 位整数或 `l` 位切片。下面列出的原语名称中的前缀不同。`i` 表示有符号整数键，`u` 表示无符号整数键，空前缀表示切片键。

例如，`udict_set` 是带有无符号整数键的字典的按键设置函数；`idict_set` 是带有有符号整数键的字典的相应函数；`dict_set` 是带有切片键的字典的函数。

标题中使用了空前缀。

### Dictionary's values

Values within a dictionary can be stored either as a subslice within an inner dictionary cell or through a reference to a separate cell. In the former scenario, it is not assured that a value small enough to fit within a cell will also fit within the dictionary, as part of the inner cell's space may already be occupied by a portion of the corresponding key. Conversely, the latter method of storage is less efficient in terms of gas usage. Storing a value using the second method is tantamount to inserting a slice with no data bits and a single reference to the value in the first method​​.

#### dict_set

```func
cell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
cell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
cell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
```

Sets the value associated with `key_len`-bit key `index` in dictionary `dict` to `value` (a slice) and returns the resulting dictionary.

#### dict_set_ref

```func
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
cell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
```

Similar to `dict_set` but with the value set to a reference to cell `value`.

#### dict_get?

```func
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
```

Searches for the key `index` within the `dict` dictionary, which uses keys of `key_len` bits. If successful, it retrieves the associated value as a `slice` and returns a flag value of `-1` to indicate **success**. If the search fails, it returns `(null, 0)​​`.

#### dict_get_ref?

```func
(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETREF";
(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF";
```

Similar to `dict_get?` but returns the first reference of the found value.

#### dict_get_ref

```func
cell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETOPTREF";
```

A variant of `dict_get_ref?` that returns `null` instead of the value if the key `index` is absent from the dictionary `dict`.

#### dict_set_get_ref

```func
(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETOPTREF";
```

Sets the value associated with `index` to `value` (if `value` is `null`, then the key is deleted instead) and returns the old value (or `null` if the value was absent).

#### dict_delete?

```func
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
```

Deletes `key_len`-bit key `index` from the dictionary `dict`. If the key is present, returns the modified dictionary `dict'` and the success flag `−1`. Otherwise, returns the original dictionary `dict` and `0`.

#### dict_delete_get?

```func
(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
```

Deletes `key_len`-bit key `index` from dictionary `dict`. If the key is present, returns the modified dictionary `dict'`, the original value `x` associated with the key k (represented by a Slice), and the success flag `−1`. Otherwise, returns `(dict, null, 0)`.

#### dict_add?

```func
(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";
(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
```

An `add` counterpart of `dict_set` sets the value associated with key `index` in dictionary `dict` to `value` but only if it is not already present in `D`. Returns either modified version of the dictionary and `-1` flag or `(dict, 0)`.

#### dict_replace?

```func
(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";
(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
```

A `replace` operation similar to `dict_set` but which sets the value of key `index` in dictionary `dict` to `value` only if the key was already present in `dict`. Returns either modified version of the dictionary and `-1` flag or `(dict, 0)`.

### Builder counterparts

The following primitives accept the new value as a builder instead of a slice, which often is more convenient if the value needs to be serialized from several components computed in the stack. The net effect is roughly equivalent to converting b into a slice and executing the corresponding primitive listed above.

#### dict_set_builder

```func
cell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
cell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
cell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
```

Similar to `dict_set` but accepts a builder.

#### dict_add_builder?

```func
(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";
(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
```

Similar to `dict_add?` but accepts a builder.

#### dict_replace_builder?

```func
(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";
(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
```

Similar to `dict_replace?` but accepts a builder.

#### dict_delete_get_min

```func
(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
```

Computes the minimum key `k` in dictionary `dict`, removes it, and returns `(dict', k, x, -1)`, where `dict'` is the modified version of `dict` and `x` is the value associated with `k`. If the dict is empty, returns `(dict, null, null, 0)`.

计算字典 `dict` 中的最小键 `k`，将其移除，并返回 `(dict', k, x, -1)`，其中 `dict'` 是修改后的 `dict`，`x` 是与 `k` 关联的值。如果字典为空，则返回 `(dict, null, null, 0)`。

#### dict_delete_get_max

```func
(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
```

Computes the maximum key `k` in dictionary `dict`, removes it, and returns `(dict', k, x, -1)`, where `dict'` is the modified version of `dict` and `x` is the value associated with `k`. If the dict is empty, returns `(dict, null, null, 0)`.

#### dict_get_min?

```func
(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMIN" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMIN" "NULLSWAPIFNOT2";
```

Computes the minimum key `k` in dictionary `dict`, the associated value `x`, and returns `(k, x, -1)`. If the dictionary is empty, returns `(null, null, 0)`.

#### dict_get_max?

```func
(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAX" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAX" "NULLSWAPIFNOT2";
```

Computes the maximum key `k` in dictionary `dict`, the associated value `x`, and returns `(k, x, -1)`. If the dictionary is empty, returns `(null, null, 0)`.

#### dict_get_min_ref?

```func
(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMINREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMINREF" "NULLSWAPIFNOT2";
```

Similar to `dict_get_min?` but returns the only reference in the value as a reference.

#### dict_get_max_ref?

```func
(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAXREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAXREF" "NULLSWAPIFNOT2";
```

Similar to `dict_get_max?` but returns the only reference in the value as a reference.

#### dict_get_next?

```func
(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT2";
```

Computes the minimum key `k` in dictionary `dict` that is greater than `pivot`; returns `k`, associated value, and a flag indicating success. If the dictionary is empty, returns `(null, null, 0)`.

#### dict_get_nexteq?

```func
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT2";
```

Similar to `dict_get_next?` but computes the minimum key `k` that is greater than or equal to `pivot`.

#### dict_get_prev?

```func
(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT2";
```

Similar to `dict_get_next?` but computes the maximum key `k` smaller than `pivot`.

#### dict_get_preveq?

```func
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT2";
```

Similar to `dict_get_prev?` but computes the maximum key `k` smaller than or equal to `pivot`.

#### new_dict

```func
cell new_dict() asm "NEWDICT";
```

Creates an empty dictionary, which is actually a `null` value. Special case of `null()`.

#### dict_empty?

```func
int dict_empty?(cell c) asm "DICTEMPTY";
```

Checks whether a dictionary is empty. Equivalent to `cell_null?`.

## Prefix dictionaries primitives

TVM also supports dictionaries with non-fixed length keys which form a prefix code (i.e., there is no key that is a prefix to another key). Learn more about them in the [TVM Instruction](/learn/tvm-instructions/tvm-overview) section.

#### pfxdict_get?

```func
(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTGETQ" "NULLSWAPIFNOT2";
```

Returns `(s', x, s'', -1)` or `(null, null, s, 0)`.
Looks up the unique prefix of slice `key` present in the prefix code dictionary `dict`. If found, the prefix of `s` is returned as `s'` and the corresponding value (also a slice) as `x`. The remainder of `s` is returned as slice `s''`. If no prefix of `s` is key in prefix code dictionary `dict`, it returns the unchanged `s` and a zero flag to indicate failure.

#### pfxdict_set?

```func
(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTSET";
```

Similar to `dict_set` but may fail if the key is a prefix of another key presented in the dictionary. Indicating success, returns a flag.

#### pfxdict_delete?

```func
(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTDEL";
```

Similar to `dict_delete?`.

## Special primitives

#### 特殊原语

```func
forall X -> X null() asm "PUSHNULL";
```

By the TVM type `Null`, FunC represents the absence of a value of some atomic type. So `null` can actually have any atomic type.

#### ~impure_touch

```func
forall X -> (X, ()) ~impure_touch(X x) impure asm "NOP";
```

Mark a variable as used, such that the code which produced it won't be deleted even if it is not impure. (c.f. [impure specifier](/develop/func/functions#impure-specifier))

## Other primitives

#### 其他原语

```func
int min(int x, int y) asm "MIN";
```

Computes the minimum of two integers `x` and `y`.

#### max

```func
int max(int x, int y) asm "MAX";
```

Computes the maximum of two integers `x` and `y`.

#### minmax

```func
(int, int) minmax(int x, int y) asm "MINMAX";
```

Sorts two integers.

#### abs

```func
int abs(int x) asm "ABS";
```

Computes the absolute value of the integer `x`.
