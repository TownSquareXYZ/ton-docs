import ConceptImage from '@site/src/components/conceptImage';
import ThemedImage from '@theme/ThemedImage';

# 消息概览

TON 是一个异步区块链，其结构与其他区块链非常不同。因此，新开发者经常对 TON 中的低级事物有疑问。在本文中，我们将探讨与消息传递相关的一个问题。 Because of this, new developers often have questions about low-level things in TON. In this article, we will have a look at one of these related to message delivery.

## 什么是消息？

消息是在actor（用户、应用程序、智能合约）之间发送的数据包。它通常包含指导接收方执行某种操作的信息，如更新存储或发送新消息。 It typically contains information instructing the receiver on what action to perform, such as updating storage or sending a new message.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_1.svg?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_1.svg?raw=true',
  }}
/>
</div>
<br></br>

这种通信方式让人想起将卫星发射到太空。我们知道我们构成的消息，但在发射后，需要进行单独的观察来找出我们将获得什么结果。 We know the message we've formed, but after its launch, it is necessary to conduct separate observation to find out what results we will obtain.

## 什么是交易？

TON 中的一笔交易包括以下内容：

- 最初触发合约的传入消息（存在特殊的触发方式）
- 由传入消息引起的合约行动，例如更新合约的存储（可选）
- 发送给其他参与者的所生成的传出消息（可选）

> 技术上，合约可以通过特殊功能如 [Tick-Tock](/develop/data-formats/transaction-layout#tick-tock) 触发，但这个功能更多用于 TON 内部的区块链核心合约。
>
> 并非每笔交易都会导致传出消息或对合约存储的更新——这取决于合约代码所定义的操作。

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_2.svg?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_2.svg?raw=true',
  }}
/>
<br></br>

如果我们看以太坊或几乎任何其他同步区块链，每笔交易可以包含几个智能合约调用。例如，如果选定的交易对没有流动性，DEX可以在一笔交易中执行多次交换。 For example, DEXs perform multiple exchanges in one transaction if there is no liquidity for the selected trading pair.

在异步系统中，您无法在同一笔交易中从目标智能合约获得响应。合约调用可能需要几个区块来处理，具体取决于来源和目的地之间的路由长度。 A contract call may take a few blocks to be processed, depending on the length of the route between source and destination.

To achieve the infinite sharding paradigm, it is necessary to ensure full parallelization, which means that the execution of each transactions is independent of every other. Therefore, instead of transactions which affect and change the state of many contracts at one time, each transaction in TON is only executed on a single smart contract and smart contracts communicate through messages. That way, smart contracts can only interact with each other by calling their functions with special messages and getting a response to them via other messages later.

:::info
在 [交易布局](/develop/data-formats/transaction-layout) 页面上有更详细和准确的描述。
:::

## 什么是逻辑时间？

In such a system with asynchronous and parallel smart contract calls, it can be hard to define the order of actions to process. That's why each message in TON has it's _Logical time_ or _Lamport time_ (later just _lt_). It is used to understand which event caused another and what a validator needs to process first.

严格保证由消息产生的交易将具有大于消息的 _lt_ 的 _lt_。同样，某笔交易中发送的消息的 _lt_ 严格大于引起它的交易的 _lt_。此外，从一个账户发送的消息和在一个账户上发生的交易也是严格有序的。 Likewise, the _lt_ of a message sent in some transaction is strictly greater than the _lt_ of the transaction that caused it. As well as this, messages that were sent from one account and transactions which happened on one account are strictly ordered as well.

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_3.svg?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_3.svg?raw=true',
  }}
/>
<br></br>

对于图像中的情况，结果是：`in_msg_lt < tx0_lt < out_msg_lt`

由此，对于每个账户，我们总是知道交易、接收消息和发送消息的顺序。

此外，如果账户 _A_ 向账户 _B_ 发送了两条消息，可以保证具有较低 _lt_ 的消息将被更早处理：

如果 `msg1_lt < msg2_lt` => `tx1_lt < tx2_lt`。

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_5.svg?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_5.svg?raw=true',
  }}
/>
</div>
<br></br>

否则，尝试同步交付将需要在处理一个分片之前知道所有其他的状态，从而破坏了并行并破坏有效的分片。

For each block, we can define the _lt_ span as starting from the first transaction and ending with the _lt_ of the last event in the block (message or transaction). Blocks are ordered the same way as other events in TON and so if one block depends on the other, it has a higher _lt_. The child block in a shard has a higher _lt_ than its parent. A masterchain block's _lt_ is higher that the _lts_ of shard blocks that it lists, since a master block depends on listed shard blocks. Each shard block contains an ordered reference to the latest (at the moment of shard block creation) master block and thus the shard block _lt_ is higher than the referenced master block _lt_.

## 消息传递

幸运的是，TON 的工作方式是任何内部消息都一定会被目标账户接收。消息不会在来源和目的地之间的任何地方丢失。外部消息有点不同，因为它们被接受到区块中是由验证者自行决定的，但是，一旦消息被接受进入传入消息队列，它将被传递。 A message cannot be lost anywhere between the source and its destination. External messages are a little bit different since their acceptance to the block is at the validator's discretion however, once the message is accepted into the incoming message queue, it will be delivered.

### 传递顺序

因此，看起来 _lt_ 解决了消息传递顺序的问题，因为我们知道具有较低 _lt_ 的交易将首先被处理。但这并不适用于每个场景。 But this doesn't work in every scenario.

Suppose that there are two contracts - _A_ and _B_. 假设有两个合约 - _A_ 和 _B_。_A_ 收到一个外部消息，触发它向 _B_ 发送两个内部消息，我们称这些消息为 _1_ 和 _2_。在这个简单的情况下，我们可以 100% 确定 _1_ 将在 _2_ 之前被 _B_ 处理，因为它具有较低的 _lt_。 In this simple case, we can be 100% sure that _1_ will be processed by _B_ before _2_ because it has a lower _lt_.

<ConceptImage src="/img/docs/msg-delivery-1.png" />

但这只是一个简单的案例，当我们只有两个合约时。我们的系统在更复杂的情况下是如何工作的？ How does our system works in more complex cases?

### 多个智能合约

Suppose that we have three contracts - _A_, _B_ and _C_. In a transaction, _A_ sends two internal messages _1_ and _2_: one to _B_ and another to _C_. Even though they were created in an exact order (_1_, then _2_), we can't be sure that _1_ will be processed before _2_. This is the case because routes from _A_ to _B_ and from _A_ to _C_ can differ in length and validator sets. If these contracts are in different shard chains, one of the messages may require several blocks to reach the destination contract.

为了更清晰，假设我们的合约在 `msg1` 和 `msg2` 由 `B` 和 `C` 合约执行后发送回消息 `msg1'` 和 `msg2'`。结果将在合约 `A` 上实现 `tx2'` 和 `tx1'`。我们有两种可能的交易路径， As a result it will be apply `tx2'` and `tx1'` on the contract `A`.
We have two possible trace for these transaction,

1. 第一种可能的顺序是 `tx1'_lt < tx2'_lt`：

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_6.svg?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_6.svg?raw=true',
  }}
/>
</div>
<br></br>

2. 第二种可能的顺序是 `tx2'_lt < tx1'_lt`：

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_7.svg?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_7.svg?raw=true',
  }}
/>
</div>
<br></br>

The same thing happens in the reverse case, when two contracts _B_ and _C_ send a message to one contract _A_. Even if message `B -> A` was sent before `C -> A`, we can't know which one of them will be delivered first. The `B -> A` route may require more shard chain hops.

<ConceptImage src="/img/docs/msg-delivery-3.png" />

There can be many possible scenarios of smart contract interactions, and in any scenario with more than 2 contracts, the order of messages delivery may be arbitrary. 在多个智能合约互动的许多可能的场景中，消息传递顺序可能是任意的。唯一的保证是，来自任何合约 _A_ 到任何合约 _B_ 的消息将按照它们的逻辑时间顺序处理。下面是一些示例。 Some examples are below.

<ConceptImage src="/img/docs/msg-delivery-4.png" />
<ConceptImage src="/img/docs/msg-delivery-5.png" />
<ConceptImage src="/img/docs/msg-delivery-6.png" />

## 结论

TON 区块链的异步结构为消息传递保证带来挑战。逻辑时间有助于确定事件和交易顺序，但由于分片链中的路由不同，它并不能保证多个智能合约之间的消息传递顺序。尽管存在这些复杂性，TON 仍然能够确保内部消息的传递，维护网络的可靠性。开发人员必须适应这些细微差别，以充分利用 TON 的潜力构建创新的去中心化应用程序。 Logical time helps to establish event and transaction order but doesn't guarantee message delivery order between multiple smart contracts due to varying routes in shard chains. Despite these complexities, TON ensures internal message delivery, maintaining network reliability. Developers must adapt to these nuances to harness TON's full potential in building innovative decentralized applications.
