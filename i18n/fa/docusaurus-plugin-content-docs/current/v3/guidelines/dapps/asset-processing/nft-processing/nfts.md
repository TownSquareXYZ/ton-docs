# پردازش NFT

## مرور کلی

در این بخش از مستندات ما، خوانندگان به درک بهتری از NFT ها دست خواهند یافت. این بخش به خواننده آموزش می‌دهد چگونه با NFT ها تعامل کند و چگونه NFT ها را، از طریق تراکنش‌های ارسال شده روی بلاکچین TON، بپذیرد.

اطلاعات ارائه شده در زیر فرض بر این دارد که خواننده پیش از این به بخش پیشین ما
[جزئیات پردازش پرداخت تونکوین](/v3/guidelines/dapps/asset-processing/payments-processing) عمیقاً وارد شده است، در حالی که همچنین فرض می‌کند که آنها دارای درک ابتدایی از تعامل با قراردادهای هوشمند کیف پول به صورت برنامه‌نویسی هستند.

## درک اصول اولیه NFT

NFT هایی که بر روی بلاکچین TON عمل می‌کنند توسط استانداردهای [TEP-62](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md) و [TEP-64](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md) نمایش داده می‌شوند.

بلاکچین The Open Network (TON) با در نظر گرفتن عملکرد بالا طراحی شده و شامل ویژگی است که از شاردینگ خودکار بر اساس آدرس‌های قرارداد در TON استفاده می‌کند (که برای تامین طراحی‌های خاص NFT استفاده می‌شوند). برای دستیابی به بهترین عملکرد، NFT های جداگانه باید از قرارداد هوشمند خودشان استفاده کنند. این امکان ایجاد کلکسیون‌های NFT با هر اندازه‌ای (چه بزرگ و چه کوچک) را فراهم می‌کند و در عین حال هزینه‌های توسعه و مشکلات عملکرد را کاهش می‌دهد. با این حال، این رویکرد نیز ملاحظات جدیدی را برای توسعه کلکسیون‌های NFT معرفی می‌کند.

به دلیل اینکه هر NFT از قرارداد هوشمند خود استفاده می‌کند، نمی‌توان از طریق یک قرارداد واحد اطلاعاتی درباره هر NFT در یک کلکسیون بدست آورد. برای بازیابی اطلاعات درباره کل کلکسیون به عنوان یک کل و همچنین هر آیتم NFT در کلکسیون، لازم است که هر دو قرارداد کلکسیون و قراردادهای آیتم های NFT جداگانه استعلام شوند. به همین دلیل، برای ردیابی انتقال NFT، لازم است که تمامی تراکنش‌ها برای هر آیتم NFT در یک کلکسیون خاص دنبال شوند.

### کلکسیون‌های NFT

کلکسیون NFT قراردادی است که برای فهرست و ذخیره محتوای NFT خدمت کرده و باید شامل رابط‌های زیر باشد:

#### متد دریافت `get_collection_data`

```
(int next_item_index, cell collection_content, slice owner_address) get_collection_data()
```

اطلاعات کلی درباره کلکسیون را بازیابی می‌کند، که به صورت زیر نمایش داده می‌شود:

1. `next_item_index` - اگر کلکسیون مرتب شده باشد، این رده‌بندی نشان‌دهنده تعداد کل NFTها در کلکسیون و همچنین شاخص بعدی برای استفاده در ضرب کردن است. برای کلکسیون‌های نامرتب، مقدار `next_item_index` برابر -1 است، به این معنا که مجموعه از مکانیزم‌های خاصی برای ردیابی NFTها استفاده می‌کند (مانند هش دامنه‌های TON DNS).
2. `collection_content` - یک cell که محتوای کلکسیون را در قالب سازگار با TEP-64 نمایش می‌دهد.
3. `owner_address` - یک slice که شامل آدرس مالک کلکسیون است (این مقدار نیز می‌تواند خالی باشد).

#### متد دریافت `get_nft_address_by_index`

```
(slice nft_address) get_nft_address_by_index(int index)
```

این متد می‌تواند برای تأیید صحت یک NFT و تأیید اینکه آیا واقعاً به یک کلکسیون خاص تعلق دارد یا خیر، استفاده شود. این متد همچنین به کاربران امکان می‌دهد که آدرس یک NFT را با ارائه شاخص آن در مجموعه بازیابی کنند. این متد باید یک slice را که شامل آدرس NFT متناسب با شاخص ارائه شده است، برگرداند.

#### متد دریافت `get_nft_content`

```
(cell full_content) get_nft_content(int index, cell individual_content)
```

چون کلکسیون به عنوان یک مخزن داده‌های مشترک برای NFT ها عمل می‌کند، این متد برای تکمیل محتوای NFT ضروری است. برای استفاده از این متد، ابتدا لازم است که `individual_content` آن NFT را با فراخوانی متد مربوطه `get_nft_data()` بدست آورید. بعد از دریافت `individual_content`، می‌توانید متد `get_nft_content()` را با شاخص NFT و سلول `individual_content` فراخوانی کنید. این متد باید یک سلول TEP-64 برگرداند که شامل محتوای کامل NFT است.

### NFT آیتم‌ها

NFT های پایه باید پیاده‌سازی کنند:

#### متد دریافت `get_nft_data()`

```
(int init?, int index, slice collection_address, slice owner_address, cell individual_content) get_nft_data()
```

#### مدیریت پیام درون‌خطی برای `transfer`

```
transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody
```

بیایید هر پارامتری که باید در پیام خودتان پر کنید را مورد بررسی قرار دهیم:

1. `OP` - `0x5fcc3d14` - یک ثابت تعریف شده توسط استاندارد TEP-62 درون پیام انتقال.
2. `queryId` - `uint64` - یک عدد uint64 که برای پیگیری پیام استفاده می‌شود.
3. `newOwnerAddress` - `MsgAddress` - آدرس قراردادی که برای انتقال NFT به آن استفاده می‌شود.
4. `responseAddress` - `MsgAddress` - آدرسی که برای انتقال موجودی اضافی استفاده می‌شود. معمولاً یک مقدار اضافی از تون (مثلاً ۱ تون) به قرارداد NFT ارسال می‌شود تا اطمینان حاصل شود که قرارداد دارای بودجه کافی برای پرداخت هزینه‌های تراکنش و ایجاد انتقال جدید در صورت لزوم است. تمامی وجوه استفاده نشده داخل تراکنش به `responseAddress` ارسال می‌شوند.
5. `forwardAmount` - `Coins` - مقدار تون که در کنار پیام پیشرو استفاده می‌شود (معمولاً به ۰٫۰۱ تون تنظیم می‌شود). از آنجا که تون از ریزمعماری غیرهمزمان استفاده می‌کند، صاحب جدید NFT بلافاصله پس از دریافت موفق تراکنش مطلع نمی‌شود. برای اطلاع رسانی به صاحب جدید، یک پیام داخلی از قرارداد هوشمند NFT به `newOwnerAddress` با مقداری که با استفاده از `forwardAmount` مشخص شده است، ارسال می‌شود. پیام پیشرو با `ownership_assigned` OP (`0x05138d91`) شروع می‌شود و به دنبال آن آدرس مالک قبلی و `forwardPayload` (اگر وجود داشته باشد) می‌آید.
6. `forwardPayload` - `Slice | Cell` - به عنوان بخشی از پیام اعلان `ownership_assigned` ارسال می‌شود.

این پیام (همانطور که در بالا توضیح داده شد) روش اصلی استفاده شده برای تعامل با یک NFT است که پس از دریافت یک اعلان در نتیجه پیام فوق، مالکیت تغییر می‌کند.

به عنوان مثال، این نوع پیام در بالا اغلب برای ارسال یک قرارداد هوشمند NFT از یک قرارداد هوشمند کیف‌پول استفاده می‌شود. هنگامی که یک قرارداد هوشمند NFT این پیام را دریافت کرده و اجرا کند، مخزن داده‌های قرارداد NFT (داده‌های داخلی قرارداد) به همراه شناسه مالک به‌روز می‌شود. به این ترتیب، آیتم NFT (قرارداد) مالکین را به درستی تغییر می‌دهد. این فرآیند جزئیات یک انتقال استاندارد NFT را ارائه می‌کند

در این صورت، مبلغ فوروارد باید به یک مقدار مناسب (۰٫۰۱ تون برای کیف‌پول معمولی یا بیشتر در صورتی که بخواهید با انتقال یک NFT قرارداد را اجرا کنید) تنظیم شود، تا اطمینان حاصل شود که مالک جدید اعلانی درباره انتقال مالکیت دریافت می‌کند. این مهم است زیرا بدون این اعلان، مالک جدید مطلع نخواهد شد که NFT را دریافت کرده است.

## بازیابی داده‌های NFT

بیشتر SDKها از هندلرهای آماده برای بازیابی داده‌های NFT استفاده می‌کنند، از جمله: [tonweb(js)](https://github.com/toncenter/tonweb/blob/b550969d960235314974008d2c04d3d4e5d1f546/src/contract/token/nft/NftItem.js#L38)، [tonutils-go](https://github.com/xssnick/tonutils-go/blob/fb9b3fa7fcd734eee73e1a73ab0b76d2fb69bf04/ton/nft/item.go#L132)، [pytonlib](https://github.com/toncenter/pytonlib/blob/d96276ec8a46546638cb939dea23612876a62881/pytonlib/client.py#L771) و دیگر SDKها.

برای دریافت داده‌های NFT لازم است از مکانیزم بازیابی `get_nft_data()` استفاده کنید. به عنوان مثال، باید آدرس آیتم NFT زیر را بررسی کنیم `EQB43-VCmf17O7YMd51fAvOjcMkCw46N_3JMCoegH_ZDo40e` (که به عنوان دامنه [foundation.ton](https://tonscan.org/address/EQB43-VCmf17O7YMd51fAvOjcMkCw46N_3JMCoegH_ZDo40e) نیز شناخته می‌شود).

ابتدا لازم است متد get را با استفاده از API سرویس toncenter.com به صورت زیر اجرا کنید:.

```
curl -X 'POST' \
  'https://toncenter.com/api/v2/runGetMethod' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "address": "EQB43-VCmf17O7YMd51fAvOjcMkCw46N_3JMCoegH_ZDo40e",
  "method": "get_nft_data",
  "stack": []
}'
```

پاسخ به طور معمول چیزی مشابه زیر خواهد بود:

```json
{
  "ok": true,
  "result": {
    "@type": "smc.runResult",
    "gas_used": 1581,
    "stack": [
      // init
      [ "num", "-0x1" ],
      // index
      [ "num", "0x9c7d56cc115e7cf6c25e126bea77cbc3cb15d55106f2e397562591059963faa3" ],
      // collection_address
      [ "cell", { "bytes": "te6cckEBAQEAJAAAQ4AW7psr1kCofjDYDWbjVxFa4J78SsJhlfLDEm0U+hltmfDtDcL7" } ],
      // owner_address
      [ "cell", { "bytes": "te6cckEBAQEAJAAAQ4ATtS415xpeB1e+YRq/IsbVL8tFYPTNhzrjr5dcdgZdu5BlgvLe" } ],
      // content
      [ "cell", { "bytes": "te6cckEBCQEA7AABAwDAAQIBIAIDAUO/5NEvz/d9f/ZWh+aYYobkmY5/xar2cp73sULgTwvzeuvABAIBbgUGAER0c3/qevIyXwpbaQiTnJ1y+S20wMpSzKjOLEi7Jwi/GIVBAUG/I1EBQhz26hlqnwXCrTM5k2Qg5o03P1s9x0U4CBUQ7G4HAUG/LrgQbAsQe0P2KTvsDm8eA3Wr0ofDEIPQlYa5wXdpD/oIAEmf04AQe/qqXMblNo5fl5kYi9eYzSLgSrFtHY6k/DdIB0HmNQAQAEatAVFmGM9svpAE9og+dCyaLjylPtAuPjb0zvYqmO4eRJF0AIDBvlU=" } ]
    ],
    "exit_code": 0,
    "@extra": "1679535187.3836682:8:0.06118075068995321"
  }
}
```

پارامترهای بازگشتی:

- `init` - `boolean` - -1 به این معناست که NFT مقداردهی اولیه شده و قابل استفاده است.
- `index` - `uint256` - شاخص NFT در کلکسیون. می‌تواند ترتیبی یا به روش دیگری ایجاد شده باشد. به عنوان مثال، می‌تواند یک هش دامنه NFT که با قراردادهای TON DNS استفاده می‌شود را نشان دهد، در حالی که کلکسیون‌ها باید فقط یک NFT منحصربه‌فرد در شاخص داده شده داشته باشد.
- `collection_address` - `Cell` - یک سلول شامل آدرس کلکسیون NFT (می‌تواند خالی باشد).
- `owner_address` - `Cell` - یک سلول شامل آدرس مالک فعلی NFT (می‌تواند خالی باشد).
- `content` - `Cell` - یک سلول شامل محتوای آیتم NFT (در صورتی که تجزیه نیاز باشد لازم است به استاندارد TEP-64 مراجعه کنید).

## بازیابی تمام NFTهای یک کلکسیون

فرآیند بازیابی تمام NFTهای یک کلکسیون به ترتیب یا عدم ترتیب کلکسیون بستگی دارد. در زیر هر دو فرآیند را توضیح می‌دهیم.

### کلکسیون های مرتب

بازیابی تمام NFTها از یک کلکسیون مرتب نسبتاً ساده است زیرا تعداد NFTهای مورد نیاز برای بازیابی قبلاً مشخص شده و می‌توان آدرس‌های آن‌ها را به راحتی بدست آورد. برای تکمیل این فرآیند، مراحل زیر را به ترتیب دنبال کنید:

1. متد `get_collection_data` را با استفاده از API سرویس TonCenter در قرارداد کلکسیون فراخوانی کنید و مقدار `next_item_index` را از پاسخ بازیابی کنید.
2. از متد `get_nft_address_by_index` استفاده کنید، مقدار شاخص `i` (در ابتدا بر روی 0 تنظیم شده) را قرار دهید، تا آدرس اولین NFT در کلکسیون را بازیابی کنید.
3. با استفاده از آدرس به دست آمده از مرحله قبل، داده‌های آیتم NFT را بازیابی کنید. سپس، بررسی کنید که قرارداد هوشمند کلکسیون NFT اولیه با قرارداد هوشمند کلکسیون NFT که آیتم NFT خودش گزارش می‌کند مطابقت دارد (برای اطمینان از این که کلکسیون قرارداد هوشمند NFT کاربر دیگر را مالک نکرده است).
4. متد `get_nft_content` را با `i` و `individual_content` از مرحله قبل فراخوانی کنید.
5. `i` را یک واحد افزایش دهید و مراحل ۲-۵ را تکرار کنید تا `i` برابر با `next_item_index` شود.
6. در این مرحله، اطلاعات لازم از کلکسیون و آیتم‌های آن را در اختیار خواهید داشت.

### کلکسیون‌های بدون ترتیب

بازیابی فهرست NFTها در یک کلکسیون بدون ترتیب دشوارتر است زیرا هیچ روش بالذاتی برای دریافت آدرس‌های NFTهایی که به کلکسیون تعلق دارد وجود ندارد. بنابراین، لازم است که تمام تراکنش‌ها در قرارداد کلکسیون تجزیه شده و تمام پیام‌های خروجی بررسی شوند تا آن‌هایی که به NFTهای مربوط به کلکسیون تعلق دارد شناسایی شوند.

برای این کار، لازم است داده‌های NFT را بازیابی کرده و متد `get_nft_address_by_index` را در کلکسیون با شناسه بازگشتی توسط NFT فراخوانی کنید. اگر آدرس قرارداد NFT و آدرسی که به وسیله متد `get_nft_address_by_index` برگردانده شده با هم مطابقت داشته باشند، نشان‌دهنده این است که NFT به کلکسیون فعلی متعلق است. با این حال، تجزیه تمام پیام‌ها به کلکسیون می‌تواند یک فرآیند طولانی باشد و ممکن است نیاز به گره‌های آرشیو داشته باشد.

## کار با NFTها خارج از TON

### ارسال NFTها

برای انتقال مالکیت NFT لازم است یک پیام داخلی از کیف پول مالک NFT به قرارداد NFT ارسال کنید با ایجاد یک سلول که یک پیام انتقال را شامل می‌شود. این می‌تواند با استفاده از کتابخانه‌ها (مانند [tonweb(js)](https://github.com/toncenter/tonweb/blob/b550969d960235314974008d2c04d3d4e5d1f546/src/contract/token/nft/NftItem.js#L65)، [ton(js)](https://github.com/getgems-io/nft-contracts/blob/debcd8516b91320fa9b23bff6636002d639e3f26/packages/contracts/nft-item/NftItem.data.ts#L102)، [tonutils-go(go)](https://github.com/xssnick/tonutils-go/blob/fb9b3fa7fcd734eee73e1a73ab0b76d2fb69bf04/ton/nft/item.go#L132)) برای زبان خاص انجام شود.

پس از ایجاد پیام انتقال، باید آن را از آدرس قرارداد کیف پول مالک به آدرس قرارداد آیتم NFT ارسال کرد و مقدار کافی از TON به همراه داشت تا هزینه تراکنش مربوطه را پوشش دهد.

برای انتقال یک NFT از کاربر دیگر به خودتان، لازم است از TON Connect 2.0 یا یک کد QR ساده که حاوی لینک ton:// است استفاده کنید. به عنوان مثال:
`ton://transfer/{nft_address}?amount={message_value}&bin={base_64_url(transfer_message)}`

### دریافت NFT

فرآیند ردیابی NFT‌هایی که به یک آدرس قرارداد هوشمند خاص (یعنی کیف پول کاربر) ارسال می‌شوند، مشابه مکانیزمی است که برای ردیابی پرداخت‌ها استفاده می‌شود. این کار با گوش کردن به همه تراکنش‌های جدید در کیف پول شما و تجزیه آن‌ها انجام می‌شود.

مراحل بعدی بسته به نوع استفاده مورد نظر ممکن است متفاوت باشد. بیایید در ادامه چندین سناریو مختلف را بررسی کنیم.

#### سرویس منتظر برای انتقال‌ها در یک آدرس NFT شناخته شده:

- تراکنش‌های جدید ارسال شده از آدرس قرارداد هوشمند آیتم NFT را تأیید کنید.
- اولین ۳۲ بیت از بدنه پیام را با استفاده از نوع `uint` بخوانید و تأیید کنید که برابر با `op::ownership_assigned()`(`0x05138d91`) است
- ۶۴ بیت بعدی را از بدنه پیام به عنوان `query_id` بخوانید.
- آدرس را از بدنه پیام به عنوان `prev_owner_address` بخوانید.
- اکنون می‌توانید NFT جدید خود را مدیریت کنید.

#### سرویس به همه انواع انتقال NFT گوش می‌دهد:

- تمام تراکنش‌های جدید را بررسی کنید و مواردی را که طول بدنه آن‌ها کمتر از ۳۶۳ بیت است نادیده بگیرید (OP - 32, QueryID - 64, Address - 267).
- مراحل شرح داده شده در لیست قبلی را تکرار کنید.
- اگر فرآیند به درستی کار می‌کند، لازم است با تجزیه NFT و کلکسیونی که متعلق به آن است، اصالت NFT را تأیید کنید. سپس لازم است مطمئن شوید که NFT به کلکسیون مشخص شده تعلق دارد. اطلاعات بیشتری که این فرآیند را توضیح می‌دهد را می‌توان در بخش `Getting all collection NFTs` یافت. این فرآیند را می‌توان با استفاده از لیست سفید NFT یا کلکسیون‌ها ساده کرد.
- اکنون می‌توانید NFT جدید خود را مدیریت کنید.

#### پیوند دادن انتقال NFT به تراکنش‌های داخلی:

هنگامی که از این نوع تراکنش دریافت می‌شود، لازم است مراحل لیست قبلی را تکرار کرد. هنگامی که این فرآیند تکمیل شد، می‌توان پارامتر `RANDOM_ID` را با خواندن uint32 از بدنه پیام پس از خواندن مقدار `prev_owner_address` بازیابی کرد.

#### NFT‌هایی که بدون پیام اعلامیه ارسال شده‌اند:

تمام استراتژی‌های بالا به این بستگی دارند که سرویس به درستی یک پیام فورواردینگ را با انتقال NFT ایجاد کنند. اگر آن‌ها این کار را نکنند، نمی‌دانیم که آیا NFT را به ما منتقل کرده‌اند یا خیر. با این حال، چند راه‌حل وجود دارد:

تمام استراتژی‌های بالا به این بستگی دارند که سرویس به درستی یک پیام فورواردینگ را در انتقال NFT ایجاد کنند. اگر این فرآیند انجام نشود، مشخص نخواهد شد که آیا NFT به طرف صحیح منتقل شده است یا خیر. با این حال، چندین راه‌حل در این سناریو وجود دارد:

- اگر تعداد کمی از NFTها انتظار می‌رود، می‌توان آن‌ها را به صورت دوره‌ای تجزیه و تحلیل کرد و تأیید کرد که آیا مالک قرارداد مربوطه تغییر کرده است یا خیر.
- اگر تعداد زیادی از NFTها انتظار می‌رود، می‌توان تمام بلوک‌های جدید را تجزیه و تحلیل کرد و تأیید کرد که آیا تماس‌های ارسال شده به مقصد NFT با استفاده از روش `op::transfer` ارسال شده‌اند یا خیر. اگر چنین تراکنشی آغاز شود، می‌توان مالک NFT را تأیید کرده و انتقال را دریافت کرد.
- اگر امکان تجزیه بلوک‌های جدید در حین انتقال وجود نداشته باشد، کاربران می‌توانند خود فرآیند تأیید مالکیت NFT را آغاز کنند. به این ترتیب، می‌توان فرآیند تأیید مالکیت NFT را پس از انتقال NFT بدون اطلاع‌رسانی راه‌اندازی کرد.

## تعامل با NFTها از قراردادهای هوشمند

اکنون که اصول ارسال و دریافت NFT‌ها را بررسی کردیم، بیایید بررسی کنیم که چگونه می‌توان NFT‌ها را از قراردادهای هوشمند با استفاده از مثال قرارداد [فروش NFT](https://github.com/ton-blockchain/token-contract/blob/1ad314a98d20b41241d5329e1786fc894ad811de/nft/nft-sale.fc) دریافت و انتقال داد.

### ارسال NFT

در این مثال، پیام انتقال NFT در [خط ۶۷](https://www.google.com/url?q=https://github.com/ton-blockchain/token-contract/blob/1ad314a98d20b41241d5329e1786fc894ad811de/nft/nft-sale.fc%23L67\&sa=D\&source=docs\&ust=1685436161341866\&usg=AOvVaw1yuoIzcbEuvqMS4xQMqfXE) قرار دارد:

```
var nft_msg = begin_cell()
  .store_uint(0x18, 6)
  .store_slice(nft_address)
  .store_coins(0)
  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
  .store_uint(op::transfer(), 32)
  .store_uint(query_id, 64)
  .store_slice(sender_address) ;; new_owner_address
  .store_slice(sender_address) ;; response_address
  .store_int(0, 1) ;; empty custom_payload
  .store_coins(0) ;; forward amount to new_owner_address
  .store_int(0, 1); ;; empty forward_payload


send_raw_message(nft_msg.end_cell(), 128 + 32);
```

بیایید هر خط کد را بررسی کنیم:

- `store_uint(0x18, 6)` - نشانگر‌های پیام را ذخیره می‌کند.
- `store_slice(nft_address)` - مقصدهای پیام (آدرس‌های NFT) را ذخیره می‌کند.
- `store_coins(0)` - مقدار تونکوین که با پیام ارسال می‌شود به ۰ تنظیم شده است زیرا از  [حالت پیام](/v3/documentation/smart-contracts/message-management/sending-messages#message-modes) `128` برای ارسال پیام با باقیمانده بالانس استفاده می‌شود. برای ارسال میزان غیر از کل بالانس کاربر، باید عدد تغییر کند. توجه داشته باشید که باید به اندازه کافی بزرگ باشد که هزینه‌های گاز و هر میزان ارسال را پوشش دهد.
- `store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)` - سایر اجزای تشکیل دهنده هدر پیام خالی می‌مانند.
- `store_uint(op::transfer(), 32)` - این شروع msg_body است. در اینجا با استفاده از کد OP انتقال شروع می‌کنیم تا گیرنده پیام انتقال مالکیت را درک کند.
- `store_uint(query_id, 64)` - ذخیره query_id
- `store_slice(sender_address) ;; new_owner_address` - اولین آدرس ذخیره شده، آدرسی است که برای انتقال NFTها و ارسال اعلان‌ها استفاده می‌شود.
- `store_slice(sender_address) ;; response_address` - دومین آدرس ذخیره شده، یک آدرس پاسخ است.
- `store_int(0, 1)` - نشانگر بار سفارشی به 0 تنظیم شده است که نشان می‌دهد نیازی به بار سفارشی نیست.
- `store_coins(0)` - میزان تونکوین برای ارسال همراه پیام. در این مثال به 0 تنظیم شده است، اما توصیه می‌شود این مقدار را به یک میزان بالاتر تنظیم کنید (حداقل ۰.۰۱ تونکوین) تا پیام موفقیت انتقال ارسال شود و مالک جدید مطلع شود که NFT دریافت کرده‌ است. مقدار باید به اندازه کافی برای پوشش هزینه‌های مرتبط باشد.
- `.store_int(0, 1)` - نشانگر بار سفارشی. اگر سرویس شما باید بار را به عنوان ref بفرستد، لازم است تا به `1` تنظیم شود.

### دریافت NFTها

پس از ارسال NFT، تعیین اینکه چه زمان به مالک جدید تحویل داده شده است بسیار مهم است. مثالی خوب از اینکه چگونه می‌توان این کار را انجام داد، در همان قرارداد هوشمند فروش NFT موجود است:

```
slice cs = in_msg_full.begin_parse();
int flags = cs~load_uint(4);

if (flags & 1) {  ;; ignore all bounced messages
    return ();
}
slice sender_address = cs~load_msg_addr();
throw_unless(500, equal_slices(sender_address, nft_address));
int op = in_msg_body~load_uint(32);
throw_unless(501, op == op::ownership_assigned());
int query_id = in_msg_body~load_uint(64);
slice prev_owner_address = in_msg_body~load_msg_addr();
```

بیایید دوباره به هر خط کد نگاه کنیم:

- `slice cs = in_msg_full.begin_parse();` - برای تجزیه پیام ورودی استفاده می‌شود.
- `int flags = cs~load_uint(4);` - برای بارگیری نشانگرها از اولین ۴ بیت پیام استفاده می‌شود.
- `if (flags & 1) { return (); } ;; ignore all bounced messages` - برای اطمینان از اینکه پیام بازگردانده نشده است، استفاده می‌شود. مهم است که این فرایند را برای همه پیام‌های ورودی خود انجام دهید مگر اینکه دلیل انجام ندادن داشته باشید. پیام‌های بازگردانده شده پیام‌هایی هستند که در حین تلاش برای دریافت یک تراکنش با خطا مواجه شده‌اند و به فرستنده بازگردانده شده‌اند.
- `slice sender_address = cs~load_msg_addr();` - در مرحله بعدی آدرس فرستنده پیام بارگیری می‌شود. در این مورد، به طور خاص با استفاده از آدرس NFT.
- `throw_unless(500, equal_slices(sender_address, nft_address));` - برای اطمینان از اینکه فرستنده واقعاً یک NFT است که باید از طریق قرارداد منتقل می‌شد، استفاده می‌شود. تجزیه داده‌های NFT از قراردادهای هوشمند نسبتاً دشوار است، بنابراین در اکثر موارد آدرس NFT در زمان ایجاد قرارداد از پیش تعریف شده است.
- `int op = in_msg_body~load_uint(32);` - بارگذاری کد عملیاتی پیام.
- `throw_unless(501, op == op::ownership_assigned());` - اطمینان حاصل می‌کند که کد عملیاتی دریافت شده با مقدار ثابت اختصاص مالکیت مطابقت دارد.
- `slice prev_owner_address = in_msg_body~load_msg_addr();` - آدرس مالک قبلی که از بدنه پیام ورودی استخراج شده و به متغیر slice `prev_owner_address` بارگذاری می‌شود. این می‌تواند مفید باشد اگر مالک قبلی لغو قرارداد را انتخاب کند و NFT به او بازگردانده شود.

اکنون که پیام اطلاعیه را با موفقیت تجزیه و اعتبارسنجی کرده‌ایم، می‌توانیم با منطق کسب‌وکار خود ادامه دهیم که برای شروع یک قرارداد هوشمند فروش استفاده می‌شود (که برای مدیریت فرآیندهای فروش آیتم NFT برای حراج‌های NFT مانند getgems.io استفاده می‌شود)
