# تجزیه متادیتا

استاندارد متادیتا که شامل NFTها، کلکسیون‌های NFT و Jettonها است، در پیشنهاد بهبود TON شماره ۶۴ [TEP-64](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md) توضیح داده شده است.

در TON، موجودیت‌ها می‌توانند سه نوع متادیتا داشته باشند: در زنجیره، نیمه‌زنجیره، و خارج از زنجیره.

- **متادیتای در زنجیره:** که در داخل بلاک‌چین ذخیره می‌شود و شامل نام، ویژگی‌ها و تصویر است.
- **متادیتای خارج از زنجیره:** با استفاده از لینک به فایل متادیتا که خارج از زنجیره میزبانی می‌شود، ذخیره می‌شود.
- **متادیتای نیمه‌زنجیره:** ترکیبی بین هر دو که اجازه می‌دهد فیلدهای کوچکی مانند نام‌ها یا ویژگی‌ها در بلاک‌چین ذخیره شوند، در حالی که تصویر خارج از زنجیره میزبانی می‌شود و فقط لینکی به آن ذخیره می‌شود.

## کدگذاری داده‌ها به صورت Snake

فرمت کدگذاری Snake قسمتی از داده را در یک سلول استاندارد ذخیره می‌کند، در حالی که قسمت باقی‌مانده در یک سلول فرزند (به صورت بازگشتی) ذخیره می‌شود. فرمت کدگذاری Snake باید با بایت 0x00 آغاز شود. طرح TL-B:

```
tail#_ {bn:#} b:(bits bn) = SnakeData ~0;
cons#_ {bn:#} {n:#} b:(bits bn) next:^(SnakeData ~n) = SnakeData ~(n + 1);
```

فرمت Snake برای ذخیره داده‌های اضافی در یک سلول زمانی که داده‌ها از حداکثر اندازه‌ای که می‌تواند در یک سلول قرار گیرد، فراتر می‌رود، استفاده می‌شود. این کار با ذخیره قسمتی از داده‌ها در سلول ریشه و ادامه به اولین سلول فرزند به صورت بازگشتی تا زمان ذخیره‌سازی تمام داده‌ها انجام می‌شود.

در زیر مثالی از کدگذاری و دیکد کردن فرمت Snake در TypeScript آمده است:

```typescript
export function makeSnakeCell(data: Buffer): Cell {
  const chunks = bufferToChunks(data, 127)

  if (chunks.length === 0) {
    return beginCell().endCell()
  }

  if (chunks.length === 1) {
    return beginCell().storeBuffer(chunks[0]).endCell()
  }

  let curCell = beginCell()

  for (let i = chunks.length - 1; i >= 0; i--) {
    const chunk = chunks[i]

    curCell.storeBuffer(chunk)

    if (i - 1 >= 0) {
      const nextCell = beginCell()
      nextCell.storeRef(curCell)
      curCell = nextCell
    }
  }

  return curCell.endCell()
}

export function flattenSnakeCell(cell: Cell): Buffer {
  let c: Cell | null = cell;

  const bitResult = new BitBuilder();
  while (c) {
    const cs = c.beginParse();
    if (cs.remainingBits === 0) {
      break;
    }

    const data = cs.loadBits(cs.remainingBits);
    bitResult.writeBits(data);
    c = c.refs && c.refs[0];
  }

  const endBits = bitResult.build();
  const reader = new BitReader(endBits);

  return reader.loadBuffer(reader.remaining / 8);
}
```

باید توجه داشت که پیشوند بایت `0x00` همیشه در سلول ریشه زمانی که از فرمت Snake استفاده می‌شود، مانند محتوای NFT خارج از زنجیره، لازم نیست. علاوه بر این، سلول‌ها با بایت‌ها به جای بیت‌ها پر می‌شوند تا تجزیه آن ساده‌تر شود. برای جلوگیری از مشکل افزودن مرجع (در سلول فرزند بعدی) به مرجعی که قبلاً به سلول ریشه آن نوشته شده است، سلول Snake به صورت معکوس ساخته می‌شود.

## کدگذاری به صورت تکه‌ای

فرمت کدگذاری تکه‌ای برای ذخیره داده با استفاده از ساختار داده لغت‌نامه‌ای از chunk_index تا chunk استفاده می‌شود. کدگذاری تکه‌ای باید با بایت `0x01` آغاز شود. طرح TL-B:

```
chunked_data#_ data:(HashMapE 32 ^(SnakeData ~0)) = ChunkedData;
```

در زیر مثالی از دیکد کردن داده تکه‌ای با استفاده از TypeScript آمده است:

```typescript
interface ChunkDictValue {
  content: Buffer;
}
export const ChunkDictValueSerializer = {
  serialize(src: ChunkDictValue, builder: Builder) {},
  parse(src: Slice): ChunkDictValue {
    const snake = flattenSnakeCell(src.loadRef());
    return { content: snake };
  },
};

export function ParseChunkDict(cell: Slice): Buffer {
  const dict = cell.loadDict(
    Dictionary.Keys.Uint(32),
    ChunkDictValueSerializer
  );

  let buf = Buffer.alloc(0);
  for (const [_, v] of dict) {
    buf = Buffer.concat([buf, v.content]);
  }
  return buf;
}
```

## ویژگی‌های متادیتای NFT

| ویژگی         | نوع        | نیازمندی | توضیحات                                                                                        |
| ------------- | ---------- | -------- | ---------------------------------------------------------------------------------------------- |
| `uri`         | رشته ASCII | اختیاری  | یک URI که به سند JSON با متادیتا اشاره می‌کند که با "چیدمان محتوای نیمه زنجیره" استفاده می‌شود |
| `name`        | رشته UTF8  | اختیاری  | دارایی را مشخص می‌کند                                                                          |
| `description` | رشته UTF8  | اختیاری  | دارایی را توصیف می‌کند                                                                         |
| `image`       | رشته ASCII | اختیاری  | یک URI که به منبعی همراه با نوع mime تصویر اشاره دارد                                          |
| `image_data`  | باینری\*   | اختیاری  | یک نمای باینری از تصویر برای چیدمان در زنجیره یا base64 برای چیدمان خارج از زنجیره             |

## ویژگی‌های متادیتای Jetton

1. `uri` - اختیاری. توسط "چیدمان محتوا نیمه‌زنجیره" استفاده می‌شود. رشته ASCII. یک URI که به سند JSON با متادیتا اشاره دارد.
2. `name` - اختیاری. رشته UTF8. دارایی را مشخص می‌کند.
3. `description` - اختیاری. رشته UTF8. دارایی را توصیف می‌کند.
4. `image` - اختیاری. رشته ASCII. یک URI که به منبعی همراه با نوع mime تصویر اشاره دارد.
5. `image_data` - اختیاری. نمای باینری از تصویر برای چیدمان در زنجیره یا base64 برای چیدمان خارج از زنجیره.
6. `symbol` - اختیاری. رشته UTF8. نماد توکن - به عنوان مثال "XMPL". در قالب "You received 99 XMPL" استفاده می‌شود.
7. `decimals` - اختیاری. اگر مشخص نشود، به طور پیش‌فرض ۹ استفاده می‌شود. رشته رمزگذاری شده UTF8 با عددی از ۰ تا ۲۵۵. تعداد اعشار استفاده شده در توکن - به عنوان مثال ۸، به معنای تقسیم مقدار توکن بر ۱۰۰۰۰۰۰۰۰ برای به دست آوردن مقدار نمایشی به کاربر است.
8. `amount_style` - اختیاری. مورد نیاز برای برنامه‌های خارجی برای درک شکل نمایش تعداد Jettonها.

- "n" - تعداد Jettonها (مقدار پیش‌فرض). اگر کاربر ۱۰۰ توکن با اعشار ۰ داشته باشد، نشان می‌دهد که کاربر ۱۰۰ توکن دارد
- "n-of-total" - تعداد Jettonها از کل تعداد Jettonها صادر شده. به عنوان مثال totalSupply Jetton = 1000. یک کاربر ۱۰۰ عدد Jetton در کیف پول Jetton دارد. باید در کیف پول کاربر به صورت ۱۰۰ از ۱۰۰۰ یا به هر روش متنی یا گرافیکی دیگری نشان داده شود تا خاص از عمومی را نشان دهد.
- "%" - درصد Jettonها از تعداد کل Jettonهای صادر شده. به عنوان مثال، totalSupply Jetton = 1000. یک کاربر ۱۰۰ عدد Jetton در کیف پول Jetton دارد. برای مثال، باید به عنوان ۱۰٪ در کیف پول کاربر نمایش داده شود.

9. `render_type` - اختیاری. توسط برنامه‌های خارجی لازم است تا بفهمند Jetton به کدام گروه تعلق دارد و چگونه باید نمایش داده شود.

- "currency" - نمایش به عنوان ارز (مقدار پیش‌فرض).
- "game" - نمایش برای بازی‌ها. باید به عنوان NFT نمایش داده شود، اما در عین حال تعداد Jettonها را با در نظر گرفتن `amount_style` نمایش دهد

| ویژگی          | نوع        | نیازمندی | توضیحات                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------- | ---------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `uri`          | رشته ASCII | اختیاری  | یک URI که به سند JSON با متادیتا اشاره می‌کند که با "چیدمان محتوای نیمه زنجیره" استفاده می‌شود                                                                                                                                                                                                                                                                                             |
| `name`         | رشته UTF8  | اختیاری  | دارایی را مشخص می‌کند                                                                                                                                                                                                                                                                                                                                                                      |
| `description`  | رشته UTF8  | اختیاری  | دارایی را توصیف می‌کند                                                                                                                                                                                                                                                                                                                                                                     |
| `image`        | رشته ASCII | اختیاری  | یک URI که به یک منبع همراه با نوع mime تصویر اشاره می‌کند                                                                                                                                                                                                                                                                                                                                  |
| `image_data`   | باینری\*   | اختیاری  | یک نمای باینری از تصویر برای چیدمان در زنجیره یا base64 برای چیدمان خارج از زنجیره                                                                                                                                                                                                                                                                                                         |
| `symbol`       | رشته UTF8  | اختیاری  | نماد توکن – برای مثال "XMPL" و به شکل "You received 99 XMPL" استفاده می‌شود                                                                                                                                                                                                                                                                                                                |
| `decimals`     | رشته UTF8  | اختیاری  | تعداد ارقام اعشاری که توکن استفاده می‌کند. در صورت عدم مشخص شدن، به طور پیش‌فرض ۹ استفاده می‌شود. رشته ای با کدگذاری UTF8 با اعداد بین ۰ تا ۲۵۵. – برای مثال ۸، به این معنا که مقدار توکن باید بر ۱۰۰۰۰۰۰۰۰ تقسیم شود تا مقدار نمایشی به کاربر به دست آید.                                                                 |
| `amount_style` |            | اختیاری  | توسط برنامه‌های خارجی لازم است تا بفهمند کدام قالب برای نمایش تعداد Jettonها استفاده شود. با *n*، *n-of-total*، *%* تعریف می‌شود.                                                                                                                                                                                                                          |
| `render_type`  |            | اختیاری  | توسط برنامه‌های خارجی لازم است تا بفهمند کدام گروه Jetton تعلق دارد و چگونه باید نمایش داده شود. "currency" - به عنوان ارز نمایش داده می‌شود (مقدار پیش‌فرض). "game" - نمایش برای بازی‌ها. باید به عنوان NFT نمایش داده شود، اما در عین حال تعداد Jettonها را با در نظر گرفتن `amount_style` نمایش دهد. |

> پارامترهای `amount_style`:

- _n" - تعداد Jettonها (مقدار پیش‌فرض). اگر کاربر ۱۰۰ توکن با اعشار ۰ داشته باشد، نشان می‌دهد که کاربر ۱۰۰ توکن دارد.
- "n-of-total" - تعداد Jettonها از کل تعداد Jettonها صادر شده. به عنوان مثال totalSupply Jetton = 1000. یک کاربر ۱۰۰ عدد Jetton در کیف پول Jetton دارد. باید در کیف پول کاربر به صورت ۱۰۰ از ۱۰۰۰ یا به هر روش متنی یا گرافیکی دیگری نسبت توکن‌های کاربر به کل مقدار توکن‌های قابل دسترس نمایش داده شود.
- *%* درصد Jettonها از تعداد کل Jettonهای صادر شده. به عنوان مثال، totalSupply Jetton = 1000. یک کاربر ۱۰۰ عدد Jetton نگه می‌دارد، درصد باید به عنوان ۱۰٪ در تراز کیف پول کاربر نمایش داده شود (۱۰۰ ÷ ۱۰۰۰ = ۰٫۱ یا ۱۰٪).

> پارامترهای `render_type`:

- *currency* - به عنوان ارز نمایش داده می‌شود (مقدار پیش‌فرض).
- *game* - نمایشی که برای بازی‌ها استفاده می‌شود و به عنوان NFT نمایش داده شود، اما در عین حال تعداد Jettonها را با در نظر گرفتن `amount_style` نمایش دهد.

## تجزیه متادیتا

برای تجزیه متادیتا، ابتدا باید داده‌های NFT را از بلاکچین به‌دست آورد. برای درک بهتر این فرایند، مطالعه بخش [بازیابی داده‌های NFT](/v3/guidelines/dapps/asset-processing/nft-processing/nfts#retrieving-nft-data) در بخش مستندات پردازش دارایی‌های TON ما را در نظر بگیرید.

پس از دریافت داده‌های NFT بر روی زنجیره، باید تجزیه شود. برای انجام این فرآیند، نوع محتوای NFT باید با خواندن اولین بایت که سازنده عملکرد داخلی NFT است، تعیین شود.

### خارج از زنجیره

اگر رشته بایت متادیتا با `0x01` شروع شود، به یک نوع محتوای NFT خارج از زنجیره اشاره دارد. قسمت باقی‌مانده محتوای NFT با استفاده از یک قالب کدگذاری Snake به عنوان یک رشته ASCII رمزگشایی می‌شود. پس از دستیابی به آدرس NFT صحیح و بازیابی داده‌های شناسایی NFT، فرآیند کامل می‌شود. در زیر نمونه‌ای از یک URL است که از تجزیه متادیتا محتوای NFT خارج از زنجیره استفاده می‌کند:
`https://s.getgems.io/nft/b/c/62fba50217c3fe3cbaad9e7f/95/meta.json`

محتوای URL (مستقیماً از بالا):

```json
{
   "name": "TON Smart Challenge #2 Winners Trophy",
   "description": "TON Smart Challenge #2 Winners Trophy 1 place out of 181",
   "image": "https://s.getgems.io/nft/b/c/62fba50217c3fe3cbaad9e7f/images/943e994f91227c3fdbccbc6d8635bfaab256fbb4",
   "content_url": "https://s.getgems.io/nft/b/c/62fba50217c3fe3cbaad9e7f/content/84f7f698b337de3bfd1bc4a8118cdfd8226bbadf",
   "attributes": []
}
```

### بر روی زنجیره و نیمه زنجیره

اگر رشته بایت متادیتا با `0x00` شروع شود، نشان‌دهنده این است که NFT از فرمت بر روی زنجیره یا نیمه زنجیره استفاده می‌کند.

اطلاعات متادیتای NFT ما در یک دیکشنری ذخیره می‌شود که کلید آن هش SHA256 از نام ویژگی و مقدار آن داده‌ای است که به صورت فرمت Snake یا Chunked ذخیره‌شده است.

برای تعیین نوع NFT استفاده‌شده، توسعه‌دهنده باید ویژگی‌های شناخته‌شده‌ی NFT مانند `uri`، `name`، `image`، `description` و `image_data` را بخواند. اگر فیلد `uri` در متادیتا موجود باشد، به معنای یک چیدمان نیمه‌زنجیره‌ای است. در چنین مواردی، محتوای بیرون از زنجیره مشخص‌شده در فیلد `uri` باید دانلود شده و با مقادیر دیکشنری تلفیق شود.

مثالی از یک NFT در زنجیره: [EQBq5z4N_GeJyBdvNh4tPjMpSkA08p8vWyiAX6LNbr3aLjI0](https://getgems.io/collection/EQAVGhk_3rUA3ypZAZ1SkVGZIaDt7UdvwA4jsSGRKRo-MRDN/EQBq5z4N_GeJyBdvNh4tPjMpSkA08p8vWyiAX6LNbr3aLjI0)

مثالی از یک NFT نیمه‌زنجیره‌ای: [EQB2NJFK0H5OxJTgyQbej0fy5zuicZAXk2vFZEDrqbQ_n5YW](https://getgems.io/nft/EQB2NJFK0H5OxJTgyQbej0fy5zuicZAXk2vFZEDrqbQ_n5YW)

نمونه‌ای از Master Jetton در زنجیره: [EQA4pCk0yK-JCwFD4Nl5ZE4pmlg4DkK-1Ou4HAUQ6RObZNMi](https://tonscan.org/jetton/EQA4pCk0yK-JCwFD4Nl5ZE4pmlg4DkK-1Ou4HAUQ6RObZNMi)

نمونه‌ای از یک تجزیه‌گر NFT زنجیره‌ای: [stackblitz/ton-onchain-nft-parser](https://stackblitz.com/edit/ton-onchain-nft-parser?file=src%2Fmain.ts)

## نکات مهم متادیتای NFT

1. برای نمایش NFT، فیلدهای `name`، `description` و `image` (یا `image_data`) در متادیتای NFT ضروری هستند.
2. برای متادیتای Jetton، فیلدهای `name`، `symbol`، `decimals` و `image` (یا `image_data`) از اولویت بالاتری برخوردارند.
3. مهم است که بدانید هر کسی می‌تواند با استفاده از هر `name`، `description`، یا `image`، یک NFT یا Jetton ایجاد کند. برای جلوگیری از سردرگمی و جلوگیری از کلاهبرداری بالقوه، کاربران باید همیشه NFTهای خود را به‌گونه‌ای نمایش دهند که به‌وضوح از سایر قسمت‌های اپلیکیشن آن‌ها متمایز باشد. NFTها و Jettonهای مخرب می‌توانند با اطلاعات گمراه‌کننده یا نادرست به کیف پول کاربر ارسال شوند.
4. برخی اقلام ممکن است دارای فیلد `video` باشند که به محتوای ویدیویی مرتبط با NFT یا Jetton لینک می‌دهد.

## منابع

- [پیشنهاد بهبود TON شماره ۶۴ (TEP-64)](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md)

## همچنین ببینید

- [پردازش NFTها در TON](/v3/guidelines/dapps/asset-processing/nft-processing/nfts)
- [پردازش Jettonها در TON](/v3/guidelines/dapps/asset-processing/jettons)
- [اولین Jetton خود را ضرب کنید](/v3/guidelines/dapps/tutorials/mint-your-first-token)