# Solidity در مقابل FunC

توسعه قراردادهای هوشمند شامل استفاده از زبان‌های از پیش تعریف شده مانند Solidity برای اتریوم و FunC برای TON می‌شود.
Solidity یک زبان شیء‌گرا، سطح بالا و دارای نوع‌سنجی سخت است که تحت تأثیر C++، پایتون و جاوا اسکریپت است و به طور خاص برای نوشتن قراردادهای هوشمندی طراحی شده است که در پلتفرم‌های بلاکچین اتریوم اجرا می‌شوند.

زبان FunC نیز یک زبان سطح بالا است که برای برنامه‌نویسی قراردادهای هوشمند در بلاکچین TON استفاده می‌شود و یک زبان خاص دامنه، شبیه به C و دارای نوع‌سنجی ایستا است.

در بخش‌های زیر به طور خلاصه به جنبه‌های زیر این زبان‌ها، یعنی انواع داده‌ها، ذخیره‌سازی، توابع، ساختارهای کنترل جریان و آرایه ها (هش‌مپ‌ها) پرداخته خواهد شد.

## قالب ذخیره‌سازی

Solidity یک مدل ذخیره‌سازی تخت ارائه می‌دهد، به این معنی که همه متغیرهای وضعیت در یک بلوک پیوسته از حافظه ذخیره می‌شوند. ذخیره‌ساز یک بانک کلید-مقدار است که در آن هر کلید یک عدد صحیح ۲۵۶ بیتی (۳۲ بایتی) است که شماره اسلات ذخیره‌سازی را نشان می‌دهد و هر مقدار ورودی ۲۵۶ بیتی ذخیره شده در آن اسلات است. اسلات‌ها به ترتیب از صفر شماره‌گذاری می‌شوند و هر اسلات می‌تواند یک مقدار را ذخیره کند. Solidity به برنامه‌نویس اجازه می‌دهد تا با استفاده از کلیدواژه `storage` طرح‌بندی ذخیره‌سازی را مشخص کند. ترتیبی که متغیرها تعریف می‌شوند، موقعیت آن‌ها در ذخیره‌سازی را تعیین می‌کند.

داده‌های ذخیره‌ساز دائمی در بلاکچین TON به عنوان یک سلول ذخیره می‌شوند. سلول‌ها نقش حافظه را در TVM مبتنی بر منبع بازی می‌کنند. یک سلول می‌تواند به یک برش تبدیل شود و سپس بیت‌های داده و مراجع به سلول‌های دیگر آن سلول می‌توانند با بارگیری از برش به دست آیند. بیت‌های داده و مراجع به سلول‌های دیگر می‌توانند در یک سازنده ذخیره شوند و سپس سازنده می‌تواند به یک سلول جدید نهایی شود.

## انواع داده‌ها

Solidity شامل انواع داده‌های اساسی زیر است:

- اعداد صحیح امضا شده/نشده
- بولین
- آدرس‌ها – برای ذخیره آدرس کیف پول یا قرارداد هوشمند اتریوم استفاده می‌شود، معمولاً حدود ۲۰ بایت. نوع آدرس می‌تواند با کلیدواژه "payable" مشخص شود که آن را محدود به ذخیره آدرس‌های کیف پول و استفاده از توابع انتقال و ارسال ارز می‌کند.
- آرایه‌های بایت – با کلیدواژه "bytes" اعلام می‌شوند، یک آرایه با اندازه ثابت است که برای ذخیره تعداد پیش‌فرض بایت تا ۳۲ استفاده می‌شود، معمولاً همراه با کلیدواژه اعلام می‌شود.
- لیترال‌ها – مقادیر ثابت مانند آدرس‌ها، نسبی‌ها و اعداد صحیح، رشته‌ها، یونیکد و اعداد هگزا، که می‌توانند در یک متغیر ذخیره شوند.
- شمارشی ها
- آرایه‌ها (ثابت/پویا)
- ساختارها
- نگاشت‌ها

در مورد FunC، انواع داده‌های اصلی عبارتند از:

- اعداد صحیح
- سلول – ساختار داده پایه برای TON، که با ظرفیت تا ۱۰۲۳ بیت و تا 4 مرجع به سلول‌های دیگر است
- برش و سازنده – اشیاء خاص برای خواندن و نوشتن در سلول‌ها،
- تداوم – نوع دیگری از سلول که حاوی کد بایت آماده برای اجرا در TVM است
- تاپل‌ها – یک مجموعه مرتب شده از حداکثر ۲۵۵ عنصر است که دارای انواع مقادیر دلخواه هستند و ممکن است متمایز باشند.
- تنسورها – یک مجموعه مرتب شده آماده برای تخصیص جرم مانند: `(int, int) a = (2, 4)`، یک مورد خاص از نوع تنسور نوع واحد () است. این نشان می‌دهد که یک تابع هیچ مقداری را باز نمی‌گرداند یا هیچ آرگومانی ندارد.

در حال حاضر، FunC از تعریف نوع‌های سفارشی پشتیبانی نمی‌کند.

### همچنین ببینید

- [دستورات](/v3/documentation/smart-contracts/func/docs/statements)

## تعریف و استفاده از متغیرها

نوع‌سنجی زبان Solidity ایستا است، به این معنی که نوع هر متغیر باید در زمان اعلام آن مشخص شود.

```js
uint test = 1; // Declaring an unsigned variable of integer type
bool isActive = true; // Logical variable
string name = "Alice"; // String variable
```

در سوی دیگر، FunC یک زبان انتزاعی‌تر و تابع‌گرا است، از نوع‌گذاری پویا و سبک برنامه‌نویسی تابعی پشتیبانی می‌کند.

```func
(int x, int y) = (1, 2); // A tuple containing two integer variables
var z = x + y; // Dynamic variable declaration 
```

### همچنین ببینید

- [دستورات](/v3/documentation/smart-contracts/func/docs/statements)

## حلقه‌ها

Solidity از حلقه‌های `for`، `while`، و `do { ... } while` پشتیبانی می‌کند.

اگر می‌خواهید چیزی را ۱۰ بار انجام دهید، می‌توانید این کار را این‌گونه انجام دهید:

```js
uint x = 1;

for (uint i; i < 10; i++) {
    x *= 2;
}

// x = 1024
```

FunC به نوبه خود از حلقه‌های `repeat`، `while`، و `do { ... } until` پشتیبانی می‌کند. حلقه for پشتیبانی نمی‌شود. اگر می‌خواهید کد مشابه مثال بالا را در FunC اجرا کنید، می‌توانید از `repeat` استفاده کنید

```func
int x = 1;
repeat(10) {
  x *= 2;
}
;; x = 1024
```

### همچنین ببینید

- [دستورات](/v3/documentation/smart-contracts/func/docs/statements)

## توابع

Solidity با ترکیبی از وضوح و کنترل به تعریف توابع نزدیک می‌شود. در این زبان برنامه‌نویسی، هر تابع با کلیدواژه `function` آغاز می‌شود و به دنبال آن نام تابع و پارامترهای آن قرار می‌گیرد. بدنه تابع در داخل آکولادها قرار دارد و به وضوح محدوده عملیاتی را تعریف می‌کند. علاوه بر این، مقادیر بازگشتی با استفاده از کلیدواژه `returns` نشان داده می‌شوند. چیزی که Solidity را متمایز می‌کند، دسته‌بندی دسترسی به توابع است - توابع می‌توانند به صورت `public`، `private`، `internal` یا `external` تعیین شوند، که شرایط دسترسی و فراخوانی آنها توسط قسمت‌های دیگر قرارداد یا نهادهای خارجی را تعیین می‌کند. در زیر یک مثال آورده شده است که در آن متغیر جهانی `num` را در زبان Solidity تنظیم می‌کنیم:

```js
function set(uint256 _num) public returns (bool) {
    num = _num;
    return true;
}
```

با انتقال به FunC، برنامه FunC اساساً یک لیست از اعلان/تعاریف توابع و اعلان متغیرهای جهانی است. اعلان تابع FunC به طور معمول با یک اعلامگر اختیاری آغاز می‌شود، به دنبال آن نوع بازگشتی و نام تابع قرار می‌گیرد. سپس پارامترها قرار میگیرند و اعلام با انتخابی از مشخص‌کننده‌ها به پایان می‌رسد - مانند `impure`، `inline/inline_ref` و `method_id`. این مشخص‌کننده‌ها دید تابع، توانایی آن برای تغییر ذخیره‌سازی قرارداد و رفتار درون‌خطی آن را تنظیم می‌کنند. در زیر یک مثال آورده شده است که در آن متغیر ذخیره‌سازی را به عنوان یک سلول به ذخیره‌سازی پایدار در زبان Func ذخیره می‌کنیم:

```func
() save_data(int num) impure inline {
  set_data(begin_cell()
            .store_uint(num, 32)
           .end_cell()
          );
}
```

### همچنین ببینید

- [توابع](/v3/documentation/smart-contracts/func/docs/functions)

## ساختارهای کنترل جریان

بیشتر ساختارهای کنترلی شناخته شده از زبان‌های آکولادی در Solidity موجود است، از جمله: `if`، `else`، `while`، `do`، `for`، `break`، `continue`، `return`، با معانی معمولی که از C یا جاوا اسکریپت شناخته شده‌اند.

FunC از اظهارات کلاسیک `if-else`، همچنین `ifnot`، حلقه‌های `repeat`، `while` و `do/until` پشتیبانی می‌کند. همچنین از نسخه v0.4.0 از عبارات `try-catch` پشتیبانی می‌شود.

### همچنین ببینید

- [دستورات](/v3/documentation/smart-contracts/func/docs/statements)

## آرایه ها

ساختار داده دیکشنری (هش‌مپ/نگاشت) برای توسعه قراردادهای Solidity و FunC بسیار مهم است، زیرا به توسعه‌دهندگان امکان می‌دهد داده‌ها را به‌طور کارآمد در قراردادهای هوشمند ذخیره و بازیابی کنند، به‌ویژه داده‌های مرتبط با یک کلید خاص، مانند تراز کاربر یا مالکیت یک دارایی.

نگاشت (mapping) یک جدول هش در Solidity است که داده‌ها را به عنوان جفت‌های کلید-مقدار ذخیره می‌کند، جایی که کلید می‌تواند هر یک از انواع داده‌های داخلی باشد، به جز انواع مرجع، و مقدار نوع داده می‌تواند هر نوعی باشد. نگاشت‌ها به‌طور معمول در Solidity و بلاکچین اتریوم برای اتصال یک آدرس اتریوم منحصر به فرد به یک نوع مقدار مربوطه استفاده می‌شوند. در هر زبان برنامه‌نویسی دیگر، یک نگاشت معادل با یک دیکشنری است.

در Solidity، نگاشت‌ها طول ندارند و مفهوم تنظیم یک کلید یا مقدار را ندارند. نگاشت‌ها فقط به متغیرهای حالت که به عنوان انواع مرجع ذخیره عمل می‌کنند، اعمال می‌شوند. هنگامی که نگاشت‌ها مقداردهی اولیه می‌شوند، هر کلید ممکن را شامل می‌شوند و به مقادیری نگاشت می‌شوند که نمایش بایتی آنها همه صفر است.

تشبیهی از نگاشت‌ها در FunC دیکشنری‌ها یا هش‌مپ‌های TON هستند. در زمینه TON، یک هش‌مپ یک ساختار داده است که توسط یک درخت سلول‌ها نمایش داده می‌شود. هش‌مپ کلیدها را به مقادیر نوع دلخواه نگاشت می‌دهد تا جستجو و تغییر سریع ممکن باشد. نمایش انتزاعی یک هش‌مپ در TVM یک درخت پاتریشیا یا دودویی فشرده است. کار با درخت‌های سلول بزرگ بالقوه می‌تواند چندین مشکل ایجاد کند. هر عملیات به‌روزرسانی تعداد قابل توجهی سلول می‌سازد (هر سلول ساخته شده ۵۰۰ گس هزینه دارد)، که به این معنی است که این عملیات‌ها در صورت استفاده نادرست می‌توانند منابع را تمام کنند. برای جلوگیری از تجاوز به حد گس، تعداد به‌روزرسانی‌های دیکشنری در یک تراکنش را محدود کنید. همچنین، یک درخت دودویی برای جفت‌های کلید-مقدار `N` دارای `N-1` انشعاب است، که به معنای حداقل  `2N-1` سلول است. ذخیره‌سازی یک قرارداد هوشمند به `65536` سلول منحصر به فرد محدود شده است، بنابراین حداکثر تعداد ورودی‌های دیکشنری `32768` است، یا کمی بیشتر اگر سلول‌ها تکراری باشند.

### همچنین ببینید

- [دیکشنری‌ها در TON](/v3/documentation/smart-contracts/func/docs/dictionaries)

## ارتباط قرارداد هوشمند

زبان های Solidity و FunC روش‌های مختلفی برای تعامل با قراردادهای هوشمند ارائه می‌دهند. تفاوت اصلی در مکانیزم‌های فراخوانی و تعامل بین قراردادها است.

Solidity از یک رویکرد شیءگرا استفاده می‌کند که در آن قراردادها از طریق فراخوانی متدها با یکدیگر تعامل دارند. این شبیه به فراخوانی متدها در زبان‌های برنامه‌نویسی شیءگرای سنتی است.

```js
// External contract interface
interface IReceiver {
    function receiveData(uint x) external;
}

contract Sender {
    function sendData(address receiverAddress, uint x) public {
        IReceiver receiver = IReceiver(receiverAddress);
        receiver.receiveData(x);  // Direct call of the contract function
    }
}
```

FunC، که در اکوسیستم بلاکچین TON استفاده می‌شود، با پیام‌ها برای فراخوانی و تعامل بین قراردادهای هوشمند عمل می‌کند. به جای فراخوانی مستقیم متدها، قراردادها پیام‌هایی به یکدیگر ارسال می‌کنند که می‌توانند حاوی داده‌ها و کد برای اجرا باشند.

یک مثال در نظر بگیرید که در آن یک قرارداد هوشمند فرستنده باید پیامی با یک عدد ارسال کند و یک قرارداد هوشمند گیرنده باید آن عدد را دریافت کرده و برخی دستکاری‌ها را بر روی آن انجام دهد.

ابتدا، قرارداد هوشمند گیرنده باید توضیح دهد که چگونه پیام‌ها را دریافت خواهد کرد.

```func
() recv_internal(int my_balance, int msg_value, cell in_msg, slice in_msg_body) impure {
    int op = in_msg_body~load_uint(32);
    
    if (op == 1) {
        int num = in_msg_body~load_uint(32);
        ;; do some manipulations
        return ();
    }

    if (op == 2) {
        ;;...
    }
}
```

بیایید جزئیات بیشتری در مورد دریافت یک پیام در قرارداد مقصد خود بررسی کنیم:

1. `recv_internal()` - این تابع زمانی اجرا می‌شود که یک قرارداد مستقیماً در داخل بلاکچین دسترسی پیدا کند. به عنوان مثال، هنگامی که یک قرارداد کیف به قرارداد ما دسترسی پیدا کند.
2. تابع مقدار موجودی قرارداد، مقدار پیام ورودی، سلول با پیام اصلی و برش `in_msg_body` را می‌پذیرد که فقط بدنه پیام دریافتی را ذخیره می‌کند.
3. بدنه پیام ما دو عدد صحیح ذخیره خواهد کرد. اولین عدد یک عدد صحیح 32 بیتی بدون علامت که حاوی `op` است و عملیات مورد نظر را برای اجرا یا متد قرارداد هوشمند مشخص می‌کند. شما می‌توانید نوعی تشبیه با Solidity ایجاد کنید و `op` را به عنوان امضای تابع در نظر بگیرید. عدد دوم عددی است که باید برخی دستکاری‌ها را روی آن انجام دهیم.
4. برای خواندن از برش نتیجه `op` و `num` از `load_uint()` استفاده می‌کنیم.
5. سپس عدد را دستکاری می‌کنیم (این قابلیت در این مثال حذف شده است).

بعد، قرارداد هوشمند فرستنده باید پیام را به درستی ارسال کند. این با استفاده از `send_raw_message` انجام می‌شود که یک پیام سریال شده را به عنوان یک آرگومان می‌پذیرد.

```func
int num = 10;
cell msg_body_cell = begin_cell().store_uint(1,32).store_uint(num,32).end_cell();

var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; in the example, we just hardcode the recipient's address
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body_cell)
        .end_cell();

send_raw_message(msg, mode);
```

بیایید جزئیات بیشتری در مورد ارسال پیام به گیرنده توسط قرارداد هوشمندمان بحث کنیم:

1. ابتدا باید پیام خود را بسازیم. ساختار کامل ارسال را می‌توانید [اینجا](/v3/documentation/smart-contracts/message-management/sending-messages) پیدا کنید. در اینجا به جزئیات نحوه ساخت آن نمی‌پردازیم، می‌توانید در لینک مطالعه کنید.
2. بدنه پیام نمایانگر یک سلول است. در `msg_body_cell` ما این کار را انجام می‌دهیم: `begin_cell()` - یک `Builder` برای سلول آینده ایجاد می‌کند، اولین `store_uint` - اولین uint را در `Builder` ذخیره می‌کند (مقدار 1 که همان `op` ماست)، دومین `store_uint` - دومین uint را در `Builder` ذخیره می‌کند (num - این همان عددی است که در قرارداد گیرنده با آن دستکاری خواهیم کرد)، `end_cell()` - سلول را ایجاد می‌کند.
3. برای پیوست بدنه‌ای که در `recv_internal` پیام می‌آید، ما سلول جمع‌آوری شده را در خود پیام با `store_ref` ارجاع می‌دهیم.
4. ارسال پیام.

این مثال نشان داد که چگونه قراردادهای هوشمند می‌توانند با یکدیگر ارتباط برقرار کنند.

### همچنین ببینید

- [پیام‌های داخلی](/v3/documentation/smart-contracts/message-management/internal-messages)
- [ارسال پیام‌ها](/v3/documentation/smart-contracts/message-management/sending-messages)
- [پیام‌های غیر بازگشتی](/v3/documentation/smart-contracts/message-management/non-bounceable-messages)
