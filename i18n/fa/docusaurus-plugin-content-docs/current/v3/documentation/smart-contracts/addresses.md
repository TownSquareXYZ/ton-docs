import Feedback from '@site/src/components/Feedback';

# Smart contract addresses

این بخش مشخصات آدرس‌های قرارداد هوشمند در بلاکچین TON را توصیف می‌کند. همچنین توضیح می‌دهد چگونه بازیگران با قراردادهای هوشمند در TON مترادف هستند.

## Everything is a smart contract

در TON، قراردادهای هوشمند با استفاده از [مدل بازیگری](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#single-actor) ساخته می‌شوند. در واقع، بازیگران در TON به صورت تکنیکی به شکل قراردادهای هوشمند نمایان می‌شوند. این بدان معنی است که حتی کیف پول شما نیز یک بازیگر ساده (و یک قرارداد هوشمند) است.

به‌طور کلی، بازیگران پیام‌های ورودی را پردازش می‌کنند، وضعیت داخلی خود را تغییر می‌دهند و پیام‌های خروجی تولید می‌کنند. به همین دلیل است که هر بازیگر (یعنی قرارداد هوشمند) در بلاکچین TON باید یک آدرس داشته باشد تا بتواند پیام‌ها را از دیگر بازیگران دریافت کند.

:::info تجربه EVM
On the Ethereum Virtual Machine (EVM), addresses are completely separate from smart contracts. Feel free to learn more about the differences by reading our article ["Six unique aspects of TON Blockchain that will surprise Solidity developers"](https://blog.ton.org/six-unique-aspects-of-ton-blockchain-that-will-surprise-solidity-developers) - *Tal Kol*.
:::

## Address of smart contract

آدرس‌های قرارداد هوشمند در TON شامل دو جزء اصلی هستند:

- **(workchain_id)**: نشان‌دهندهٔ ID کار پوشه (یک عدد صحیح ۳۲ بیتی امضا شده)

- **(account_id)** آدرس حساب را نشان می‌دهد (۶۴-۵۱۲ بیت، بسته به کار پوشه)

در بخش مرور آدرس خام این مستندات، بحث خواهیم کرد که جفت‌های **(workchain_id, account_id)** چگونه ارائه می‌شوند.

### WorkChain ID and Account ID

#### شناسه کار پوشه

[همان‌طور که قبلاً دیده‌ایم](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#workchain-blockchain-with-your-own-rules)، ممکن است به تعداد `2^32` کار پوشه در بلاکچین TON ایجاد شود. ما همچنین مشاهده کردیم که آدرس‌های قرارداد هوشمند با پیشوند ۳۲ بیتی شناخته شده و به آدرس‌های قرارداد هوشمند در کار پوشه‌های مختلف مرتبط می‌شوند. این امکان را برای قراردادهای هوشمند فراهم می‌سازد تا پیام‌ها را به کار پوشه‌های مختلف در بلاکچین TON بفرستند و دریافت کنند.

امروزه تنها مسترچین (workchain_id=-1) و گاهی اوقات کار پوشه پایه (workchain_id=0) در بلاکچین TON در حال اجرا هستند.

هر دوی آن‌ها دارای آدرس‌های ۲۵۶ بیتی هستند، بنابراین فرض می‌کنیم که workchain_id برابر با ۰ یا -۱ باشد و آدرس در کار پوشه دقیقاً ۲۵۶ بیت است.

#### شناسه حساب

All account IDs on TON use 256-bit addresses on the Masterchain and Basechain (also referred to as the basic workchain).

In fact, an Account ID (**account_id**) is defined as the result of applying a hash function (specifically SHA-256) to a smart contract object. Every smart contract operating on the TON Blockchain stores two main components:

1. *Compiled code*. The logic of the smart contract, compiled into bytecode.
2. *Initial state*. The contract's values at the moment it is deployed on-chain.

To derive the contract's address, you calculate the hash of the **(Initial code, Initial state)** pair. We won’t explore how the [TVM](/v3/documentation/tvm/tvm-overview) works at this time, but it is important to understand that account IDs on TON follow this formula:

**account_id = hash(initial code, initial state)**

Later in this documentation, we will dive deeper into the technical specifications of the TVM and TL-B scheme. Now that we are familiar with how the **account_id** is generated and how it interacts with smart contract addresses on TON, let’s discuss Raw and User-Friendly addresses.

## وضعیت‌های آدرس

هر آدرس می‌تواند در یکی از وضعیت‌های ممکن باشد:

- `nonexist` - در این آدرس هیچ تراکنش پذیرفته نشده است، بنابراین هیچ داده‌ای ندارد (یا قرارداد حذف شده است). می‌توان گفت که تمامی ۲<sup>۲۵۶</sup> آدرس در این وضعیت هستند.
- `uninit` - آدرس دارای مقداری داده است که شامل موجودی و اطلاعات متا است. در این وضعیت آدرس هنوز هیچ کدی برای قرارداد هوشمند/داده دائم ندارد. به عنوان مثال، وقتی یک آدرس در وضعیت nonexist بود و آدرس دیگری به آن توکن‌ها ارسال کرد، به این وضعیت وارد می‌شود.
- `active` - آدرس حاوی کد قرارداد هوشمند، داده دائم و موجودی است. در این وضعیت می‌تواند در طی تراکنش منطق خاصی را اجرا کند و داده دائم خود را تغییر دهد. یک آدرس زمانی به این وضعیت وارد می‌شود که `uninit` باشد و پیام ورودی با پارامتر state_init داشته باشد (توجه داشته باشید که برای اینکه بتوانید این آدرس را استقرار دهید، هش `state_init` و `code` باید با آدرس برابر باشد).
- `frozen` - آدرس نمی‌تواند هیچ عملیاتی انجام دهد، این وضعیت فقط شامل دو هش از حالت قبلی (سلول‌های کد و وضعیت به ترتیب) است. وقتی هزینه ذخیره‌سازی آدرس بیش از موجودی آن شود، به این وضعیت می‌افتد. برای رفع یخ‌زدگی، می‌توانید یک پیام داخلی با `state_init` و `code` که هش‌های توضیح داده شده را ذخیره می‌کند و مقداری Toncoin ارسال کنید. بازیابی آن ممکن است دشوار باشد، بنابراین نباید اجازه دهید این وضعیت رخ دهد. پروژه‌ای برای رفع یخ‌زدگی آدرس وجود دارد که می‌توانید [اینجا](https://unfreezer.ton.org/) پیدا کنید.

## Raw and user-friendly addresses

پس از ارائه یک نمای کلی از نحوه استفاده آدرس‌های قرارداد هوشمند در TON از شناسه‌های کار پوشه و حساب (به طور خاص برای مسترچین و بیسچین)، درک این که این آدرس‌ها در دو قالب اصلی بیان می‌شوند مهم است:

- **آدرس‌های خام**: نمایه کامل اصلی از آدرس‌های قرارداد هوشمند.
- **آدرس‌های کاربر پسند**: آدرس‌های کاربر پسند، یک قالب بهبود یافته از آدرس خام هستند که امنیت و سهولت استفاده بهتری دارند.

در زیر، بیشتر در مورد تفاوت‌های بین این دو نوع آدرس توضیح خواهیم داد و بیشتر به این موضوع می‌پردازیم که چرا آدرس‌های کاربر پسند در TON استفاده می‌شوند.

### آدرس خام

آدرس‌های خام قرارداد هوشمند از یک شناسه کار پوشه و شناسه حساب *(workchain_id, account_id)* تشکیل شده و به شکل زیر نمایش داده می‌شود:

- [workchain_id دهدهی\]:[۶۴ رقم شانزده‌شانزدهی با account_id\]

در زیر مثالی از آدرس خام قرارداد هوشمند که از شناسه کار پوشه و شناسه حساب به‌طور همزمان استفاده می‌کند (با عنوان **workchain_id** و **account_id** بیان شده) ارائه شده است:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

توجه کنید به `-1` در ابتدای رشته آدرس، که نشان‌دهنده‌ی *workchain_id* متعلق به مسترچین است.

:::note
حروف بزرگ (مانند 'A'، 'B'، 'C'، 'D' و غیره) ممکن است در رشته‌های آدرس به جای همتایان کوچک‌حروفشان (مانند 'a'، 'b'، 'c'، 'd' و غیره) استفاده شوند.
:::

#### Issues with raw addresses

استفاده از فرم آدرس خام دو مشکل اصلی ایجاد می‌کند:

1. هنگام استفاده از قالب آدرس خام، نمی‌توان آدرس‌ها را قبل از ارسال تراکنش تأیید کرد تا خطاها را حذف کرد.
   این بدان معناست که اگر قبل از ارسال تراکنش، به طور تصادفی کاراکترهایی در رشته آدرس اضافه یا حذف کنید، تراکنش شما به مقصد اشتباه ارسال می‌شود و باعث از دست رفتن وجوه می‌شود.
2. هنگام استفاده از قالب آدرس خام، نمی‌توان نشانگر‌های خاصی مانند آن‌هایی که هنگام ارسال تراکنش‌های کاربر پسند استفاده می‌شوند، اضافه کرد.
   برای کمک به شما در درک بهتر این مفهوم، ما توضیح می‌دهیم که چه نشانگر‌هایی می‌توانند استفاده شوند.

### User-friendly address

آدرس‌های کاربر پسند برای ایمن‌سازی و ساده‌سازی تجربه کاربران TON که آدرس‌ها را در اینترنت (برای مثال، بر روی پلتفرم‌های پیام‌رسان عمومی یا از طریق ارائه‌دهندگان خدمات ایمیل) و همین‌طور در دنیای واقعی به اشتراک می‌گذارند، توسعه داده شده‌اند.

#### User-friendly address structure

آدرس‌های کاربر پسند در مجموع از ۳۶ بایت تشکیل شده‌اند و با تولید مؤلفه‌های زیر به ترتیب به دست می‌آیند:

1. *[نشانگر‌ها - ۱ بایت]* — نشانگر‌هایی که به آدرس‌ها الصاق شده‌اند، نحوه واکنش قراردادهای هوشمند به پیام دریافتی را تغییر می‌دهند.
   انواع نشانگر‌هایی که از قالب آدرس کاربر پسند استفاده می‌کنند عبارتند از:

   - isBounceable. نوع آدرس قابل برگشت یا غیرقابل برگشت را نشان می‌دهد. (*0x11* برای "قابل برگشت"، *0x51* برای "غیرقابل برگشت")
   - isTestnetOnly. نوع آدرسی را نشان می‌دهد که فقط برای اهداف شبکه آزمایشی استفاده می‌شود. آدرس‌هایی که با *0x80* شروع می‌شوند نباید توسط نرم‌افزار در حال اجرا بر روی شبکه تولید استفاده شوند
   - isUrlSafe. نشانگر‌ای را نشان می‌دهد که تعریف شده است به عنوان ایمن برای آدرس. همه آدرس‌ها پس از آن ایمن برای URL درنظر گرفته می‌شوند.
2. *\[شناسه کارchain - ۱ بایت]* — شناسه کارchain (*workchain_id*) با یک عدد صحیح ۸ بیتی امضا شده *workchain_id* تعریف می‌شود.\
   (*0x00* برای BaseChain، *0xff* برای MasterChain)
3. *\[شناسه حساب - ۳۲ بایت]* — شناسه حساب از یک آدرس ۲۵۶ بیتی ([بزرگ-اندی در](https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/)) در کارchain ساخته شده است.
4. *\[تأیید آدرس - ۲ بایت]* — در آدرس‌های کاربر پسند، تأیید آدرس از امضای CRC16-CCITT از ۳۴ بایت قبلی تشکیل شده است. ([مثال](https://github.com/andreypfau/ton-kotlin/blob/ce9595ec9e2ad0eb311351c8a270ef1bd2f4363e/ton-kotlin-crypto/common/src/crc32.kt))
   در واقع، ایده مربوط به تأیید آدرس کاربر پسند بسیار شبیه به [الگوریتم Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) است که در تمام کارت‌های اعتباری استفاده می‌شود تا از ورود کاربران به شماره‌های کارتی که وجود ندارد جلوگیری کند.

اضافه شدن این ۴ مؤلفه اصلی بدین معناست که: `1 + 1 + 32 + 2 = 36` بایت در مجموع (برای هر آدرس کاربر پسند)

برای تولید یک آدرس کاربر پسند، توسعه‌دهنده باید همه ۳۶ بایت را با استفاده از یکی از موارد زیر کدگذاری کند:

- *base64* (یعنی، شامل اعداد، حروف لاتین بزرگ و کوچک، '/' و '+')
- *base64url* (با '_' و '-' به جای '/' و '+')

پس از اتمام این فرآیند، تولید آدرس کاربر پسند با طول ۴۸ کاراکتر بدون فاصله کامل می‌شود.

:::info نشانگر‌های آدرس DNS
در TON، گاهی اوقات از آدرس‌های DNS مانند mywallet.ton به جای آدرس‌های خام و کاربر پسند استفاده می‌شود.آدرس‌های DNS از آدرس‌های کاربر پسند تشکیل شده‌اند و شامل تمام نشانگر‌های ضروری هستند که به توسعه‌دهندگان اجازه می‌دهند به تمام نشانگر‌های رکورد DNS در دامنه TON دسترسی داشته باشند.
:::

#### User-friendly address encoding examples

برای مثال، قرارداد هوشمند "test giver" (یک قرارداد هوشمند ویژه که در زنجیره اصلی شبکه آزمایشی مستقر است و ۲ توکن آزمایشی را به هر کسی که درخواست کند ارسال می‌کند) از آدرس خام زیر استفاده می‌کند:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

آدرس خام "test giver" فوق باید به فرم آدرس کاربرپسند تبدیل شود. این با استفاده از فرم‌های base64 یا base64url (که قبلاً معرفی کردیم) به دست می‌آید به شرح زیر:

- `kf/8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15+KsQHFLbKSMiYIny` (base64)
- `kf_8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15-KsQHFLbKSMiYIny` (base64url)

:::info
توجه داشته باشید که هر دو فرم (*base64* و *base64url*) معتبر هستند و باید پذیرفته شوند!
:::

#### Bounceable vs non-bounceable addresses

ایده اصلی پشت نشانگر آدرس قابل برگشت، امنیت وجوه ارسال کننده است.

برای مثال، اگر قرارداد هوشمند مقصد وجود نداشته باشد یا در حالی که تراکنش در حال انجام است مشکل رخ دهد، پیام به فرستنده "برگشت" خواهد شد و تشکیل دهنده باقی‌مانده ارزش اصلی تراکنش خواهد بود (منفی تمام هزینه‌های انتقال و گاز).
در رابطه با آدرس‌های قابل برگشت به طور خاص:

1. نشانگر **bounceable=false** به طور کلی به این معنا است که گیرنده یک کیف پول است.
2. نشانگر **bounceable=true** معمولاً نشان‌دهنده یک قرارداد هوشمند سفارشی با منطق کاربردی خود است (برای مثال، یک DEX). در این مثال، پیام‌های غیرقابل برگشت به دلیل امنیتی نباید ارسال شوند.

برای درک بهتر، می‌توانید اطلاعات بیشتری درباره این موضوع را در مستندات ما بخوانید تا [پیام‌های غیرقابل برگشت](/v3/documentation/smart-contracts/message-management/non-bounceable-messages) را بهتر بشناسید.

#### Armored base64 representations

داده‌های باینری اضافی مرتبط با بلاکچین TON از نمایش‌های آدرس کاربرپسند base64 مشابه "محکم" استفاده می‌کند. این‌ها با توجه به ۴ کاراکتر اول برچسب بایتی از یکدیگر متمایز می‌شوند. برای مثال، کلیدهای عمومی ۲۵۶ بیتی Ed25519 با ایجاد یک رشته ۳۶ بایت با استفاده از فرآیند زیر به ترتیب ارائه می‌شوند:

- یک برچسب بایت واحد با استفاده از فرمت *0x3E* یک کلید عمومی را نشان می‌دهد
- یک برچسب بایت واحد با استفاده از فرمت *0xE6* یک کلید عمومی Ed25519 را نشان می‌دهد
- ۳۲ byte شامل نمایش دودویی استاندارد کلید عمومی Ed25519
- ۲ byte شامل نمایش big-endian از CRC16-CCITT از ۳۴ byte قبلی

توالی ۳۶ byte به دست آمده به طور استاندارد به یک رشته base64 یا base64url با ۴۸ کاراکتر تبدیل می‌شود. به عنوان مثال، کلید عمومی Ed25519 `E39ECDA0A7B0C60A7107EC43967829DBE8BC356A49B9DFC6186B3EAC74B5477D` (که معمولاً با توالی ۳۲ بایت مانند: `0xE3، 0x9E، ...، 0x7D` نمایش داده می‌شود) از طریق نمایش "armored" به صورت زیر ارائه می‌شود:

`Pubjns2gp7DGCnEH7EOWeCnb6Lw1akm538YYaz6sdLVHfRB2`

### Converting user-friendly addresses and raw addresses

ساده‌ترین راه برای تبدیل آدرس‌های کاربرپسند و خام، استفاده از یکی از چندین API TON و ابزارهای دیگر از جمله:

- [ton.org/address](https://ton.org/address)
- [روش API dton.io](https://dton.io/api/address/0:867ac2b47d1955de6c8e23f57994fad507ea3bcfe2a7d76ff38f29ec46729627)
- [روش‌های API toncenter در mainnet](https://toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)
- [روش‌های API toncenter در testnet](https://testnet.toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)

علاوه بر این، دو روش برای تبدیل آدرس‌های کاربرپسند و خام برای کیف پول‌ها با استفاده از JavaScript وجود دارد:

- [تبدیل آدرس از/به فرم کاربرپسند یا خام با استفاده از ton.js](https://github.com/ton-org/ton-core/blob/main/src/address/Address.spec.ts)
- [تبدیل آدرس از/به فرم کاربرپسند یا خام با استفاده از tonweb](https://github.com/toncenter/tonweb/tree/master/src/utils#address-class)

همچنین، می‌توان از مکانیزم‌های مشابه با استفاده از [SDKها](/v3/guidelines/dapps/apis-sdks/sdk) استفاده کرد.

### Address examples

برای نمونه‌های بیشتر درباره آدرس‌های TON، به [TON Cookbook](/v3/guidelines/dapps/cookbook#working-with-contracts-addresses) مراجعه کنید.

## مشکلات ممکن

هنگام تعامل با بلاک‌چین ton، مهم است که پیامدهای انتقال سکه‌های ton به آدرس‌های کیف پول 'uninit' را درک کنید. این بخش، سناریوهای مختلف و نتایج آن‌ها را جهت ارائه روشنی بر نحوه مدیریت چنین تراکنش‌هایی تبیین می‌کند.

### وقتی که Toncoin را به یک آدرس uninit انتقال می‌دهید چه اتفاقی می‌افتد؟

#### تراکنش با `state_init` شامل شده

اگر `state_init` (که شامل کد و داده‌های کیف پول یا قرارداد هوشمند است) را با تراکنش خود وارد کنید. قرارداد هوشمند ابتدا با استفاده از `state_init` ارائه شده مستقر می‌شود. پس از استقرار، پیام ورودی پردازش می‌شود، مشابه ارسال به یک حساب از پیش موجود.

#### تراکنش بدون مشخص کردن `state_init` و تنظیم نشانگر `bounce`

پیام نمی‌تواند به قرارداد هوشمند `uninit` تحویل شود و به فرستنده بازگردانده می‌شود. پس از کسر هزینه‌های گاز مصرفی، مبلغ باقیمانده به نشانی فرستنده بازگردانده می‌شود.

#### تراکنش بدون مشخص کردن `state_init` و مشخص نکردن نشانگر `bounce`

پیام نمی‌تواند تحویل شود، اما به فرستنده برگشت نخواهد خورد. در عوض، مبلغ ارسال شده به حساب آدرس دریافت‌کننده واریز می‌شود، که باعث افزایش موجودی آن می‌شود حتی اگر کیف پول هنوز به حالت اولیه درنیامده باشد. آن‌ها در آنجا نگهداری خواهند شد تا زمانی که دارنده آدرس یک قرارداد کیف پول هوشمند را مستقر کند و سپس به موجودی دسترسی پیدا می‌کند.

#### چگونه آن را به درستی انجام دهیم

بهترین راه برای مستقر کردن یک کیف پول این است که TON به نشانی آن (که هنوز به حالت اولیه در نیامده) ارسال کنید و نشانگر `bounce` را پاک کنید. پس از این مرحله، مالک می‌تواند کیف پول را با استفاده از وجوه در نشانی فعلی غیرمبادله شده مستقر و به حالت اولیه درآورد. این مرحله معمولاً در اولین عملیات کیف پول رخ می‌دهد.

### بلاک‌چین ton حفاظت در برابر تراکنش‌های اشتباه را پیاده‌سازی می‌کند

در بلاک‌چین ton، کیف پول‌ها و برنامه‌های استاندارد به‌طور خودکار پیچیدگی‌های تراکنش‌ها به آدرس‌های غیرانشعابی را با استفاده از آدرس‌های قابل انشعاب و غیرقابل انشعاب، که در [اینجا](#bounceable-vs-non-bounceable-addresses) توضیح داده شده‌اند، مدیریت می‌کنند. این مرسوم است که کیف پول‌ها هنگام ارسال سکه‌ها به آدرس‌های غیرانشعابی، سکه‌ها را به هر دوی آدرس‌های قابل انشعاب و غیرقابل انشعاب بدون بازگشت ارسال می‌کنند.

اگر نیاز به گرفتن سریع یک آدرس در فرم قابل انشعاب/غیرقابل انشعاب دارید، این کار را می‌توانید [اینجا](https://ton.org/address/) انجام دهید.

### مسئولیت محصولات سفارشی

اگر شما یک محصول سفارشی در بلاک‌چین ton توسعه می‌دهید، لازم است که چک‌ها و منطق مشابهی را پیاده‌سازی کنید:

اطمینان حاصل کنید که برنامه شما بررسی می‌کند که آیا نشانی دریافت‌کننده اولیه شده است یا خیر قبل از ارسال وجوه.
براساس وضعیت آدرس، برای قراردادهای هوشمند کاربران با منطق برنامه سفارشی از آدرس‌های قابل انشعاب استفاده کنید تا اطمینان حاصل کنید وجوه بازگردانده می‌شوند. برای کیف پول‌ها از آدرس‌های غیرقابل انشعاب استفاده کنید.

<Feedback />

