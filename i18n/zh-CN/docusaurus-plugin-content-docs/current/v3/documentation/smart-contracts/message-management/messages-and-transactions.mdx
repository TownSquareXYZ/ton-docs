import Feedback from '@site/src/components/Feedback';

import ConceptImage from "@site/src/components/conceptImage";
import ThemedImage from "@theme/ThemedImage";

# Messages and transactions

TON is an asynchronous blockchain with a complex structure that is very different from other blockchains. Because of this, new developers often have questions about low-level things in TON. In this article, we will examine one such question related to message delivery.

## 什么是消息？

消息是在actor（用户、应用程序、智能合约）之间发送的数据包。它通常包含指导接收方执行某种操作的信息，如更新存储或发送新消息。

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Message diagram"
    sources={{
      light: "/img/docs/message-delivery/message_delivery_1.png?raw=true",
      dark: "/img/docs/message-delivery/message_delivery_1_dark.png?raw=true",
    }}
  />
</div>
<br></br>

这种通信方式让人想起将卫星发射到太空。我们知道我们构成的消息，但在发射后，需要进行单独的观察来找出我们将获得什么结果。

## What is a transaction?

TON 中的一笔交易包括以下内容：

- The incoming message that initially triggers the contract (special ways to trigger exist)
- Contract actions caused by the incoming message, such as an update to the contract's storage (optional)
- Outgoing messages generated and sent to other actors (optional)

> Technically, a contract can be triggered through special functions such as [Tick-Tock](/v3/documentation/data-formats/tlb/transaction-layout#tick-tock). Still, this function is more used for internal TON Blockchain core contracts.
>
> Not every transaction results in outgoing messages or updates to the contract's storage - this depends on the actions defined by the contract's code.# Messages and transactions

TON is an asynchronous blockchain with a complex structure that is very different from other blockchains. Because of this, new developers often have questions about low-level things in TON. In this article, we will examine one such question related to message delivery.

## What is a message?

A message is a packet of data exchanged between actors (users, applications, or smart contracts). It typically contains information instructing the receiver on what action to perform, such as updating storage or sending a new message.

<br></br>
<ThemedImage
  alt="Transaction diagram"
  sources={{
    light: "/img/docs/message-delivery/message_delivery_2.png?raw=true",
    dark: "/img/docs/message-delivery/message_delivery_2_dark.png?raw=true",
  }}
/>
<br></br>

If we look at Ethereum or almost any other synchronous blockchain, each transaction can contain several smart contract calls. For example, DEXs perform multiple exchanges in one transaction if there is no liquidity for the selected trading pair.

In an asynchronous system, you can't get a response from the destination smart contract in the same transaction. Depending on the length of the route between source and destination, a contract call may take a few blocks to process.

Achieving the infinite sharding paradigm requires full parallelization, ensuring that each transaction executes independently of others. Therefore, instead of transactions that affect and change the state of many contracts simultaneously, each transaction in TON is only executed on a single smart contract, and smart contracts communicate through messages. That way, smart contracts can only interact with each other by calling their functions with special messages and getting a response to them via other messages later.

:::info
See [transaction layout](/v3/documentation/data-formats/tlb/transaction-layout) for complete transaction details.
:::

### 交易结果

There is a [TVM exit code](/v3/documentation/tvm/tvm-exit-codes) for a transaction that had a compute phase. If it is not 0 or 1, then there was an error.
Also, TVM [compute phase may be skipped](/v3/documentation/tvm/tvm-overview#compute-phase-skipped) for reasons like lack of funds or state.

:::info 用于 toncenter api v3
One should use `tx.description.action` to determine a successful `transaction.success  && tx.description.compute_ph.success`:
:::

```json
"transactions": [
    {
      "description": {
        . . . . . . . .
        "action": {
          "valid": true,
          "success": true,
         . . . . . . . .
          },
. . . . . . . .
        "destroyed": false,
        "compute_ph": {
          "mode": 0,
          "type": "vm",
          "success": true,
```

The transaction may have one of three results:

- 成功，退出代码为 0 或 1
- 失败，`aborted: true` 未执行
- Fail， [exit code](/v3/documentation/tvm/tvm-exit-codes), `aborted: true`.

:::info 用于 toncenter api v3
`aborted: true` is a TON Center field. Transaction has no such field.
:::

## What is a logical time?

In a system with asynchronous and parallel smart contract calls, it can be hard to define the order of actions to process. That's why each message in TON has its _Logical time_ or _Lamport time_ (later just _lt_). This time is used to understand which event caused another and what a validator needs to process first.

It is strictly guaranteed that the transaction resulting from a message will have a _lt_ greater than the _lt_ of the message. Likewise, the _lt_ of a message sent in some transaction is strictly greater than the _lt_ of the transaction that caused it. In addition, messages sent from one account and transactions on one account are strictly ordered.

<br></br>
<ThemedImage
  alt="Logical time sequence"
  sources={{
    light: "/img/docs/message-delivery/message_delivery_3.png?raw=true",
    dark: "/img/docs/message-delivery/message_delivery_3_dark.png?raw=true",
  }}
/>
<br></br>

此外，如果账户 _A_ 向账户 _B_ 发送了两条消息，可以保证具有较低 _lt_ 的消息将被更早处理：

Thanks to this, we always know the order of transactions, received messages and sent messages for every account.

Moreover, if account _A_ sends two messages to account _B_, it is guaranteed that the message with a lower _lt_ will be processed earlier:

假设有两个合约 - _A_ 和 _B_。_A_ 收到一个外部消息，触发它向 _B_ 发送两个内部消息，我们称这些消息为 _1_ 和 _2_。在这个简单的情况下，我们可以 100% 确定 _1_ 将在 _2_ 之前被 _B_ 处理，因为它具有较低的 _lt_。

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Message order guarantee"
    sources={{
      light: "/img/docs/message-delivery/message_delivery_5.png?raw=true",
      dark: "/img/docs/message-delivery/message_delivery_5_dark.png?raw=true",
    }}
  />
</div>
<br></br>

Otherwise, an attempt to synchronize delivery would require knowing the state of all the others before processing one shard, thereby breaking parallelization and destroying efficient sharding.

For each block, we can define the _lt_ span as starting from the first transaction and ending with the _lt_ of the last event in the block (message or transaction). Blocks are ordered like other events in TON, so if one block depends on the other, it has a higher _lt_. The child block in a shard has a higher _lt_ than its parent. A masterchain block's _lt_ is higher than the _lts_ of shard blocks that it lists since a master block depends on listed shard blocks. Each shard block contains an ordered reference to the latest (at the moment of shard block creation) master block, and thus, the shard block _lt_ is higher than the referenced master block _lt_.

## 消息传递

TON guarantees reliable delivery of all internal messages - the destination account will always receive them. The network ensures messages cannot be lost between sender and recipient during transit.
Validators control external messages' initial acceptance into blocks. However, once an external message enters the incoming message queue, it receives the same delivery guarantee as internal messages.

### Delivery order

Therefore, it seems like _lt_ solves the issue about message delivery order because we know that a transaction with a lower _lt_ will be processed first. But this doesn't work in every scenario.

Suppose there are two contracts - _A_ and _B_. _A_ receives an external message, which triggers it to send two internal messages to _B_. Let's call these messages _1_ and _2_. In this simple case, we can be 100% sure that _1_ will be processed by _B_ before _2_ because it has a lower _lt_.

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Simple message order"
    sources={{
      light: "/img/docs/message-delivery/msg-delivery-1.png?raw=true",
      dark: "/img/docs/message-delivery/msg-delivery-1-dark.png?raw=true",
    }}
  />
</div>
<br></br>

But this is just a simple case when we have only two contracts. How does our system work in more complex cases?

### Several smart contracts

Consider three contracts - _A_, _B_, and _C_. When contract _A_ sends two internal messages (_1_ to _B_ and _2_ to _C_) in a single transaction, the messages are created in strict order (_1_ first, then _2_). However, their processing order at the destinations isn't guaranteed because:

1. **Network paths may differ**: The routes to _B_ and _C_ might involve different validator sets
2. **Shard chain effects**: If _B_ and _C_ are in separate shard chains, messages may traverse different numbers of blocks
3. **Asynchronous processing**: Each shard chain progresses independently, potentially causing delivery timing variations

While the sending order is preserved at the source, TON's decentralized sharded architecture means the receiving order can't be predetermined.

For better clarity, suppose our contracts send back messages `msg1'` and `msg2'` after `msg1` and `msg2` executed by `B` and `C` contracts. As a result, it will apply `tx2'` and `tx1'` to contract `A`.
We have two possible traces for these transactions,

1. 第一种可能的顺序是 `tx1'_lt < tx2'_lt`：

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Complex message order 1"
    sources={{
      light: "/img/docs/message-delivery/message_delivery_6.png?raw=true",
      dark: "/img/docs/message-delivery/message_delivery_6_dark.png?raw=true",
    }}
  />
</div>
<br></br>

2. 第二种可能的顺序是 `tx2'_lt < tx1'_lt`：

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Complex message order 2"
    sources={{
      light: "/img/docs/message-delivery/message_delivery_7.png?raw=true",
      dark: "/img/docs/message-delivery/message_delivery_7_dark.png?raw=true",
    }}
  />
</div>
<br></br>

The same happens in the reverse case, when two contracts, _B_ and _C_, send a message to one contract, _A_. Even if message `B -> A` was sent before `C -> A`, we can't know which one will be delivered first. The `B -> A` route may require more shard chain hops.

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Reverse message flow"
    sources={{
      light: "/img/docs/message-delivery/msg-delivery-3.png?raw=true",
      dark: "/img/docs/message-delivery/msg-delivery-3_dark.png?raw=true",
    }}
  />
</div>
<br></br>

There can be many scenarios of smart contract interactions, and in any scenario with more than 2 contracts, the order of message delivery may be arbitrary. The only guarantee is that messages from contract _A_ to contract _B_ will be processed in order of their logical time. Some examples are below.

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Multi-contract scenario 1"
    sources={{
      light: "/img/docs/message-delivery/msg-delivery-4.png?raw=true",
      dark: "/img/docs/message-delivery/msg-delivery-4_dark.png?raw=true",
    }}
  />
</div>
<br></br>

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Multi-contract scenario 2"
    sources={{
      light: "/img/docs/message-delivery/msg-delivery-5.png?raw=true",
      dark: "/img/docs/message-delivery/msg-delivery-5_dark.png?raw=true",
    }}
  />
</div>
<br></br>

<br></br>
<div class="text--center">
  <ThemedImage
    alt="Multi-contract scenario 3"
    sources={{
      light: "/img/docs/message-delivery/msg-delivery-6.png?raw=true",
      dark: "/img/docs/message-delivery/msg-delivery-6-dark.png?raw=true",
    }}
  />
</div>
<br></br>

## 结论

TON 区块链的异步结构为消息传递保证带来挑战。逻辑时间有助于确定事件和交易顺序，但由于分片链中的路由不同，它并不能保证多个智能合约之间的消息传递顺序。尽管存在这些复杂性，TON 仍然能够确保内部消息的传递，维护网络的可靠性。开发人员必须适应这些细微差别，以充分利用 TON 的潜力构建创新的去中心化应用程序。

<Feedback />
