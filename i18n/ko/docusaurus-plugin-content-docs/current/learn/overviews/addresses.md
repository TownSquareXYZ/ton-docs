# 스마트 컨트랙트 주소

이 섹션에서는 TON 블록체인의 스마트 컨트랙트 주소에 대해 자세히 설명합니다. 또한 TON에서 액터가 스마트 컨트랙트와 어떻게 동의어인지 설명합니다.

## 모든 것이 스마트 컨트랙트입니다

TON에서 스마트 컨트랙트는 [액터 모델]을 사용하여 구축됩니다(/학습/개요/ton-blockchain#single-actor). 실제로 TON의 액터는 기술적으로 스마트 컨트랙트로 표현됩니다. 즉, 지갑도 단순한 액터이자 스마트 컨트랙트라고 할 수 있습니다.

일반적으로 액터는 수신 메시지를 처리하고, 내부 상태를 변경하며, 그 결과로 아웃바운드 메시지를 생성합니다. 그렇기 때문에 TON 블록체인의 모든 액터(즉, 스마트 컨트랙트)는 주소를 가지고 있어야 다른 액터로부터 메시지를 수신할 수 있습니다.

:::info EVM 경험
이더리움 가상머신(EVM)에서 주소는 스마트 콘트랙트와 완전히 분리되어 있습니다. 차이점에 대해 자세히 알아보려면 탈 콜의 ["솔리디티 개발자들을 놀라게 할 TON 블록체인의 6가지 독특한 측면"](https://blog.ton.org/six-unique-aspects-of-ton-blockchain-that-will-surprise-solidity-developers) 글을 읽어보시기 바랍니다.
:::

## 스마트 컨트랙트 주소

TON에서 작동하는 스마트 컨트랙트 주소는 일반적으로 두 가지 주요 구성 요소로 이루어져 있습니다:

- **(workchain_id)**: 워크체인 ID(부호화된 32비트 정수)를 나타냅니다.

- \*\*(account_id)\*\*는 계정의 주소를 나타냅니다(워크체인에 따라 64-512비트).

이 문서의 원시 주소 개요 섹션에서는 **(workchain_id, account_id)** 쌍이 어떻게 표시되는지에 대해 설명합니다.

### 워크체인 ID 및 계정 ID

#### 워크체인 ID

[앞서 살펴본 바와 같이](/학습/오버뷰/톤 블록체인#워크체인-블록체인-자신의-규칙), 톤 블록체인에서 작동하는 `2^32`개의 워크체인을 생성할 수 있습니다. 또한 32비트 접두사 스마트 컨트랙트 주소가 어떻게 서로 다른 워크체인 내의 스마트 컨트랙트 주소를 식별하고 연결되는지에 주목했습니다. 이를 통해 스마트 컨트랙트는 TON 블록체인의 다른 워크체인과 메시지를 주고받을 수 있습니다.

현재 톤 블록체인에서는 마스터체인(workchain_id=-1)과 때때로 기본 워크체인(workchain_id=0)만 실행되고 있습니다.

둘 다 256비트 주소를 가지고 있으므로 workchain_id는 0 또는 -1이고 워크체인 내 주소는 정확히 256비트라고 가정합니다.

#### 계정 ID

TON의 모든 계정 ID는 마스터체인과 베이스체인(또는 기본 워크체인)의 256비트 주소를 사용합니다.

실제로 계정 ID의 \*\*(account_id)\*\*는 스마트 컨트랙트 객체에 대한 해시 함수(특히 SHA-256)로 정의됩니다. 톤 블록체인에서 작동하는 모든 스마트 컨트랙트는 두 가지 주요 구성 요소를 저장합니다. 이들은 다음과 같습니다:

1. 컴파일된 코드_. 바이트코드 형태로 컴파일된 스마트 컨트랙트의 로직입니다.
2. 초기 상태_. 컨트랙트가 온체인에 배포되는 순간의 값입니다.

마지막으로 컨트랙트의 주소를 정확하게 도출하기 위해서는 **(초기 코드, 초기 상태)** 객체 쌍에 해당하는 해시를 계산해야 합니다. 현재로서는 [TVM](/learn/tvm-instructions/tvm-overview)의 작동 방식에 대해 자세히 살펴보지는 않겠지만, TON의 계정 ID는 이 공식을 사용하여 결정된다는 점을 이해하는 것이 중요합니다:
:
**account_id = 해시(초기 코드, 초기 상태)** \*\*

이 문서에서는 TVM과 TL-B 체계의 기술 사양과 개요에 대해 자세히 살펴보도록 하겠습니다. 이제 **account_id**의 생성과 TON에서 스마트 컨트랙트 주소와의 상호작용에 익숙해졌으니, 원시 주소와 사용자 친화적 주소에 대해 설명해 보겠습니다.

## 원시 및 사용자 친화적인 주소

TON의 스마트 컨트랙트 주소가 워크체인과 계정 ID(특히 마스터체인과 베이스체인)를 활용하는 방법에 대해 간략하게 살펴본 후, 이러한 주소가 두 가지 주요 형식으로 표현된다는 점을 이해하는 것이 중요합니다:

- **원시 주소**: 스마트 컨트랙트 주소의 원본 전체 표현.
- **사용자 친화적 주소**: 사용자 친화적 주소는 보안과 사용 편의성을 개선한 향상된 형식의 원시 주소입니다.

아래에서 이 두 주소 유형의 차이점에 대해 자세히 설명하고 TON에서 사용자 친화적인 주소가 사용되는 이유에 대해 자세히 알아보겠습니다.

### 원시 주소

원시 스마트 컨트랙트 주소는 워크체인 ID와 계정 ID \*(워크체인_id, 계정_id)\*로 구성되며 다음 형식으로 표시됩니다:

- [십진수 workchain_id\]:[16진수 64자리, 계정_id 포함\]

아래는 워크체인 ID와 계정 ID를 함께 사용하는 원시 스마트 컨트랙트 주소의 예시입니다(**workchain_id** 및 **account_id**로 표현):

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

주소 문자열의 시작 부분에 있는 '-1'은 마스터체인에 속한 _workchain_id_를 나타냅니다.

:::note
주소 문자열에는 대문자('A', 'B', 'C', 'D' 등)를 소문자('a', 'b', 'c' 'd' 등) 대신 사용할 수 있습니다.
:::

#### 원시 주소 관련 문제

원시 주소 양식을 사용하면 두 가지 주요 문제가 발생합니다:

1. 원시 주소 형식을 사용하면 트랜잭션을 전송하기 전에 오류를 제거하기 위해 주소를 확인할 수 없습니다.
   즉, 트랜잭션을 전송하기 전에 실수로 주소 문자열에 문자를 추가하거나 제거하면 트랜잭션이 잘못된 목적지로 전송되어 자금 손실이 발생할 수 있습니다.
2. 원시 주소 형식을 사용할 때는 사용자 친화적인 주소를 사용하는 트랜잭션을 전송할 때 사용하는 것과 같은 특수 플래그를 추가할 수 없습니다.
   이 개념을 더 잘 이해할 수 있도록 아래에서 어떤 플래그를 사용할 수 있는지 설명해드리겠습니다.

### 사용자 친화적인 주소

사용자 친화적인 주소는 인터넷(예: 공용 메시징 플랫폼 또는 이메일 서비스 제공업체를 통해)은 물론 현실 세계에서 주소를 공유하는 TON 사용자의 경험을 보호하고 간소화하기 위해 개발되었습니다.

#### 사용자 친화적인 주소 구조

사용자 친화적인 주소는 총 36바이트로 구성되며, 다음 구성 요소를 순서대로 생성하여 얻습니다:

1. *[플래그 - 1바이트]* - 주소에 고정된 플래그는 스마트 컨트랙트가 수신된 메시지에 반응하는 방식을 변경합니다.
   사용자 친화적인 주소 형식을 사용하는 플래그 유형은 다음과 같습니다:

   - isBounceable. 바운스 가능 또는 바운스 불가능 주소 유형을 나타냅니다. (_0x11_은 "바운스 가능", _0x51_은 "바운스 불가능").
   - isTestnetOnly. 테스트넷 용도로만 사용되는 주소 유형을 나타냅니다. 0x80_으로 시작하는 주소는 프로덕션 네트워크에서 실행되는 소프트웨어에서 허용되지 않아야 합니다.
   - isUrlSafe. 주소에 대해 URL 안전으로 정의된 더 이상 사용되지 않는 플래그를 나타냅니다. 그러면 모든 주소가 URL 안전 주소로 간주됩니다.
2. *\[workchain_id - 1바이트]* - 워크체인 ID(*workchain_id*)는 부호화된 8비트 정수 _workchain_id_로 정의됩니다.\
   (베이스체인의 경우 *0x00*, 마스터체인의 경우 *0xff*).
3. *\[account_id - 32바이트]* - 계정 ID는 워크체인에서 ([빅엔디안](https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/)) 256비트 주소로 구성됩니다.
4. *\[주소 확인 - 2바이트]* - 사용자 친화적 주소에서 주소 확인은 이전 34바이트의 CRC16-CCITT 서명으로 구성됩니다. ([예시](https://github.com/andreypfau/ton-kotlin/blob/ce9595ec9e2ad0eb311351c8a270ef1bd2f4363e/ton-kotlin-crypto/common/src/crc32.kt))
   사실 사용자 친화적 주소의 인증과 관련된 아이디어는 사용자가 실수로 존재하지 않는 카드 번호를 입력하는 것을 방지하기 위해 모든 신용카드에 사용되는 [루른 알고리즘](https://en.wikipedia.org/wiki/Luhn_algorithm)과 매우 유사합니다.

이 4가지 주요 구성 요소를 더하면 다음과 같습니다: 총 `1 + 1 + 32 + 2 = 36` 바이트(사용자 친화적 주소당)가 됩니다.

사용자 친화적인 주소를 생성하려면 개발자는 둘 중 하나를 사용하여 36바이트를 모두 인코딩해야 합니다:

- *base64* (즉, 숫자, 라틴 대문자 및 소문자, '/' 및 '+' 포함)
- *base64url* ('/'와 '+' 대신 '_'와 '-' 사용)

이 과정이 완료되면 공백이 없는 48자 길이의 사용자 친화적인 주소 생성이 완료됩니다.

:::info DNS 주소 플래그
TON에서는 사용자 친화적인 원시 주소 대신 mywallet.ton과 같은 DNS 주소가 사용되기도 합니다. 실제로 DNS 주소는 사용자 친화적인 주소로 구성되며 개발자가 TON 도메인 내의 DNS 레코드에서 모든 플래그에 액세스할 수 있는 모든 필수 플래그를 포함합니다.
:::

#### 사용자 친화적인 주소 인코딩 예시

예를 들어, "테스트 제공자" 스마트 컨트랙트(테스트 토큰을 요청하는 모든 사람에게 2개의 테스트 토큰을 보내는 테스트넷 마스터체인에 있는 특수 스마트 컨트랙트)는 다음과 같은 원시 주소를 사용합니다:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

위의 "테스트 제공자" 원시 주소를 사용자 친화적인 주소 형식으로 변환해야 합니다. 이는 다음과 같이 base64 또는 base64url 형식(앞서 소개한)을 사용하여 얻을 수 있습니다:

- `kf/8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15+KsQHFLbKSMiYIny` (base64)
- `kf_8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15-KsQHFLbKSMiYIny` (base64url)

:::info
두 양식(*base64* 및 *base64url*)이 모두 유효하며 반드시 수락해야 합니다!
:::

#### 바운스 가능한 주소와 바운스 불가능한 주소

반송 가능한 주소 플래그의 핵심 아이디어는 발신자의 자금 보안입니다.

예를 들어 대상 스마트 컨트랙트가 존재하지 않거나 트랜잭션 중에 문제가 발생하면 메시지는 발신자에게 '반송'되어 원래 거래 금액(모든 송금 및 가스 수수료를 뺀 나머지 금액)으로 구성됩니다. 이렇게 하면 발신자가 거래를 수락할 수 없는 주소로 실수로 송금한 자금을 잃어버리는 일이 발생하지 않습니다.

특히 반송 가능한 주소와 관련하여:

1. 바운스 가능=거짓\*\* 플래그는 일반적으로 수신자가 지갑임을 의미합니다.
2. 바운스 가능=참\*\* 플래그는 일반적으로 자체 애플리케이션 로직이 있는 사용자 지정 스마트 컨트랙트(예: DEX)를 나타냅니다. 이 예시에서는 보안상의 이유로 바운스 불가능한 메시지를 전송해서는 안 됩니다.

반송 불가 메시지](/개발/스마트-계약/가이드라인/반송 불가 메시지) 문서에서 이 주제에 대한 자세한 내용을 읽어보시면 더 잘 이해하실 수 있습니다.

#### 기갑 Base64 표현

TON 블록체인과 관련된 추가 바이너리 데이터는 유사한 "아머드" 베이스64 사용자 친화적인 주소 표현을 사용합니다. 이는 바이트 태그의 처음 4자에 따라 서로 구별됩니다. 예를 들어, 256비트 Ed25519 공개 키는 먼저 아래 프로세스를 사용하여 36바이트 시퀀스를 순서대로 생성하여 표현합니다:

- 0x3E_ 형식을 사용하는 단일 바이트 태그는 공개 키를 나타냅니다.
- 0xE6_ 형식을 사용하는 단일 바이트 태그는 Ed25519 공개키를 나타냅니다.
- Ed25519 공개 키의 표준 바이너리 표현을 포함하는 32바이트
- 이전 34바이트의 CRC16-CCITT의 빅 엔디안 표현을 포함하는 2바이트

결과 36바이트 시퀀스는 표준 방식에 따라 48자 base64 또는 base64url 문자열로 변환됩니다. 예를 들어, Ed25519 공개 키 `E39ECDA0A7B0C60A7107EC43967829DBE8BC356A49B9DFC6186B3EAC74B5477D`(일반적으로 32바이트의 시퀀스로 표시됨)는 다음과 같이 표시됩니다:  0xE3, 0x9E, ..., 0x7D\`)는 다음과 같이 "아머드" 표현을 통해 나타납니다:

`Pubjns2gp7DGCnEH7EOWeCnb6Lw1akm538YYaz6sdLVHfRB2`

### 사용자 친화적인 주소와 원시 주소 변환하기

사용자 친화적인 원시 주소를 변환하는 가장 간단한 방법은 다음과 같은 여러 TON API 및 기타 도구 중 하나를 사용하는 것입니다:

- [ton.org/address](https://ton.org/address)
- [메인넷의 톤센터 API 메소드](https://toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)
- [테스트넷의 톤센터 API 메소드](https://testnet.toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)

또한 JavaScript를 사용하여 지갑의 사용자 친화적인 주소와 원시 주소를 변환하는 두 가지 방법이 있습니다:

- [ton.js를 사용하여 사용자 친화적 또는 원시 양식으로 주소 변환](https://github.com/ton-org/ton-core/blob/main/src/address/Address.spec.ts)
- [톤웹을 사용하여 사용자 친화적 또는 원시 형태로 주소 변환](https://github.com/toncenter/tonweb/tree/master/src/utils#address-class)

SDK](/develop/dapps/apis/sdk)를 사용하여 유사한 메커니즘을 사용할 수도 있습니다.

### 주소 예시

TON 주소에 대한 자세한 예제는 [TON 쿡북]에서 확인하세요(/개발/앱/쿡북#계약 주소로 작업하기).
