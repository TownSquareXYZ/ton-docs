import ThemedImage from '@theme/ThemedImage';

# 백엔드에서 로그인 사용자 인증하기

이 페이지에서는 백엔드에서 사용자가 선언한 주소를 실제로 소유하고 있는지 확인하는 방법을 설명합니다.
모든 DApp에서 사용자 인증이 필요한 것은 아닙니다.

백엔드에서 사용자의 개인 정보를 제공하기 위해 사용자를 인증하려는 경우 유용합니다.

## 작동 방식

- 사용자가 로그인 프로세스를 시작합니다.
- 백엔드가 ton_proof 엔티티를 생성하여 프론트엔드로 전송합니다.
- 프론트엔드는 ton_proof를 사용하여 지갑에 로그인하고 서명된 ton_proof를 받습니다.
- 프론트엔드가 서명된 ton_proof를 백엔드로 전송하여 검증합니다.

<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/docs/ton-connect/ton_proof_scheme.svg?raw=true',
        dark: '/img/docs/ton-connect/ton_proof_scheme-dark.svg?raw=true',
    }}
/>
<br></br>

## ton_proof 구조

connector 내부에 구현된 TonProof 엔티티를 사용합니다.

```js
type TonProofItemReply = TonProofItemReplySuccess | TonProofItemReplyError;

type TonProofItemReplySuccess = {
  name: "ton_proof";
  proof: {
    timestamp: string; // 64-bit unix epoch time of the signing operation (seconds)
    domain: {
      lengthBytes: number; // AppDomain Length
      value: string;  // app domain name (as url part, without encoding)
    };
    signature: string; // base64-encoded signature
    payload: string; // payload from the request
  }
}

```

## 서버 측에서 ton_proof 확인하기

1. 사용자로부터 `TonProofItemReply`를 가져옵니다.
2. 받은 도메인이 애플리케이션 도메인과 일치하는지 확인합니다.
3. `TonProofItemReply.payload`가 원본 서버에서 허용되고 여전히 유효한지 확인합니다.
4. `timestamp`가 현재 시점에서 유효한지 확인합니다.
5. [메시지 스킴](/v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#concept-explanation)에 따라 메시지를 조합합니다.
6. API(a)나 백엔드 로직(b)을 통해 `public_key`를 가져옵니다

- 6a:
  - [TON API](https://docs.tonconsole.com/tonapi#:~:text=/v2/-,tonconnect,-/stateinit)의 `POST /v2/tonconnect/stateinit` 메서드로 `walletStateInit`에서 `{public_key, address}`를 가져옵니다.
  - `walletStateInit`에서 추출한 `address`가 사용자가 선언한 지갑 `address`와 일치하는지 확인합니다.
- 6b:
  - 지갑 계약의 [get 메서드](https://github.com/ton-blockchain/wallet-contract/blob/main/func/wallet-v4-code.fc#L174)를 통해 지갑 `public_key`를 얻습니다.
  - 계약이 활성화되지 않았거나 이전 지갑 버전(v1-v3)에서 발견되는 get_method가 없는 경우, 이 방식으로 키를 얻을 수 없습니다. 대신 프론트엔드에서 제공한 walletStateInit을 파싱해야 합니다. TonAddressItemReply.walletStateInit.hash()가 TonAddressItemReply.address.hash()와 같은지 확인하여 BoC 해시를 나타냅니다.

7. 프론트엔드의 `signature`가 조합된 메시지에 대해 올바르게 서명되었고 주소의 `public_key`와 일치하는지 확인합니다.

## React 예시

1. 앱의 루트에 토큰 프로바이더를 추가합니다:

```tsx
function App() {
    const [token, setToken] = useState<string | null>(null);

  return (
      <BackendTokenContext.Provider value={{token, setToken}}>
            { /* Your app */ }
      </BackendTokenContext.Provider>
  )
}
```

2. 백엔드 통합과 함께 프론트엔드에서 인증을 구현합니다:

<details>
<summary>예시</summary>

```tsx
import {useContext, useEffect, useRef} from "react";
import {BackendTokenContext} from "./BackendTokenContext";
import {useIsConnectionRestored, useTonConnectUI, useTonWallet} from "@tonconnect/ui-react";
import {backendAuth} from "./backend-auth";

const localStorageKey = 'my-dapp-auth-token';
const payloadTTLMS = 1000 * 60 * 20;

export function useBackendAuth() {
    const { setToken } = useContext(BackendTokenContext);
    const isConnectionRestored = useIsConnectionRestored();
    const wallet = useTonWallet();
    const [tonConnectUI] = useTonConnectUI();
    const interval = useRef<ReturnType<typeof setInterval> | undefined>();

    useEffect(() => {
        if (!isConnectionRestored || !setToken) {
            return;
        }

        clearInterval(interval.current);

        if (!wallet) {
            localStorage.removeItem(localStorageKey);
            setToken(null);

            const refreshPayload = async () => {
                tonConnectUI.setConnectRequestParameters({ state: 'loading' });

                const value = await backendAuth.generatePayload();
                if (!value) {
                    tonConnectUI.setConnectRequestParameters(null);
                } else {
                    tonConnectUI.setConnectRequestParameters({state: 'ready', value});
                }
            }

            refreshPayload();
            setInterval(refreshPayload, payloadTTLMS);
            return;
        }

        const token = localStorage.getItem(localStorageKey);
        if (token) {
            setToken(token);
            return;
        }

        if (wallet.connectItems?.tonProof && !('error' in wallet.connectItems.tonProof)) {
            backendAuth.checkProof(wallet.connectItems.tonProof.proof, wallet.account).then(result => {
                if (result) {
                    setToken(result);
                    localStorage.setItem(localStorageKey, result);
                } else {
                    alert('Please try another wallet');
                    tonConnectUI.disconnect();
                }
            })
        } else {
            alert('Please try another wallet');
            tonConnectUI.disconnect();
        }

    }, [wallet, isConnectionRestored, setToken])
}
```

</details>

## 백엔드 예시

<details>
<summary>Proof 유효성 확인하기 (Next.js)</summary>

```tsx
'use server'
import {Address, Cell, contractAddress, loadStateInit, TonClient4} from '@ton/ton'


export async function isValid(proof, account) {
    const payload = {
					address: account.address,
					public_key: account.publicKey,
					proof: {
						...proof,
						state_init: account.walletStateInit
					}
	  }
    const stateInit = loadStateInit(Cell.fromBase64(payload.proof.state_init).beginParse())
	  const client = new TonClient4({
		  endpoint: 'https://mainnet-v4.tonhubapi.com'
	  })
	  const masterAt = await client.getLastBlock()
	  const result = await client.runMethod(masterAt.last.seqno, Address.parse(payload.address), 'get_public_key', [])
	  const publicKey = Buffer.from(result.reader.readBigNumber().toString(16).padStart(64, '0'), 'hex')
	  if (!publicKey) {
		  return false
	  }
	  const wantedPublicKey = Buffer.from(payload.public_key, 'hex')
	  if (!publicKey.equals(wantedPublicKey)) {
		  return false
	  }
	  const wantedAddress = Address.parse(payload.address)
	  const address = contractAddress(wantedAddress.workChain, stateInit)
	  if (!address.equals(wantedAddress)) {
		  return false
	  }
	  const now = Math.floor(Date.now() / 1000)
	  if (now - (60 * 15) > payload.proof.timestamp) {
		  return false
	  }
    return true
  }

```

</details>

주요 메서드를 보여주는 [예시](https://github.com/ton-connect/demo-dapp-with-react-ui/tree/master/src/server)를 확인할 수 있습니다:

- [generatePayload](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/api/generate-payload.ts): ton proof용 페이로드 생성
- [checkProof](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/api/check-proof.ts): proof를 확인하고 액세스 토큰 반환

## 개념 설명

`TonProofItem`이 요청되면 지갑은 선택된 계정의 키 소유권을 증명합니다. 서명된 메시지는 다음과 연결됩니다:

- 온체인 메시지와 구분하기 위한 고유 접두사 (`ton-connect`)
- 지갑 주소
- 앱 도메인
- 서명 타임스탬프
- 앱의 커스텀 페이로드(서버가 nonce, 쿠키 ID, 만료 시간 등을 넣을 수 있는 곳)

```
message = utf8_encode("ton-proof-item-v2/") ++
          Address ++
          AppDomain ++
          Timestamp ++
          Payload

signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode("ton-connect") ++ sha256(message)))
```

여기서:

- `Address`는 다음 시퀀스로 인코딩된 지갑 주소:
- `workchain`: 32비트 부호있는 정수 빅엔디안
- `hash`: 256비트 부호없는 정수 빅엔디안
- `AppDomain`은 Length ++ EncodedDomainName

<!---->

- `Length`는 utf-8로 인코딩된 앱 도메인 이름의 바이트 길이를 나타내는 32비트 값
- `EncodedDomainName`은 `Length`바이트의 utf-8로 인코딩된 앱 도메인 이름

<!---->

- `Timestamp`는 서명 작업의 64비트 유닉스 에폭 시간
- `Payload`는 가변 길이 바이너리 문자열

참고: payload는 신뢰할 수 없는 가변 길이 데이터입니다. 불필요한 길이 접두사 사용을 피하기 위해 마지막에 배치합니다.

서명은 공개키를 사용하여 확인해야 합니다:

1. 먼저 `Address`에 배포된 스마트 계약의 `get_public_key` get-메서드를 통해 공개키를 얻습니다.

2. 스마트 계약이 아직 배포되지 않았거나 get-메서드가 없는 경우:

   1. `TonAddressItemReply.walletStateInit`를 파싱하여 stateInit에서 공개키를 가져옵니다. `walletStateInit.code`를 표준 지갑 계약의 코드와 비교하고 발견된 지갑 버전에 따라 데이터를 파싱할 수 있습니다.

   2. `TonAddressItemReply.publicKey`가 얻은 공개키와 일치하는지 확인

   3. `TonAddressItemReply.walletStateInit.hash()`가 `TonAddressItemReply.address`와 일치하는지 확인. `.hash()`는 BoC 해시를 의미합니다.

### TON Proof 검증 예시

- [Go 데모 앱](https://github.com/ton-connect/demo-dapp-backend)
- [Rust 데모 앱](https://github.com/liketurbo/demo-dapp-backend-rs)
- [JS 데모 앱](https://github.com/liketurbo/demo-dapp-backend-js)
- [Python 예시](https://github.com/XaBbl4/pytonconnect/blob/main/examples/check_proof.py)
- [PHP 예시](https://github.com/vladimirfokingithub/Ton-Connect-Proof-Php-Check)
- [C# 데모 앱](https://github.com/WinoGarcia/TonProof.NET)

## 참고 자료

- [[YouTube] @tonconnect/react-ui의 ton_proof 확인하기 [RU]](https://youtu.be/wIMbkJHv0Fs?list=PLyDBPwv9EPsCJ226xS5_dKmXXxWx1CKz_&t=2971)
- [메시지 준비하기](/v3/guidelines/ton-connect/guidelines/preparing-messages)
- [메시지 보내기](/v3/guidelines/ton-connect/guidelines/sending-messages)
