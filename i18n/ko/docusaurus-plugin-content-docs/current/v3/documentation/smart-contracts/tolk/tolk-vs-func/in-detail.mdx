# Tolk vs FunC: 상세 비교

매우 긴 목록입니다. 끝까지 읽을 인내심이 있으신가요?..

:::tip 요약 버전이 있습니다
여기에서 보실 수 있습니다: [Tolk vs FunC: 요약](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)
:::

<h3 className="cmp-func-tolk-header">
  ✅ 전통적인 주석 :)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{';; comment'}</code></td>
    <td><code>{'// comment'}</code></td>
  </tr>
  <tr>
    <td><code>{'{- multiline comment -}'}</code></td>
    <td><code>{'/* multiline comment */'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `2+2`는 식별자가 아닌 4입니다. 식별자는 알파벳과 숫자만 가능합니다
</h3>

FunC에서는 거의 모든 문자가 식별자의 일부가 될 수 있습니다.
예를 들어 `2+2`(공백 없이)는 식별자입니다.
이러한 이름으로 변수를 선언할 수도 있습니다.

Tolk에서는 공백이 필수가 아닙니다. `2+2`는 예상대로 4입니다. `3+~x`는 `3 + (~ x)`이고, 이런 식입니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'return 2+2;  ;; undefined function `2+2`'}</code></td>
    <td><code>{'return 2+2;  // 4'}</code></td>
  </tr>
  </tbody>
</table>

더 정확히 말하면, 식별자는 <code style={{display: 'inline-block'}}>{'[a-zA-Z$_]'}</code>로 시작할 수 있고 <code style={{display: 'inline-block'}}>{'[a-zA-Z0-9$_]'}</code>로 이어질 수 있습니다. `?`, `:` 등은 유효한 기호가 아니며, `found?`와 `op::increase`는 유효한 식별자가 아닙니다.

백틱을 사용하여 식별자를 둘러싸면 모든 기호를 포함할 수 있습니다(Kotlin과 다른 언어들과 유사). 예를 들어 코드 생성 스키마에서 키워드를 식별자로 사용할 수 있게 하는 것이 잠재적인 용도입니다.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'const op::increase = 0x1234;'}</code></td>
    <td><code>{'const OP_INCREASE = 0x1234;'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: ';; even 2%&!2 is valid<br>int 2+2 = 5;'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '// don\'t do like this :)<br>var \`2+2\` = 5;'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ 기본적으로 impure, 컴파일러는 사용자 함수 호출을 삭제하지 않습니다
</h3>

FunC에는 `impure` 함수 지정자가 있습니다. 지정자가 없으면 함수는 pure로 취급됩니다. 결과가 사용되지 않으면 컴파일러에 의해 호출이 삭제됩니다.

이 동작은 문서화되어 있지만 초보자들에게는 매우 예상치 못한 것입니다.
예를 들어 아무것도 반환하지 않는 다양한 함수들(불일치 시 예외를 던지는 등)이
자동으로 삭제됩니다. FunC가 함수 본문을 확인하고 검증하지 않아
pure 함수 내에서 impure 연산을 허용한다는 사실로 인해 이 상황이 더 악화됩니다.

Tolk에서는 모든 함수가 기본적으로 impure입니다. 어노테이션으로 함수를 pure로 표시할 수 있으며,
그런 경우 그 본문에서 impure 연산(예외, 전역 수정, non-pure 함수 호출 등)이 금지됩니다.

<h3 className="cmp-func-tolk-header">
  ✅ 새로운 함수 구문: `fun` 키워드, `@` 속성, 타입은 오른쪽에 (TypeScript, Kotlin, Python 등과 같이)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'cell parse_data(slice cs) { }'}</code></td>
    <td><code>{'fun parse_data(cs: slice): cell { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell, int) load_storage() { }'}</code></td>
    <td><code>{'fun load_storage(): (cell, int) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'() main() { ... }'}</code></td>
    <td><code>{'fun main() { ... }'}</code></td>
  </tr>
  </tbody>
</table>

변수의 타입도 오른쪽에:

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'slice cs = ...;'}</code></td>
    <td><code>{'var cs: slice = ...;'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell c, int n) = parse_data(cs);'}</code></td>
    <td><code>{'var (c: cell, n: int) = parse_data(cs);'}</code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`inline`과 다른 수정자들은 어노테이션으로:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>int f(cell s) inline {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline<br>fun f(s: cell): int {'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() load_data() impure inline_ref {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline_ref<br>fun load_data() {'}}></code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`forall`은 이렇게:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'forall X -> tuple cons(X head, tuple tail)'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'fun cons&amp;lt;X&amp;gt;(head: X, tail: tuple): tuple'}}></code></td>
  </tr>
  </tbody>
</table>

`asm` 구현은 FunC와 비슷하지만, 적절히 정렬되어 더 보기 좋습니다:

```tolk
@pure
fun third<X>(t: tuple): X
    asm "THIRD";

@pure
fun iDictDeleteGet(dict: cell, keyLen: int, index: int): (cell, slice, int)
    asm(index dict keyLen) "DICTIDELGET NULLSWAPIFNOT";

@pure
fun mulDivFloor(x: int, y: int, z: int): int
    builtin;
```

컴파일에는 영향을 미치지 않지만 사람과 IDE를 위한 `@deprecated` 속성도 있습니다.

<h3 className="cmp-func-tolk-header">
  ✅ `method_id` 대신 `get`
</h3>

FunC에서 `method_id`(인수 없이)는 실제로 get 메서드를 선언했습니다. Tolk에서는 직관적인 구문을 사용합니다:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int seqno() method_id { ... }'}</code></td>
    <td><code>{'get seqno(): int { ... }'}</code></td>
  </tr>
  </tbody>
</table>

`get methodName()`과 `get fun methodName()` 모두 허용됩니다.

`method_id(xxx)`의 경우(실제로는 드물지만 유효함), 속성이 있습니다:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() after_code_upgrade(cont old_code) impure method_id(1666)'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@method_id(1666)<br>fun afterCodeUpgrade(oldCode: continuation)'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ 매개변수의 타입 선언이 필수입니다(로컬 변수는 선택사항)
</h3>

```tolk
// not allowed
fun do_smth(c, n)
// types are mandatory
fun do_smth(c: cell, n: int)
```

매개변수 타입이 필수인 반면, 반환 타입은 필수가 아닙니다(종종 명백하거나 장황합니다). 생략하면 자동으로 추론됩니다:

```tolk
fun x() { ... }  // auto infer from return statements
```

로컬 변수의 경우에도 타입은 선택사항입니다:

```tolk
var i = 10;                      // ok, int
var b = beginCell();             // ok, builder
var (i, b) = (10, beginCell());  // ok, two variables, int and builder

// types can be specified manually, of course:
var b: builder = beginCell();
var (i: int, b: builder) = (10, beginCell());
```

<h3 className="cmp-func-tolk-header">
  ✅ 같은 스코프에서 변수를 재선언할 수 없습니다
</h3>

```tolk
var a = 10;
...
var a = 20;  // error, correct is just `a = 20`
if (1) {
    var a = 30;  // it's okay, it's another scope
}
```

결과적으로 부분 재할당은 허용되지 않습니다:

```tolk
var a = 10;
...
var (a, b) = (20, 30);  // error, releclaration of a
```

이는 `loadUint()`와 같은 메서드에는 문제가 되지 않습니다. FunC에서는 수정된 객체를 반환했기 때문에 `var (cs, int value) = cs.load_int(32)` 패턴이 매우 일반적이었습니다. Tolk에서는 이러한 메서드가 객체를 변형시킵니다: `var value = cs.loadInt(32)`, 따라서 재선언이 필요할 가능성이 낮습니다.

```tolk
fun send(msg: cell) {
    var msg = ...;  // error, redeclaration of msg

    // solution 1: intruduce a new variable
    var msgWrapped = ...;
    // solution 2: use `redef`, though not recommended
    var msg redef = ...;
```

<h3 className="cmp-func-tolk-header">
  ✅ 타입 시스템의 변경사항
</h3>

FunC의 타입 시스템은 Hindley-Milner를 기반으로 합니다. 이는 단일화를 통해 사용에서 타입을 추론하는 함수형 언어에서 일반적인 접근 방식입니다.

Tolk v0.7에서는 타입 시스템이 처음부터 다시 작성되었습니다.
불리언, 고정 너비 정수, null 가능성, 구조체, 제네릭을 추가하기 위해서는 정적 타입 시스템이 필요합니다(TypeScript나 Rust처럼).
Hindley-Milner는 구조체 메서드와 충돌하고, 적절한 제네릭을 다루는 데 어려움을 겪으며, 유니온 타입에는 완전히 비실용적이기 때문입니다("유니온 타입을 위해 설계되었다"는 주장에도 불구하고).

다음과 같은 타입들이 있습니다:

- `int`, `bool`, `cell`, `slice`, `builder`, 타입이 지정되지 않은 `tuple`
- 타입이 지정된 튜플 `[T1, T2, ...]`
- 텐서 `(T1, T2, ...)`
- 호출 가능 타입 `fun(TArgs) -> TResult`
- `void` (`unit`으로 명명하는 것이 더 정통적이지만 `void`가 더 안정적)
- `self`, 아래에서 설명할 연결 가능한 메서드를 만들기 위함; 실제로는 타입이 아니며 함수의 반환 타입 대신에만 발생할 수 있음

타입 시스템은 다음 규칙을 따릅니다:

- 변수 타입은 수동으로 지정하거나 선언에서 추론될 수 있으며, 선언된 후에는 절대 변경되지 않음
- 함수 매개변수는 반드시 명확한 타입을 가져야 함
- 함수 반환 타입은 지정되지 않은 경우 TypeScript와 유사하게 return 문에서 추론됨; 재귀(직접 또는 간접)의 경우 어딘가에서 반환 타입을 명시적으로 선언해야 함
- 제네릭 함수 지원됨

<h3 className="cmp-func-tolk-header">
  ✅ 타입 불일치 시 명확하고 읽기 쉬운 오류 메시지
</h3>

FunC에서는 Hindley-Milner로 인해 타입 불일치 오류를 이해하기가 매우 어렵습니다:

```
error: previous function return type (int, int)
cannot be unified with implicit end-of-block return type (int, ()):
cannot unify type () with int
```

Tolk에서는 사람이 읽을 수 있습니다:

```
1) can not assign `(int, slice)` to variable of type `(int, int)`
2) can not call method for `builder` with object of type `int`
3) can not use `builder` as a boolean condition
4) missing `return`
...
```

<h3 className="cmp-func-tolk-header">
  ✅ <code>bool</code> 타입, <code>boolVar as int</code> 캐스팅
</h3>

내부적으로 **`bool`은 여전히 TVM 레벨에서 -1과 0입니다**, 하지만 타입 시스템의 관점에서 `bool`과 `int`는 이제 다릅니다.

비교 연산자 `== / >= /...`는 `bool`을 반환합니다. 논리 연산자 `&& ||`는 `bool`을 반환합니다. 상수 `true`와 `false`는 `bool` 타입을 가집니다.
많은 stdlib 함수들이 이제 `int` 대신 `bool`을 반환합니다(런타임에서는 -1과 0):

```tolk
var valid = isSignatureValid(...);    // bool
var end = cs.isEndOfSlice();          // bool
```

연산자 `!x`는 `int`와 `bool` 모두 지원합니다. `if`와 유사한 조건문은 `int`(!= 0)와 `bool` 모두 허용합니다.
논리 연산자 `&&`와 `||`는 정수가 아닌 값에 대한 `a && b` 같은 구문과의 호환성을 위해 `bool`과 `int` 모두 허용합니다.

산술 연산자는 정수로 제한되며, 비트 연산자와 논리 연산자만 불리언에 허용됩니다:

```tolk
valid && end;    // ok
valid & end;     // ok, bitwise & | ^ also work if both are bools
if (!end)        // ok

if (~end)        // error, use !end
valid + end;     // error
8 & valid;       // error, int & bool not allowed
```

논리 연산자 `&& ||`(FunC에서는 누락됨)는 항상 IF/ELSE asm 표현을 사용합니다.
향후 최적화를 위해 안전할 때(예: `a > 0 && a < 10`) 자동으로 `& |`로 대체될 수 있습니다.
가스 소비를 수동으로 최적화하기 위해 여전히 `& |`(bool에 허용됨)를 사용할 수 있지만, 단락 평가가 아니라는 점을 기억하세요.

**`bool`은 `as` 연산자를 통해 `int`로 캐스팅될 수 있습니다**:

```tolk
var i = boolValue as int;  // -1 / 0
```

런타임 변환은 없습니다. `bool`은 TVM 레벨에서 -1/0임이 보장되므로 이는 타입만의 캐스팅입니다.
하지만 일반적으로 이러한 캐스팅이 필요하다면 아마도 잘못된 방식으로 하고 있는 것입니다(까다로운 비트 연산 최적화를 하는 경우 제외).

<h3 className="cmp-func-tolk-header">
  ✅ 제네릭 함수와 <code>f&amp;lt;int&amp;gt;(...)</code> 같은 인스턴스화
</h3>

FunC에는 "forall" 함수가 있었습니다:

```func
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
```

Tolk는 제대로 만들어진 제네릭 함수를 도입합니다. 구문은 주류 언어들을 연상시킵니다:

```tolk
fun tuplePush<T>(mutate self: tuple, value: T): void
    asm "TPUSH";
```

`f<T>`가 호출될 때 `T`는 (대부분의 경우) 제공된 인수에 의해 감지됩니다:

```tolk
t.tuplePush(1);     // detected T=int
t.tuplePush(cs);    // detected T=slice
t.tuplePush(null);  // error, need to specify "null of what type"
```

구문 `f<int>(...)`도 지원됩니다:

```tolk
t.tuplePush<int>(1);     // ok
t.tuplePush<int>(cs);    // error, can not pass slice to int
t.tuplePush<int>(null);  // ok, null is "null of type int"
```

사용자 정의 함수도 제네릭일 수 있습니다:

```tolk
fun replaceLast<T>(mutate self: tuple, value: T) {
    val size = self.tupleSize();
    self.tupleSetAt(value, size - 1);
}
```

`replaceLast<int>`와 `replaceList<slice>`를 호출하면 두 개의 생성된 asm (fift) 함수가 됩니다.
실제로 이들은 대부분 "템플릿" 함수를 연상시킵니다. 각각의 고유한 호출에서 함수의 본문은 새로운 이름으로 완전히 복제됩니다.

여러 제네릭 매개변수가 있을 수 있습니다:

```tolk
fun replaceNulls<T1, T2>(tensor: (T1, T2), v1IfNull: T1, v2IfNull: T2): (T1, T2) {
    var (a, b) = tensor;
    return (a == null ? v1IfNull : a, b == null ? v2IfNull : b);
}
```

제네릭 매개변수 `T`는 복잡한 것일 수도 있습니다.

```tolk
fun duplicate<T>(value: T): (T, T) {
    var copy: T = value;
    return (value, copy);
}

duplicate(1);         // duplicate<int>
duplicate([1, cs]);   // duplicate<[int, slice]>
duplicate((1, 2));    // duplicate<(int, int)>
```

또는 함수도 가능하며, 이것도 작동합니다:

```tolk
fun callAnyFn<TObj, TResult>(f: fun(TObj) -> TResult, arg: TObj) {
    return f(arg);
}

fun callAnyFn2<TObj, TCallback>(f: TCallback, arg: TObj) {
    return f(arg);
}
```

제네릭 `T`가 대부분 인수에서 감지되는 반면, `T`가 인수에 의존하지 않는 덜 분명한 경우가 있습니다:

```tolk
fun tupleLast<T>(self: tuple): T
    asm "LAST";

var last = t.tupleLast();    // error, can not deduce T
```

이를 유효하게 만들기 위해서는 `T`를 외부에서 제공해야 합니다:

```tolk
var last: int = t.tupleLast();       // ok, T=int
var last = t.tupleLast<int>();       // ok, T=int
var last = t.tupleLast() as int;     // ok, T=int

someF(t.tupleLast());       // ok, T=(paremeter's declared type)
return t.tupleLast();       // ok if function specifies return type
```

또한 asm 함수의 `T`는 1개의 스택 슬롯을 차지해야 합니다(그렇지 않으면 asm 본문이 제대로 처리할 수 없음), 반면 사용자 정의 함수의 경우 `T`는 어떤 형태도 가능합니다.

향후 구조체와 제네릭 구조체가 구현되면 제네릭 함수의 모든 힘이 발휘될 것입니다.

<h3 className="cmp-func-tolk-header">
  ✅ recv_internal / recv_external에 대한 다른 이름
</h3>

```tolk
fun onInternalMessage
fun onExternalMessage
fun onTickTock
fun onSplitPrepare
fun onSplitInstall
```

모든 매개변수 타입과 순서는 그대로이고 이름만 변경되었습니다. `fun main`도 사용 가능합니다.

<h3 className="cmp-func-tolk-header">
  ✅ #include → import. 엄격한 임포트
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'#include "another.fc";'}</code></td>
    <td><code>{'import "another.tolk"'}</code></td>
  </tr>
  </tbody>
</table>

Tolk에서는 이 파일을 임포트하지 않고는 `a.tolk`의 심볼을 사용할 수 없습니다. 다시 말해서 "사용하는 것을 임포트하세요".

모든 stdlib 함수는 기본적으로 사용 가능하며, stdlib를 다운로드하고 `#include "stdlib.fc"`를 할 필요가 없습니다. 내장된 stdlib에 대해서는 아래를 참조하세요.

여전히 전역 이름 범위가 있습니다. `f`가 두 개의 다른 파일에서 선언되면 오류입니다. 우리는 파일 전체를 "임포트"하며, 현재는 파일별 가시성과 `export` 키워드가 지원되지 않지만 향후에는 가능할 것입니다.

<h3 className="cmp-func-tolk-header">
  ✅ #pragma → 컴파일러 옵션
</h3>

FunC에서는 `allow-post-modifications`와 같은 "실험적" 기능이 .fc 파일의 프라그마로 켜졌습니다(일부 파일에는 있고 일부 파일에는 없어서 발생하는 문제로 이어짐). 실제로는 파일을 위한 프라그마가 아닌 컴파일 옵션입니다.

Tolk에서는 모든 프라그마가 제거되었습니다. `allow-post-modification`과 `compute-asm-ltr`는 Tolk 소스에 병합되었습니다(FunC에서 항상 켜져 있던 것처럼). 프라그마 대신 이제 실험적 옵션을 전달할 수 있습니다.

현재로서는 하나의 실험적 옵션이 도입되었습니다 - `remove-unused-functions`으로, 사용되지 않은 심볼을 Fift 출력에 포함하지 않습니다.

`#pragma version xxx`는 `tolk xxx`로 대체되었습니다(>=가 없고 엄격한 버전). 사용하고 있는 컴파일러 버전을 주석으로 달아두는 것이 좋은 관행입니다. 일치하지 않으면 Tolk가 경고를 표시합니다.

```tolk
tolk 0.6
```

<h3 className="cmp-func-tolk-header">
  ✅ 늦은 심볼 해결. AST 표현
</h3>

FunC에서는(C와 마찬가지로) 아래에 선언된 함수에 접근할 수 없습니다:

```func
int b() { a(); }   ;; error
int a() { ... }    ;; since it's declared below
```

오류를 피하기 위해서는 프로그래머가 먼저 전방 선언을 해야 합니다. 이는 심볼 해결이 구문 분석 시점에 수행되기 때문입니다.

Tolk 컴파일러는 이 두 단계를 분리합니다. 먼저 구문 분석을 하고, 그 다음 심볼 해결을 합니다. 따라서 위의 코드 조각은 오류가 되지 않습니다.

간단해 보이지만 내부적으로는 매우 큰 작업입니다. 이를 가능하게 하기 위해 FunC에는 완전히 빠져있던 중간 AST 표현을 도입했습니다. 이는 향후 수정과 의미론적 코드 분석 수행을 위한 필수적인 부분입니다.

<h3 className="cmp-func-tolk-header">
  ✅ `null` 키워드
</h3>

널 값 생성과 변수의 널 체크가 이제 매우 깔끔해 보입니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'a = null()'}</code></td>
    <td><code>{'a = null'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (null?(a))'}</code></td>
    <td><code>{'if (a == null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ null?(b))'}</code></td>
    <td><code>{'if (b != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ cell_null?(c))'}</code></td>
    <td><code>{'if (c != null)'}</code></td>
  </tr>
  </tbody>
</table>

이것이 Tolk 언어에 널 가능성이 있다는 의미는 아닙니다. 아니요, FunC처럼 여전히 정수 변수에 `null`을 할당할 수 있습니다 - 단지 구문적으로 더 보기 좋을 뿐입니다. 진정한 널 가능성은 타입 시스템에 대한 힘든 작업 이후에 언젠가 사용 가능할 것입니다.

<h3 className="cmp-func-tolk-header">
  ✅ `throw`와 `assert` 키워드
</h3>

Tolk는 예외 작업을 크게 단순화합니다.

FunC가 `throw()`, `throw_if()`, `throw_arg_if()`와 unless에 대한 같은 것을 가지고 있다면, Tolk는 `throw`와 `assert` 두 가지 기본 요소만 가집니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'throw(excNo)'}</code></td>
    <td><code>{'throw excNo'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_arg(arg, excNo)'}</code></td>
    <td><code>{'throw (excNo, arg)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_unless(excNo, condition)'}</code></td>
    <td><code>{'assert(condition, excNo)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_if(excNo, condition)'}</code></td>
    <td><code>{'assert(!condition, excNo)'}</code></td>
  </tr>
  </tbody>
</table>

논리적 NOT이 가능하므로 `!condition`이 가능하다는 점을 참고하세요.

`assert(condition, excNo)`의 긴(자세한) 구문이 있습니다:

```tolk
assert(condition) throw excNo;
// with possibility to include arg to throw
```

또한 Tolk는 `catch` 인수를 바꿉니다: `catch (excNo, arg)`이며, 둘 다 선택사항입니다(arg가 대부분 비어있기 때문에).

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'try { } catch (_, _) { }'}</code></td>
    <td><code>{'try { } catch { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (_, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (arg, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo, arg) { }'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `do ... until` → `do ... while`
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'do { ... } until (~ condition);'}</code></td>
    <td><code>{'do { ... } while (condition);'}</code></td>
  </tr>
  <tr>
    <td><code>{'do { ... } until (condition);'}</code></td>
    <td><code>{'do { ... } while (!condition);'}</code></td>
  </tr>
  </tbody>
</table>

논리적 NOT이 가능하므로 `!condition`이 가능하다는 점을 참고하세요.

<h3 className="cmp-func-tolk-header">
  ✅ 연산자 우선순위가 C++ / JavaScript와 동일해짐
</h3>

FunC에서는 `if (slices_equal() & status == 1)` 같은 코드가 `if( (slices_equal()&status) == 1 )`로 파싱됩니다. 이는 실제 계약에서 다양한 오류의 원인이 됩니다.

Tolk에서는 `&`가 C++와 JavaScript와 동일하게 더 낮은 우선순위를 가집니다.

더욱이 Tolk는 이러한 오류를 완전히 제거하기 위해 잠재적으로 잘못된 연산자 사용에 대해 오류를 발생시킵니다:

```tolk
if (flags & 0xFF != 0)
```

컴파일 오류가 발생합니다(gcc/clang과 유사):

```
& has lower precedence than ==, probably this code won't work as you expected.  Use parenthesis: either (... & ...) to evaluate it first, or (... == ...) to suppress this error.
```

따라서 코드는 다시 작성되어야 합니다:

```tolk
// either to evaluate it first (our case)
if ((flags & 0xFF) != 0)
// or to emphasize the behavior (not our case here)
if (flags & (0xFF != 0))
```

비트시프트 연산자에서 흔한 실수에 대한 진단도 추가했습니다: `a << 8 + 1`은 `a << 9`와 동일하며, 아마도 예상치 못한 결과일 것입니다.

```
int result = a << 8 + low_mask;

error: << has lower precedence than +, probably this code won't work as you expected.  Use parenthesis: either (... << ...) to evaluate it first, or (... + ...) to suppress this error.
```

연산자 `~% ^% /% ~/= ^/= ~%= ^%= ~>>= ^>>=`는 더 이상 존재하지 않습니다.

<h3 className="cmp-func-tolk-header">
  ✅ `val`을 통해 선언되는 불변 변수
</h3>

Kotlin처럼: 가변에는 `var`, 불변에는 `val`, 선택적으로 타입이 따라옵니다. FunC에는 `val`의 대응물이 없습니다.

```tolk
val flags = msgBody.loadMessageFlags();
flags &= 1;         // error, modifying an immutable variable

val cs: slice = c.beginParse();
cs.loadInt(32);     // error, since loadInt() mutates an object
cs.preloadInt(32);  // ok, it's a read-only method
```

함수의 매개변수는 가변이지만, 값으로 복사되기 때문에 호출된 인수는 변경되지 않습니다. FunC와 정확히 같으며, 명확히 하기 위함입니다.

```tolk
fun some(x: int) {
    x += 1;
}

val origX = 0;
some(origX);      // origX remains 0

fun processOpIncrease(msgBody: slice) {
    val flags = msgBody.loadInt(32);
    ...
}

processOpIncrease(msgBody);  // by value, not modified
```

Tolk에서 함수는 `mutate` 매개변수를 선언할 수 있습니다. 이는 FunC의 `~` 틸다 함수의 일반화이며, 아래에서 읽어보세요.

<h3 className="cmp-func-tolk-header">
  ✅ 더 이상 사용되지 않는 명령줄 옵션 제거
</h3>

명령줄 플래그 `-A`, `-P` 등이 제거되었습니다. 기본 동작

```
/path/to/tolk {inputFile}
```

이 충분합니다. 버전을 출력하고 종료하려면 `-v`를 사용하세요. 사용 가능한 모든 명령줄 플래그를 보려면 `-h`를 사용하세요.

하나의 입력 파일만 전달할 수 있으며, 다른 파일들은 `import`되어야 합니다.

<h3 className="cmp-func-tolk-header">
  ✅ stdlib 함수들이 ~~장황한~~ 명확한 이름으로 변경됨, camelCase 스타일
</h3>

표준 라이브러리의 모든 이름이 재고되었습니다. 이제 함수들은 더 길지만 명확한 이름을 사용합니다.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'cur_lt()<br>car(l)<br>get_balance().pair_first()<br>raw_reserve(count)<br>dict~idict_add?(...)<br>dict~udict::delete_get_max()<br>t~tpush(triple(x, y, z))<br>s.slice_bits()<br>~dump(x)<br>...'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'getLogicalTime()<br>listGetHead(l)<br>getMyOriginalBalance()<br>reserveToncoinsOnBalance(count)<br>dict.iDictSetIfNotExists(...)<br>dict.uDictDeleteLastAndGet()<br>t.tuplePush([x, y, z])<br>s.getRemainingBitsCount()<br>debugPrint(x)<br>...'}}></code></td>
  </tr>
  </tbody>
</table>

이전의 "stdlib.fc"는 여러 파일로 분할되었습니다: common.tolk, tvm-dicts.tolk 등.

여기에서 계속: [Tolk vs FunC: standard library](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib).

<h3 className="cmp-func-tolk-header">
  ✅ stdlib가 이제 GitHub에서 다운로드하지 않고 내장됨
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <ol style={{margin: 0}}>
        <li>GitHub에서 stdlib.fc 다운로드</li>
        <li>프로젝트에 저장</li>
        <li>`#include "stdlib.fc";`</li>
        <li>표준 함수 사용</li>
      </ol>
    </td>
    <td>
      <ol style={{margin: 0}}>
        <li>표준 함수 사용</li>
      </ol>
    </td>
  </tr>
  </tbody>
</table>

Tolk에서 stdlib는 배포판의 일부입니다. "언어, 컴파일러, stdlib" 세 가지를 함께 유지하는 것이 릴리스 주기를 유지하는 유일하게 올바른 방법이기 때문에 표준 라이브러리는 분리할 수 없습니다.

다음과 같이 작동합니다. Tolk 컴파일러는 표준 라이브러리를 찾는 방법을 알고 있습니다. 사용자가 apt 패키지를 설치했다면 stdlib 소스도 다운로드되어 하드 디스크에 존재하므로 컴파일러가 시스템 경로로 찾습니다. 사용자가 WASM 래퍼를 사용한다면 tolk-js에 의해 제공됩니다. 등등.

표준 라이브러리는 여러 파일로 나뉩니다: `common.tolk`(가장 일반적인 함수들), `gas-payments.tolk`(가스 수수료 계산), `tvm-dicts.tolk` 등. `common.tolk`의 함수들은 항상 사용 가능합니다(컴파일러가 암묵적으로 임포트). 다른 파일들은 명시적으로 임포트해야 합니다:

```tolk
import "@stdlib/tvm-dicts"   // ".tolk" optional

...
var dict = createEmptyDict();
dict.iDictSet(...);
```

"사용하는 것을 임포트하세요" 규칙을 명심하세요, `@stdlib/...` 파일에도 적용됩니다("common.tolk"만 예외).

JetBrains IDE 플러그인은 stdlib 폴더를 자동으로 발견하고 타이핑할 때 필요한 임포트를 삽입합니다.

<h3 className="cmp-func-tolk-header">
  ✅ 논리 연산자 `&& ||`, 논리 NOT `!`
</h3>

FunC에는 비트 연산자 `~ & | ^`만 있습니다. 처음 시작하는 개발자들은 "좋아, 논리 연산자가 없으니 같은 방식으로 비트 연산자를 사용하면 되겠지"라고 생각하여 자주 오류를 범합니다. 연산자 동작이 완전히 다르기 때문입니다:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>`a & b`</th>
    <th>`a && b`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>때로는 동일:</td></tr>
  <tr>
    <td><code>{'0 & X = 0'}</code></td>
    <td><code>{'0 & X = 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'-1 & X = -1'}</code></td>
    <td><code>{'-1 & X = -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>하지만 일반적으로는 그렇지 않음:</td></tr>
  <tr>
    <td><code>{'1 & 2 = 0'}</code></td>
    <td><code>{'1 && 2 = -1 (true)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>`~ found`</th>
    <th>`!found`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>때로는 동일:</td></tr>
  <tr>
    <td><code>{'true (-1) → false (0)'}</code></td>
    <td><code>{'-1 → 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'false (0) → true (-1)'}</code></td>
    <td><code>{'0 → -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>하지만 일반적으로는 그렇지 않음:</td></tr>
  <tr>
    <td><code>{'1 → -2'}</code></td>
    <td><code>{'1 → 0 (false)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>condition & f()</code></th>
    <th><code>condition && f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code>는 항상 호출됨</td>
    <td><code className="inline">f()</code>는 <code className="inline">condition</code>이 참일 때만 호출됨</td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>condition | f()</code></th>
    <th><code>condition || f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code>는 항상 호출됨</td>
    <td><code className="inline">f()</code>는 <code className="inline">condition</code>이 거짓일 때만 호출됨</td>
  </tr>
  </tbody>
</table>

Tolk는 논리 연산자를 지원합니다. 이들은 익숙한 대로 정확히 작동합니다(오른쪽 열). 현재로서는 `&&`와 `||`가 때때로 최적화되지 않은 Fift 코드를 생성하지만, 향후 Tolk 컴파일러가 이 경우에 더 똑똑해질 것입니다. 이는 무시할 만하므로 다른 언어처럼 사용하시면 됩니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'if (~ found?)'}</code></td>
    <td><code>{'if (!found)'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'if (~ found?) {<br>    if (cs~load_int(32) == 0) {<br>        ...<br>    }<br>}'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'if (!found && cs.loadInt(32) == 0) {<br>    ...<br>}'}}></code></td>
  </tr>
  <tr>
    <td><code>{'ifnot (cell_null?(signatures))'}</code></td>
    <td><code>{'if (signatures != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'elseifnot (eq_checksum)'}</code></td>
    <td><code>{'else if (!eqChecksum)'}</code></td>
  </tr>
  </tbody>
</table>

키워드 `ifnot`과 `elseifnot`는 이제 논리 NOT이 있기 때문에 제거되었습니다(최적화를 위해 Tolk 컴파일러는 `IFNOTJMP`를 생성합니다). 키워드 `elseif`는 전통적인 `else if`로 대체되었습니다.

불리언 `true`가 `as int`로 변환되면 1이 아닌 -1이라는 점을 기억하세요. 이는 TVM 표현입니다.

<h3 className="cmp-func-tolk-header">
  ✅ 틸다 `~` 메서드 없음, 대신 `mutate` 키워드
</h3>

이 변경사항은 매우 크기 때문에 별도의 페이지에서 설명됩니다: [Tolk mutability](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability).

<hr />

<h3>Tolk vs FunC 가스 소비</h3>

:::caution 요약
Tolk의 가스 소비는 FunC의 예상치 못한 인수 셔플링을 수정하기 때문에 약간 더 높을 수 있습니다. 실제로는 무시할 만한 수준입니다.
향후 Tolk 컴파일러는 셔플링 문제를 피하면서도 스택 조작을 최소화하도록 인수를 재정렬하는 데 충분히 똑똑해질 것입니다.
:::

FunC 컴파일러는 어셈블리 함수를 호출할 때 예상치 못하게 인수를 섞을 수 있습니다:

```
some_asm_function(f1(), f2());
```

때로는 `f2()`가 `f1()` 전에 호출될 수 있으며, 이는 예상치 못한 일입니다.
이 동작을 수정하기 위해 `#pragma compute-asm-ltr`를 지정하여 인수가 항상 ltr 순서로 평가되도록 강제할 수 있습니다.
이는 실험적이었고 따라서 기본적으로 꺼져 있었습니다.

이 프라그마는 스택의 인수를 재정렬하여 종종 프라그마 없이보다 더 많은 스택 조작이 필요합니다.
다시 말해, 예상치 못한 동작은 수정하지만 가스 소비가 증가합니다.

Tolk는 이 프라그마가 켜진 것처럼 정확히 스택에 인수를 넣습니다.
따라서 프라그마를 사용하지 않았을 때보다 때때로 가스 소비가 더 높습니다.
물론 Tolk에는 셔플링 문제가 없습니다.

향후 Tolk 컴파일러는 셔플링 문제를 피하면서도 스택 조작을 최소화하도록 인수를 재정렬하는 데 충분히 똑똑해질 것입니다.
