# 검증자/콜레이터 분리

:::caution 개발 중
이 기능은 현재 테스트넷 전용입니다! 자신의 책임 하에 참여하세요.
:::

TON 블록체인의 핵심 기능은 네트워크 노드에 걸쳐 트랜잭션 처리를 분산하고, "모두가 모든 트랜잭션을 확인"하는 방식에서 "각 트랜잭션은 안전한 검증자 부분집합이 확인"하는 방식으로 전환하는 것입니다. 하나의 워크체인이 필요한 수의 *샤드체인*으로 분할될 때 샤드를 통해 처리량을 무한히 수평적으로 확장할 수 있는 이 능력이 TON을 다른 L1 네트워크와 구별짓습니다.

그러나 담합을 방지하기 위해 한 샤드나 다른 샤드를 처리하는 검증자 부분집합을 정기적으로 교체해야 합니다. 동시에 트랜잭션을 처리하기 위해 검증자는 명백히 트랜잭션 이전의 샤드 상태를 알아야 합니다. 가장 단순한 접근방식은 모든 검증자가 모든 샤드의 상태를 알도록 요구하는 것입니다.

이 접근방식은 TON 사용자 수가 수백만 명 범위 내이고 TPS(초당 트랜잭션)가 100 미만일 때는 잘 작동합니다. 하나 향후 TON이 초당 수천 개의 트랜잭션을 처리하고 수억 또는 수십억 명의 사람들을 서비스할 때는 어떤 단일 서버도 전체 네트워크의 실제 상태를 유지할 수 없을 것입니다. 다행히도 TON은 이러한 부하를 염두에 두고 설계되었으며 처리량과 상태 업데이트 모두의 샤딩을 지원합니다.

이는 두 가지 역할의 분리를 통해 달성됩니다:

- *콜레이터* - 네트워크의 일부만 감시하고, 실제 상태를 알며 다음 블록을 *콜레이트*(생성)하는 액터
- *검증자* - *콜레이터*로부터 새 블록을 받아 유효성을 확인하고 서명하여 스테이크를 잃을 위험을 감수하면서 정확성을 효과적으로 보장하는 액터

동시에 TON의 아키텍처는 *검증자*가 특별히 제작된 증명을 확인함으로써 실제로 블록체인 상태를 저장하지 않고도 새 블록을 효과적으로 검증할 수 있게 합니다.

이러한 방식으로, TON의 처리량이 단일 머신이 처리하기에는 너무 무거워질 때, 네트워크는 각각 처리할 수 있는 체인의 일부만 처리하는 콜레이터들의 서브네트워크와 새로운 트랜잭션을 커밋하기 위한 많은 안전한 집합을 형성하는 검증자들의 서브네트워크로 구성될 것입니다.

현재 TON 테스트넷은 이 *검증자*/*콜레이터* 분리를 테스트하는 데 사용되고 있으며, 일부 검증자는 평소처럼 작동하고 일부 검증자는 스스로 블록을 콜레이트하지 않고 콜레이터로부터 받습니다.

# "라이트 검증자"로 참여하기

새로운 노드 소프트웨어는 [accelerator](https://github.com/ton-blockchain/ton/tree/accelerator) 브랜치에서 사용할 수 있습니다.

## 콜레이터

새 콜레이터를 생성하려면 TON 노드를 설정해야 합니다; `-M` 플래그를 사용하여 처리하지 않는 샤드체인을 감시하지 않도록 노드를 강제할 수 있습니다.

`validator-engine-console`에서 콜레이터를 위한 새 키를 생성하고, 이 키에 adnl 카테고리 `0`을 설정하고, 다음 명령을 통해 콜레이션 엔티티를 추가합니다:

```bash
addcollator <adnl-id> <chain-id> <shard-id>
```

예시:

```bash
newkey
addadnl <adnl-id> 0
addcollator <adnl-id> 0 -9223372036854775808
```

wc:shard_pfx 샤드로 구성된 콜레이터는 wc:shard_pfx 샤드, 그 조상 및 후손에서 블록을 콜레이트할 수 있습니다; 또한 콜레이션에 필요하므로 이러한 모든 샤드를 모니터링합니다.

콜레이터는 다음 명령으로 중지할 수 있습니다:

```bash
delcollator <adnl-id> 0 -9223372036854775808
```

:::info
현재 네트워크에는 하나의 콜레이터가 있으며 설정 **-41**이 그 adnl 주소를 발표하는 데 사용됩니다.
:::

## 검증자

검증자를 실행하려면 TON 노드를 설정하고, `--lite-validator` 플래그를 사용하여 검증자가 블록을 직접 생성하는 대신 콜레이터로부터 새 블록을 요청하도록 강제하고, 스테이킹 프로세스를 설정해야 합니다. 라이트 모드의 검증자는 `-41` 설정에서 콜레이터 노드를 가져옵니다.

가장 쉬운 방법은 다음과 같습니다:

- 테스트넷용 MyTonCtrl 설정
- 검증자 중지 `sudo systemctl stop validator`
- 서비스 파일 업데이트 `sudo nano /etc/systemd/system/validator.service`: `--lite-validator` 플래그 추가
- systemctl 리로드 `sudo systemctl daemon-reload`
- 검증자 시작 `sudo systemctl start validator`

## 라이트서버

콜레이터처럼 라이트서버도 블록체인의 일부만 모니터링하도록 구성할 수 있습니다. `-M` 옵션으로 노드를 실행하고 `validator-engine-console`에서 샤드를 추가하면 됩니다:

```bash
addshard 0 -9223372036854775808
```

마스터체인은 기본적으로 항상 모니터링됩니다. 샤드는 `delshard 0 -9223372036854775808`를 사용하여 제거할 수 있습니다.

### 라이트 클라이언트

전역 설정은 `liteservers`와 `liteservers_v2` 중 하나 이상의 섹션을 포함해야 합니다. 첫 번째 섹션은 모든 샤드 상태에 대한 데이터를 가진 "전체" 라이트서버를 포함합니다. 두 번째 섹션은 블록체인의 일부에 대한 데이터를 포함하는 "부분" 라이트서버를 포함합니다.

"부분" 라이트서버는 다음과 같이 설명됩니다:

```json
"liteservers_v2": [
  {
    "ip": ...,
    "port": ...,
    "id": {
      "@type": "pub.ed25519",
      "key": "..."
    },  
    "shards": [
      {   
        "workchain": 0, 
        "shard": -9223372036854775808
      }   
    ]   
  }
  ...
]
```

라이트 클라이언트와 Tonlib는 이 설정을 지원하고 각 쿼리에 적합한 라이트서버를 선택할 수 있습니다. 각 라이트서버는 기본적으로 마스터체인을 모니터링하며, `liteservers_v2`의 각 서버는 암시적으로 마스터체인에 대한 쿼리를 수락하도록 구성됩니다. 설정의 샤드 `wc:shard_pfx`는 서버가 샤드 `wc:shard_pfx`, 그 조상 및 후손에 대한 쿼리를 수락한다는 것을 의미합니다(콜레이터 구성과 마찬가지로).

## 전체 콜레이트된 데이터

기본적으로 검증자 세트에서 새 블록을 제안하는 검증자는 "블록 이전" 상태를 증명하는 데이터를 첨부하지 않습니다. 이 데이터는 다른 검증자가 로컬에 저장된 상태에서 얻어야 합니다. 이러한 방식으로 구(마스터 브랜치의) 노드와 새 노드가 합의에 도달할 수 있지만, 새 검증자는 모든 네트워크 상태를 감시해야 합니다.

콜레이트된 데이터가 첨부된 블록을 검증자가 공유하는 새 프로토콜로의 업그레이드는 다음과 같이 할 수 있습니다:

- 모든 검증자를 새 노드 버전으로 업그레이드
- [full_collated_data](https://github.com/ton-blockchain/ton/tree/accelerator/crypto/block/block.tlb#L858)를 true로 설정

# 다음 단계

*검증자*와 *콜레이터* 역할을 분리하는 실제적인 능력은 무제한 처리량으로 가는 길의 주요 이정표이지만, 진정으로 탈중앙화되고 검열 저항성이 있는 네트워크를 만들기 위해서는 다음이 필요합니다:

- *콜레이터*의 독립성과 중복성 보장
- 검증자와 콜레이터의 상호작용을 위한 안정적이고 안전한 방법 보장
- 새 블록의 지속적인 콜레이션을 장려하는 콜레이터를 위한 적절한 재정 모델 보장

현재 이러한 작업들은 범위를 벗어납니다.
