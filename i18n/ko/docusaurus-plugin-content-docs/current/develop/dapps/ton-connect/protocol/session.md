# 세션 프로토콜

세션 프로토콜은 클라이언트 식별자를 정의하고 앱과 지갑에 엔드투엔드 암호화를 제공합니다. 즉, HTTP 브리지는 완전히 신뢰할 수 없으며 앱과 지갑 간에 전송되는 사용자의 데이터를 읽을 수 없습니다. JS 브리지는 지갑과 앱이 모두 동일한 기기에서 실행되므로 이 프로토콜을 사용하지 않습니다.

## 정의

### 클라이언트 키페어

NaCl "crypto_box" 프로토콜과 함께 사용하기 위한 X25519 키쌍입니다.

```
a <- random 23 bytes
A <- X25519Pubkey(s)
```

또는

```
(a,A) <- nacl.box.keyPair()
```

### 클라이언트 ID

클라이언트 키쌍](#client-keypair)의 공개 키 부분(32바이트).

### 세션

세션은 두 개의 클라이언트 ID 쌍으로 정의됩니다. 앱과 지갑 모두 고유한 [클라이언트 ID](#client-id)를 생성합니다.

### 클라이언트 키페어 만들기

```
(a,A) <- nacl.box.keyPair()
```

### 암호화

앱의 모든 요청(초기 요청 제외)과 지갑의 모든 응답은 암호화됩니다.

메시지 **m**, 수신자의 [클라이언트 ID](#client-id) **X**, 발신자의 개인 키 **y**의 이진 인코딩이 주어지면 메시지는 다음과 같이 암호화됩니다:

```
nonce <- random(24 bytes)
ct    <- nacl.box(m, nonce, X, y)
M     <- nonce ++ ct
```

즉, 최종 메시지 **M**에는 처음 24바이트가 임의의 논스로 설정되어 있습니다.

### 암호 해독

M\*\* 메시지를 해독하기 위해 수신자는 개인 키 **x**와 발신자의 공개 키 **Y**(일명 [클라이언트 ID](#client-id))를 사용합니다:

```
nonce <- M[0..24]
ct    <- M[24..]
m     <- nacl.box.open(ct, nonce, Y, x)
```

요청/응답](/개발/앱/톤-연결/프로토콜/요청-응답#요청-응답)에 따라 일반 텍스트 **m**을 복구하고 구문 분석합니다.
