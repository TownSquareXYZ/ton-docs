# 리터럴 및 식별자

## 숫자 리터럴

FunC는 10진수 및 16진수 리터럴을 허용합니다(선행 0은 허용됨).

예를 들어, `0`, `123`, `-17`, `00987`, `0xef`, `0xEF`, `0x0`, `-0xfFAb`, `0x0001`, `-0`, `-0x0`은 유효한 숫자 리터럴입니다.

## 문자열 리터럴

FunC의 문자열은 `"이것은 문자열입니다"`와 같이 큰따옴표 `"`로 따옵니다.\n`와 같은 특수 기호 및 여러 줄 문자열은 지원되지 않습니다.
선택적으로 문자열 리터럴은 `"string"u\`와 같이 뒤에 유형을 지정할 수 있습니다.

지원되는 문자열 유형은 다음과 같습니다:

- 유형 없이 - ASCII 문자열로 슬라이스 const를 정의하는 데 사용됩니다.
- s\` - 원시 슬라이스 const를 그 내용(16진수 인코딩 및 선택적으로 비트 패딩)으로 정의합니다.
- a`-지정된 주소에서 `MsgAddressInt\` 구조체를 포함하는 슬라이스 const를 생성합니다.
- u\`-제공된 ASCII 문자열의 16진수 값에 해당하는 int const를 생성합니다.
- h\` - 문자열의 SHA256 해시의 첫 32비트인 int const를 생성합니다.
- H\` - 문자열의 SHA256 해시 256비트 모두인 int const를 생성합니다.
- c\`- 문자열의 crc32 값인 int const를 생성합니다.

예를 들어, 다음 값은 해당 const를 생성합니다:

- "문자열"`은 `x{737472696e67}\` 슬라이스 const가 됩니다.
- "abcdef"s`는 `x{abcdef}\` 슬라이스 const가 됩니다.
- `"Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF"a`가 `x{9FE6666666666666666666666666666666666666666666666666666666666666667_}` 슬라이스 const (`addr_std$10 anycast:none$0 workchain_id:int8=0xFF 주소:bits256=0x33...33`)가 됩니다.
- "NstK"u`가 `0x4e73744b\`가 되는 int const
- "transfer(slice, int)"h`는 `0x7a62e8a8\` int const가 됩니다.
- `"transfer(slice, int)"H`는 `0x7a62e8a8ebac41bd6de16c65e7be363bc2d2cbc6a0873778dead4795c13db979` int const가 됩니다.
- "transfer(slice, int)"c`는 `2235694568\` int const가 됩니다.

## 식별자

FunC는 매우 다양한 종류의 식별자(함수 및 변수 이름)를 허용합니다. 즉, 특수 기호 `;`, `,`, `(`, `)`, ``(공백 또는 탭), `~`, `...`를 포함하지 않는 모든 (한 줄) 문자열입니다.', 주석이나 문자열 리터럴(`"` 포함)로 시작하지 않고, 숫자 리터럴이 아니며, 밑줄 `_`이 아니고, 키워드가 아닌 문자열은 유효한 식별자입니다(단, `` `로 시작하는 경우 동일한 ` `로 끝나야 하며 이 두 가지를 제외한 다른 ` \`\`를 포함할 수 없다는 예외가 있습니다).

또한 함수 정의의 함수 이름은 '.`또는`~\`로 시작할 수 있습니다.

예를 들어, 이는 유효한 식별자입니다:

- 쿼리`, `쿼리'`, `쿼리''\`
- elem0`, `elem1`, `elem2\`
- 체크\`
- `_내부_값`
- `메시지_발견?`
- `GET_PUBKEYS&SIGNATURES`
- `dict::udict_set_builder`
- `_+_`(접두사 표기법에서 `(int, int) -> int` 타입의 표준 덧셈 연산자, 이미 정의되어 있지만)
- '치명적!

변수 이름 끝에 \`\`\`는 일반적으로 이전 값의 일부 수정된 버전이 도입될 때 사용됩니다. 예를 들어, 해시맵 조작을 위한 거의 모든 수정 내장 프리미티브(접두사 `~`가 붙은 것 제외)는 해시맵을 가져와서 필요한 경우 다른 데이터와 함께 새 버전의 해시맵을 반환합니다. 이러한 값의 이름은 같은 이름에 접미사 `'`를 붙이면 편리합니다.

접미사 `?`는 일반적으로 부울 변수(TVM에는 부울 유형이 내장되어 있지 않습니다. 부울은 정수로 표현됩니다: 0은 거짓, -1은 참)에 사용되거나 일반적으로 작업의 성공을 나타내는 일부 플래그를 반환하는 함수([stdlib.fc](/develop/func/stdlib)의 `udict_get?`처럼)에 사용됩니다.

유효하지 않은 식별자입니다:

- '(첫)항목 가져가기'
- `"not_a_string`
- `msg.sender`
- 보내기_메시지,다음_종료\`
- `_`

유효한 식별자의 흔하지 않은 몇 가지 예입니다:

- `123validname`
- `2+2=2*2`
- `-알수있는이름`
- `0xefefhahaha`
- `{hehehe}`
- ``pa{--}in"`aaa`"``

이 또한 유효하지 않은 식별자입니다:

- ``pa;;in"`aaa`"``(`;`는 금지되어 있으므로)
- `{-aaa-}`
- `aa(bb`
- 123\`(숫자)

또한 FunC에는 뒷따옴표 ` `로 따옴표로 묶인 특수한 유형의 식별자가 있습니다.
따옴표 안에는 `\n`와 따옴표 자체를 제외한 모든 기호가 허용됩니다.

예를 들어, `나도 변수입니다``는 유효한 식별자이며, `여기에는 기호 ; ~ ()도 허용됩니다...\`\`도 허용됩니다.

## 상수

FunC를 사용하면 컴파일 중에 대체되고 미리 계산되는 컴파일 시간 상수를 정의할 수 있습니다.

상수는 `const 선택적 유형 식별자 = 값 또는 표현식;`으로 정의됩니다.

'옵션 유형'을 사용하면 특정 유형의 상수를 강제로 적용하고 가독성을 높일 수 있습니다.

현재 `int` 및 `슬라이스` 유형이 지원됩니다.

'값 또는 표현식'은 리터럴 또는 리터럴과 상수의 사전 계산 가능한 표현식일 수 있습니다.

예를 들어 상수는 다음과 같이 정의할 수 있습니다:

- `const int101 = 101;`은 숫자 리터럴 `101`에 해당하는 `int101` 상수를 정의합니다.
- `const str1 = "const1", str2 = "aabbcc"s;`는 해당 문자열과 동일한 두 개의 상수를 정의합니다.
- `const int int240 = ((int1 + int2) * 10) << 3;`는 계산 결과와 동일한 `int240` 상수를 정의합니다.
- `const slice str2r = str2;`는 `str2` 상수의 값과 동일한 `str2r` 상수를 정의합니다.

컴파일 중에 숫자 상수를 대체하기 때문에 컴파일 중에 수행되는 모든 최적화 및 사전 계산이 성공적으로 수행됩니다(인라인으로 상수를 정의하는 기존 방식과 달리).
