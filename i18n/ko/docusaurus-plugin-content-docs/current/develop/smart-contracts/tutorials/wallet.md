---
description: ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” ì§€ê°‘, íŠ¸ëœì­ì…˜, ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì™„ë²½í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ë“œë¦½ë‹ˆë‹¤.
---

'@theme/Tabs'ì—ì„œ Tabs ê°€ì ¸ì˜¤ê¸°;
'@theme/TabItem'ì—ì„œ TabItem ê°€ì ¸ì˜¤ê¸°;

# ì›”ë › ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì‘ì—…

## ğŸ‘‹ ì†Œê°œ

ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ê°œë°œì„ ì‹œì‘í•˜ê¸° ì „ì— TONì—ì„œ ì§€ê°‘ê³¼ íŠ¸ëœì­ì…˜ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì•Œì•„ë‘ëŠ” ê²ƒì€ í•„ìˆ˜ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ì§€ì‹ì€ ê°œë°œìê°€ íŠ¹ì • ê°œë°œ ì‘ì—…ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ ì§€ê°‘, íŠ¸ëœì­ì…˜, ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ ê°„ì˜ ìƒí˜¸ ì‘ìš©ì„ ì´í•´í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.

ì´ ì„¹ì…˜ì—ì„œëŠ” ê°œë°œ ì›Œí¬í”Œë¡œìš°ë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ ë¯¸ë¦¬ êµ¬ì„±ëœ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì‘ì—…ì„ ë§Œë“œëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤. ì´ íŠœí† ë¦¬ì–¼ì˜ ë¶„ì„ì— í•„ìš”í•œ ëª¨ë“  ì°¸ì¡° ìë£ŒëŠ” ì°¸ì¡° ì¥ì— ìˆìŠµë‹ˆë‹¤.

## ğŸ’¡ ì „ì œ ì¡°ê±´

ì´ íŠœí† ë¦¬ì–¼ì€ ìë°”ìŠ¤í¬ë¦½íŠ¸, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸, ê³¨ë‘ì— ëŒ€í•œ ê¸°ë³¸ ì§€ì‹ì´ í•„ìš”í•©ë‹ˆë‹¤. ë˜í•œ, ìµœì†Œ 3í†¤(ê±°ë˜ì†Œ ê³„ì •, ë¹„ìœ„íƒ ì§€ê°‘ ë˜ëŠ” í…”ë ˆê·¸ë¨ ë´‡ ì§€ê°‘ì„ ì‚¬ìš©í•˜ì—¬ ë³´ê´€í•  ìˆ˜ ìˆìŒ)ì„ ë³´ìœ í•˜ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì´ íŠœí† ë¦¬ì–¼ì„ ì´í•´í•˜ë ¤ë©´ [ì…€](/í•™ìŠµ/ê°œìš”/ì…€), [TONì˜ ì£¼ì†Œ](/í•™ìŠµ/ê°œìš”/ì£¼ì†Œ), [ë¸”ë¡ì²´ì¸ì˜ ë¸”ë¡ì²´ì¸](/í•™ìŠµ/ê°œìš”/í†¤ë¸”ë¡ì²´ì¸)ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì´í•´ê°€ í•„ìš”í•©ë‹ˆë‹¤.

:::info ë©”ì¸ë„· ê°œë°œì€ í•„ìˆ˜\
TON í…ŒìŠ¤íŠ¸ë„·ìœ¼ë¡œ ì‘ì—…í•˜ë©´ ì¢…ì¢… ë°°í¬ ì˜¤ë¥˜, íŠ¸ëœì­ì…˜ ì¶”ì ì˜ ì–´ë ¤ì›€, ë¶ˆì•ˆì •í•œ ë„¤íŠ¸ì›Œí¬ ê¸°ëŠ¥ ë“±ì´ ë°œìƒí•©ë‹ˆë‹¤. ë”°ë¼ì„œ ëŒ€ë¶€ë¶„ì˜ ê°œë°œì„ TON ë©”ì¸ë„·ì—ì„œ ì™„ë£Œí•˜ë©´ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í”¼í•  ìˆ˜ ìˆìœ¼ë©°, íŠ¸ëœì­ì…˜ ìˆ˜ë¥¼ ì¤„ì—¬ ìˆ˜ìˆ˜ë£Œë¥¼ ìµœì†Œí™”í•˜ëŠ” ë° ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

## ì†ŒìŠ¤ ì½”ë“œ

ì´ íŠœí† ë¦¬ì–¼ì— ì‚¬ìš©ëœ ëª¨ë“  ì½”ë“œ ì˜ˆì œëŠ” ë‹¤ìŒ [GitHub ë¦¬í¬ì§€í† ë¦¬](https://github.com/aSpite/wallet-tutorial)ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## âœï¸ ì‹œì‘í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ê²ƒ

- NodeJSê°€ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
- íŠ¹ì • í†¤ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•„ìš”í•˜ë©° ë‹¤ìŒì´ í¬í•¨ë©ë‹ˆë‹¤: í†¤/í†¤ 13.5.1+, í†¤/ì½”ì–´ 0.49.2+ ë° @í†¤/í¬ë¦½í†  3.2.0+.

**ì˜µì…˜**: JS ëŒ€ì‹  GOë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ [tonutils-go](https://github.com/xssnick/tonutils-go) ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ GoLand IDEë¥¼ ì„¤ì¹˜í•˜ì—¬ TONì—ì„œ ê°œë°œì„ ì§„í–‰í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì´ íŠœí† ë¦¬ì–¼ì—ì„œ GO ë²„ì „ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```bash
npm i --save @ton/ton @ton/core @ton/crypto
```

</TabItem>
<TabItem value="go" label="Golang">

```bash
go get github.com/xssnick/tonutils-go
go get github.com/xssnick/tonutils-go/adnl
go get github.com/xssnick/tonutils-go/address
```

</TabItem>
</Tabs>

## âš™ í™˜ê²½ ì„¤ì •

TypeScript í”„ë¡œì íŠ¸ë¥¼ ë§Œë“¤ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆœì„œëŒ€ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤:

1. ë¹ˆ í´ë”ë¥¼ ë§Œë“­ë‹ˆë‹¤(ì´ë¦„ì€ WalletsTutorialìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤).
2. CLIë¥¼ ì‚¬ìš©í•˜ì—¬ í”„ë¡œì íŠ¸ í´ë”ë¥¼ ì—½ë‹ˆë‹¤.
3. ë‹¤ìŒ ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ í”„ë¡œì íŠ¸ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤:

```bash
npm init -y
npm install typescript @types/node ts-node nodemon --save-dev
npx tsc --init --rootDir src --outDir build \ --esModuleInterop --target es2020 --resolveJsonModule --lib es6 \ --module commonjs --allowJs true --noImplicitAny false --allowSyntheticDefaultImports true --strict false
```

:::info
ë‹¤ìŒ í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ `ts-node`ëŠ” ì‚¬ì „ ì»´íŒŒì¼ ì—†ì´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œë¥¼ ì§ì ‘ ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. nodemon\`ì€ ë””ë ‰í† ë¦¬ì˜ íŒŒì¼ ë³€ê²½ì´ ê°ì§€ë˜ë©´ ë…¸ë“œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ìë™ìœ¼ë¡œ ì¬ì‹œì‘í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
:::

```json
  "files": [
    "\",
    "\"
  ]
```

5. ê·¸ëŸ° ë‹¤ìŒ í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— ë‹¤ìŒ ë‚´ìš©ìœ¼ë¡œ `nodemon.json` ì„¤ì •ì„ ìƒì„±í•©ë‹ˆë‹¤:

```json
{
  "watch": ["src"],
  "ext": ".ts,.js",
  "ignore": [],
  "exec": "npx ts-node ./src/index.ts"
}
```

6. í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•  ë•Œ ì¶”ê°€ë˜ëŠ” "test" ëŒ€ì‹  ì´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ `package.json`ì— ì¶”ê°€í•©ë‹ˆë‹¤:

```json
"start:dev": "npx nodemon"
```

7. í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— `src` í´ë”ë¥¼ ë§Œë“¤ê³  ì´ í´ë”ì— `index.ts` íŒŒì¼ì„ ë§Œë“­ë‹ˆë‹¤.
8. ë‹¤ìŒìœ¼ë¡œ ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤:

```ts
async function main() {
  console.log("Hello, TON!");
}

main().finally(() => console.log("Exiting..."));
```

9. í„°ë¯¸ë„ì„ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤:

```bash
npm run start:dev
```

10. ë§ˆì§€ë§‰ìœ¼ë¡œ ì½˜ì†” ì¶œë ¥ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.

![](/img/docs/how-to-wallet/wallet_1.png)

:::tip ë¸”ë£¨í”„ë¦°íŠ¸
TON ì»¤ë®¤ë‹ˆí‹°ëŠ” ëª¨ë“  ê°œë°œ í”„ë¡œì„¸ìŠ¤(ë°°í¬, ì»¨íŠ¸ë™íŠ¸ ì‘ì„±, í…ŒìŠ¤íŠ¸)ë¥¼ ìë™í™”í•˜ëŠ” í›Œë¥­í•œ ë„êµ¬ì¸ [ë¸”ë£¨í”„ë¦°íŠ¸](https://github.com/ton-org/blueprint)ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì €í¬ëŠ” ì´ëŸ¬í•œ ê°•ë ¥í•œ ë„êµ¬ê°€ í•„ìš”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ìœ„ì˜ ì§€ì¹¨ì„ ë”°ë¥´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
:::

\*\*ì„ íƒ ì‚¬í•­: \*\* Golangì„ ì‚¬ìš©í•  ë•ŒëŠ” ë‹¤ìŒ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”:

1. GoLand IDEë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤.
2. ë‹¤ìŒ ë‚´ìš©ì„ ì‚¬ìš©í•˜ì—¬ í”„ë¡œì íŠ¸ í´ë”ì™€ `go.mod` íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤(í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ Go ë²„ì „ì´ ì˜¤ë˜ëœ ê²½ìš° ì´ ê³¼ì •ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ **ë²„ì „**ì„ ë³€ê²½í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤):

```
module main

go 1.20
```

3. í„°ë¯¸ë„ì— ë‹¤ìŒ ëª…ë ¹ì„ ì…ë ¥í•©ë‹ˆë‹¤:

```bash
go get github.com/xssnick/tonutils-go
```

4. í”„ë¡œì íŠ¸ì˜ ë£¨íŠ¸ì— ë‹¤ìŒ ë‚´ìš©ìœ¼ë¡œ `main.go` íŒŒì¼ì„ ë§Œë“­ë‹ˆë‹¤:

```go
package main

import (
	"log"
)

func main() {
	log.Println("Hello, TON!")
}
```

5. go.mod`ì—ì„œ ëª¨ë“ˆì˜ ì´ë¦„ì„ `ë©”ì¸\`ìœ¼ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
6. í„°ë¯¸ë„ì— ì¶œë ¥ì´ í‘œì‹œë  ë•Œê¹Œì§€ ìœ„ì˜ ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

:::info
GoLandëŠ” ë¬´ë£Œê°€ ì•„ë‹ˆë¯€ë¡œ ë‹¤ë¥¸ IDEë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì´ ë°©ë²•ì„ ì„ í˜¸í•©ë‹ˆë‹¤.
:::

:::warning ì¤‘ìš”

ë˜í•œ íŠ¹ì • ì½”ë“œ ì„¹ì…˜ì— í•„ìš”í•œ ê°€ì ¸ì˜¤ê¸°ë§Œ ê°ê°ì˜ ìƒˆ ì„¹ì…˜ì— ì§€ì •ë˜ë©° ìƒˆ ê°€ì ¸ì˜¤ê¸°ë¥¼ ì¶”ê°€í•˜ê³  ì´ì „ ê°€ì ¸ì˜¤ê¸°ì™€ ê²°í•©í•´ì•¼ í•©ë‹ˆë‹¤(\
::):

## ğŸš€ ì‹œì‘í•˜ì!

ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” TON ë¸”ë¡ì²´ì¸ì—ì„œ ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ì§€ê°‘(ë²„ì „ 3ê³¼ 4)ì„ ì•Œì•„ë³´ê³  í•´ë‹¹ ì§€ê°‘ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì‘ë™ ë°©ì‹ì— ëŒ€í•´ ì•Œì•„ë³¼ ê²ƒì…ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ê°œë°œìëŠ” TON í”Œë«í¼ì˜ ë‹¤ì–‘í•œ íŠ¸ëœì­ì…˜ ìœ í˜•ì„ ë” ì˜ ì´í•´í•˜ì—¬ íŠ¸ëœì­ì…˜ì„ ìƒì„±í•˜ê³ , ë¸”ë¡ì²´ì¸ì— ì „ì†¡í•˜ê³ , ì§€ê°‘ì„ ë°°í¬í•˜ê³ , ê²°êµ­ì—ëŠ” ë¶€í•˜ê°€ ë†’ì€ ì§€ê°‘ìœ¼ë¡œ ì‘ì—…í•  ìˆ˜ ìˆê²Œ ë  ê²ƒì…ë‹ˆë‹¤.

ì €í¬ì˜ ì£¼ìš” ì„ë¬´ëŠ” @ton/ton, @ton/core, @ton/crypto(ì™¸ë¶€ ë©”ì‹œì§€, ë‚´ë¶€ ë©”ì‹œì§€, ì„œëª… ë“±)ì— ëŒ€í•œ ë‹¤ì–‘í•œ ê°ì²´ì™€ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ íŠ¸ëœì­ì…˜ì„ êµ¬ì¶•í•˜ì—¬ ë” í° ê·œëª¨ì˜ íŠ¸ëœì­ì…˜ì´ ì–´ë–»ê²Œ ë³´ì´ëŠ”ì§€ ì´í•´í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ê³¼ì •ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ë‘ ê°€ì§€ ì£¼ìš” ì§€ê°‘ ë²„ì „(v3 ë° v4)ì„ ì‚¬ìš©í•˜ê²Œ ë˜ëŠ”ë°, ê±°ë˜ì†Œ, ë¹„ìˆ˜íƒ ì§€ê°‘ ë° ëŒ€ë¶€ë¶„ì˜ ì‚¬ìš©ìê°€ ì´ íŠ¹ì • ë²„ì „ë§Œ ì‚¬ìš©í•œë‹¤ëŠ” ì‚¬ì‹¤ì„ ê³ ë ¤í•œ ê²ƒì…ë‹ˆë‹¤.

:::note
There may be occasions in this tutorial when there is no explanation for particular details. In these cases, more details will be provided in later stages of this tutorial.

**ì¤‘ìš”:** ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” ì§€ê°‘ ê°œë°œ ê³¼ì •ì„ ë” ì˜ ì´í•´í•˜ê¸° ìœ„í•´ [ì§€ê°‘ v3 ì½”ë“œ](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. v3 ë²„ì „ì—ëŠ” r1ê³¼ r2ë¼ëŠ” ë‘ ê°€ì§€ í•˜ìœ„ ë²„ì „ì´ ìˆë‹¤ëŠ” ì ì— ìœ ì˜í•´ì•¼ í•©ë‹ˆë‹¤. í˜„ì¬ ë‘ ë²ˆì§¸ ë²„ì „ë§Œ ì‚¬ìš© ì¤‘ì´ë¯€ë¡œ ì´ ë¬¸ì„œì—ì„œ v3ë¥¼ ì–¸ê¸‰í•  ë•ŒëŠ” v3r2ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
:::

## ğŸ’ TON ë¸”ë¡ì²´ì¸ ì§€ê°‘

TON ë¸”ë¡ì²´ì¸ì—ì„œ ì‘ë™í•˜ê³  ì‹¤í–‰ë˜ëŠ” ëª¨ë“  ì§€ê°‘ì€ ì‹¤ì œë¡œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì´ë©°, ë§ˆì°¬ê°€ì§€ë¡œ TONì—ì„œ ì‘ë™í•˜ëŠ” ëª¨ë“  ê²ƒì´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì…ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ë¸”ë¡ì²´ì¸ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë„¤íŠ¸ì›Œí¬ì— ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë°°í¬í•˜ê³  ë‹¤ì–‘í•œ ìš©ë„ì— ë§ê²Œ ì»¤ìŠ¤í„°ë§ˆì´ì§•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê¸°ëŠ¥ ë•ë¶„ì— **ì™„ì „í•œ ì§€ê°‘ ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤**.
ì˜¨í†¤ ì§€ê°‘ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” í”Œë«í¼ì´ ë‹¤ë¥¸ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ìœ í˜•ê³¼ í†µì‹ í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì§€ê°‘ í†µì‹ ì´ ì–´ë–»ê²Œ ì´ë£¨ì–´ì§€ëŠ”ì§€ ê³ ë ¤í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

### ì›”ë › ì»¤ë®¤ë‹ˆì¼€ì´ì…˜

ì¼ë°˜ì ìœ¼ë¡œ í†¤ ë¸”ë¡ì²´ì¸ì—ëŠ” 'ë‚´ë¶€'ì™€ 'ì™¸ë¶€'ì˜ ë‘ ê°€ì§€ íŠ¸ëœì­ì…˜ ìœ í˜•ì´ ìˆìŠµë‹ˆë‹¤. ì™¸ë¶€ íŠ¸ëœì­ì…˜ì€ ì™¸ë¶€ì—ì„œ ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ìœ¼ë¡œ, ì´ëŸ¬í•œ íŠ¸ëœì­ì…˜ì„ ìˆ˜ë½í•˜ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì™€ í†µì‹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì„ ë‹´ë‹¹í•˜ëŠ” í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```func
() recv_external(slice in_msg) impure {
    ;; some code
}
```

ì§€ê°‘ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê¸° ì „ì— ì§€ê°‘ì´ ì™¸ë¶€ íŠ¸ëœì­ì…˜ì„ ì–´ë–»ê²Œ ìˆ˜ë½í•˜ëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. TONì—ì„œ ëª¨ë“  ì§€ê°‘ì€ ì†Œìœ ìì˜ `ê³µê°œí‚¤`, `ì„¸ê·¸ë…¸`, `ì„œë¸Œì›”ë ›_id`ë¥¼ ë³´ìœ í•©ë‹ˆë‹¤. ì™¸ë¶€ íŠ¸ëœì­ì…˜ì„ ìˆ˜ì‹ í•˜ë©´ ì§€ê°‘ì€ `get_data()` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ê°‘ì˜ ìŠ¤í† ë¦¬ì§€ ë¶€ë¶„ì—ì„œ ë°ì´í„°ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ëª‡ ê°€ì§€ í™•ì¸ ì ˆì°¨ë¥¼ ìˆ˜í–‰í•˜ì—¬ íŠ¸ëœì­ì…˜ì„ ìˆ˜ë½í• ì§€ ì—¬ë¶€ë¥¼ ê²°ì •í•©ë‹ˆë‹¤. ì´ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ì´ ì§„í–‰ë©ë‹ˆë‹¤:

```func
() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512); ;; get signature from the message body
  var cs = in_msg;
  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));  ;; get rest values from the message body
  throw_if(35, valid_until <= now()); ;; check the relevance of the transaction
  var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
  var (stored_seqno, stored_subwallet, public_key) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256)); ;; read values from storage
  ds.end_parse(); ;; make sure we do not have anything in ds variable
  throw_unless(33, msg_seqno == stored_seqno);
  throw_unless(34, subwallet_id == stored_subwallet);
  throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));
  accept_message();
```

> ğŸ’¡ ìœ ìš©í•œ ë§í¬:
>
> ["load_bits()" in docs](/develop/func/stdlib/#load_bits)
>
> ["get_data()" in docs](/develop/func/stdlib/#load_bits)
>
> ["begin_parse()" in docs](/develop/func/stdlib/#load_bits)
>
> ["end_parse()" in docs](/develop/func/stdlib/#end_parse)
>
> ["load_int()" in docs](/develop/func/stdlib/#load_int)
>
> ["load_uint()" in docs](/develop/func/stdlib/#load_int)
>
> ["check_signature()" in docs](/develop/func/stdlib/#check_signature)
>
> ["slice_hash()" in docs](/develop/func/stdlib/#slice_hash)
>
> ["accept_message()"(/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ê³„ì•½/ê°€ì´ë“œë¼ì¸/ìˆ˜ë½)](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ê³„ì•½/ê°€ì´ë“œë¼ì¸/ìˆ˜ë½)

ì´ì œ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

### ë¦¬í”Œë ˆì´ ë³´í˜¸ - Seqno

ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ íŠ¸ëœì­ì…˜ ë¦¬í”Œë ˆì´ ë³´í˜¸ëŠ” ì–´ë–¤ íŠ¸ëœì­ì…˜ì´ ì–´ë–¤ ìˆœì„œë¡œ ì „ì†¡ë˜ì—ˆëŠ”ì§€ ì¶”ì í•˜ëŠ” íŠ¸ëœì­ì…˜ ì‹œí€€ìŠ¤ ë²ˆí˜¸ì™€ ì§ì ‘ì ìœ¼ë¡œ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤. í•˜ë‚˜ì˜ íŠ¸ëœì­ì…˜ì´ ì§€ê°‘ì—ì„œ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì€ ë§¤ìš° ì¤‘ìš”í•œë°, ì´ëŠ” ì‹œìŠ¤í…œì˜ ë¬´ê²°ì„±ì„ ì™„ì „íˆ ë¬´ë„ˆëœ¨ë¦¬ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì§€ê°‘ ë‚´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì½”ë“œë¥¼ ìì„¸íˆ ì‚´í´ë³´ë©´, ì¼ë°˜ì ìœ¼ë¡œ `seqno`ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì²˜ë¦¬ë©ë‹ˆë‹¤:

```func
throw_unless(33, msg_seqno == stored_seqno);
```

ìœ„ ì½”ë“œ ì¤„ì€ íŠ¸ëœì­ì…˜ì— ë“¤ì–´ì˜¨ `seqno`ë¥¼ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì— ì €ì¥ëœ `seqno`ì™€ ë¹„êµí•˜ì—¬ í™•ì¸í•©ë‹ˆë‹¤. ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì»¨íŠ¸ë™íŠ¸ëŠ” `33 ì¢…ë£Œ ì½”ë“œ`ì™€ í•¨ê»˜ ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ë°œì‹ ìê°€ ìœ íš¨í•˜ì§€ ì•Šì€ seqnoë¥¼ ì „ë‹¬í–ˆë‹¤ëŠ” ê²ƒì€ íŠ¸ëœì­ì…˜ ì‹œí€€ìŠ¤ì—ì„œ ì‹¤ìˆ˜ë¥¼ í–ˆë‹¤ëŠ” ì˜ë¯¸ì´ë©°, ì»¨íŠ¸ë™íŠ¸ëŠ” ì´ëŸ¬í•œ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë³´í˜¸í•©ë‹ˆë‹¤.

:::note
ë˜í•œ ì™¸ë¶€ ë©”ì‹œì§€ëŠ” ëˆ„êµ¬ë‚˜ ë³´ë‚¼ ìˆ˜ ìˆë‹¤ëŠ” ì ë„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. ì¦‰, ëˆ„êµ°ê°€ì—ê²Œ 1í†¤ì„ ë³´ë‚´ë©´ ë‹¤ë¥¸ ì‚¬ëŒì´ ì´ ë©”ì‹œì§€ë¥¼ ë°˜ë³µí•  ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ seqnoê°€ ì¦ê°€í•˜ë©´ ì´ì „ ì™¸ë¶€ ë©”ì‹œì§€ëŠ” ë¬´íš¨ê°€ ë˜ì–´ ì•„ë¬´ë„ ë°˜ë³µí•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ìê¸ˆì„ ë„ìš©í•  ê°€ëŠ¥ì„±ì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

### ì„œëª…

ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´ ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ëŠ” ì™¸ë¶€ íŠ¸ëœì­ì…˜ì„ í—ˆìš©í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ëŸ¬í•œ ê±°ë˜ëŠ” ì™¸ë¶€ ì„¸ê³„ì—ì„œ ì´ë£¨ì–´ì§€ë©° í•´ë‹¹ ë°ì´í„°ë¥¼ 100% ì‹ ë¢°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ê° ì§€ê°‘ì€ ì†Œìœ ìì˜ ê³µê°œ í‚¤ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ëŠ” ì†Œìœ ìê°€ ê°œì¸ í‚¤ë¡œ ì„œëª…í•œ ì™¸ë¶€ íŠ¸ëœì­ì…˜ì„ ë°›ì„ ë•Œ ê³µê°œ í‚¤ë¥¼ ì‚¬ìš©í•´ ê±°ë˜ ì„œëª…ì˜ ì ë²•ì„±ì„ í™•ì¸í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ íŠ¸ëœì­ì…˜ì´ ì‹¤ì œë¡œ ê³„ì•½ ì†Œìœ ìê°€ ë³´ë‚¸ ê²ƒì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.

ì´ í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆ˜í–‰í•˜ë ¤ë©´ ë¨¼ì € ì§€ê°‘ì´ ìˆ˜ì‹  ë©”ì‹œì§€ì—ì„œ ì„œëª…ì„ ë°›ì•„ì•¼ í•˜ë©°, ì§€ê°‘ì€ ìŠ¤í† ë¦¬ì§€ì—ì„œ ê³µê°œ í‚¤ë¥¼ ë¡œë“œí•˜ê³  ë‹¤ìŒ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„œëª…ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•©ë‹ˆë‹¤:

```func
var signature = in_msg~load_bits(512);
var ds = get_data().begin_parse();
var (stored_seqno, stored_subwallet, public_key) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256));
throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));
```

ê·¸ë¦¬ê³  ëª¨ë“  í™•ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ì˜¬ë°”ë¥´ê²Œ ì™„ë£Œë˜ë©´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ë©”ì‹œì§€ë¥¼ ìˆ˜ë½í•˜ê³  ì²˜ë¦¬í•©ë‹ˆë‹¤:

```func
accept_message();
```

:::info accept_message()
íŠ¸ëœì­ì…˜ì´ ì™¸ë¶€ì—ì„œ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— íŠ¸ëœì­ì…˜ ìˆ˜ìˆ˜ë£Œë¥¼ ì§€ë¶ˆí•˜ëŠ” ë° í•„ìš”í•œ í†¤ì½”ì¸ì€ í¬í•¨ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. accept_message() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ TONì„ ì „ì†¡í•  ë•Œ ê°€ìŠ¤ í¬ë ˆë”§(ì‘ì„± ì‹œì ì˜ ê°’ì€ 10,000 ê°€ìŠ¤ ë‹¨ìœ„)ì´ ì ìš©ë˜ì–´ ê°€ìŠ¤ê°€ ê°€ìŠ¤ í¬ë ˆë”§ ê°’ì„ ì´ˆê³¼í•˜ì§€ ì•Šìœ¼ë©´ í•„ìš”í•œ ê³„ì‚°ì„ ë¬´ë£Œë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. accept_message() í•¨ìˆ˜ê°€ ì‚¬ìš©ëœ í›„, ì‚¬ìš©ëœ ëª¨ë“  ê°€ìŠ¤(í†¤ ë‹¨ìœ„)ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì”ì•¡ì—ì„œ ì¸ì¶œë©ë‹ˆë‹¤. ì´ í”„ë¡œì„¸ìŠ¤ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [ì—¬ê¸°](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸/ê°€ì´ë“œë¼ì¸/ìˆ˜ë½)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

### ê±°ë˜ ë§Œë£Œ

ì™¸ë¶€ íŠ¸ëœì­ì…˜ì˜ ìœ íš¨ì„±ì„ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë˜ ë‹¤ë¥¸ ë‹¨ê³„ëŠ” `valid_until` í•„ë“œì…ë‹ˆë‹¤. ë³€ìˆ˜ ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´, ì´ê²ƒì€ íŠ¸ëœì­ì…˜ì´ ìœ íš¨í•˜ê¸° ì „ UNIXì—ì„œì˜ ì‹œê°„ì…ë‹ˆë‹¤. ì´ í™•ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤íŒ¨í•˜ë©´ ì»¨íŠ¸ë™íŠ¸ëŠ” íŠ¸ëœì­ì…˜ ì²˜ë¦¬ë¥¼ ì™„ë£Œí•˜ê³  35 ì¢…ë£Œ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤:

```func
var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
throw_if(35, valid_until <= now());
```

ì´ ì•Œê³ ë¦¬ì¦˜ì€ íŠ¸ëœì­ì…˜ì´ ë” ì´ìƒ ìœ íš¨í•˜ì§€ ì•Šì§€ë§Œ ì•Œ ìˆ˜ ì—†ëŠ” ì´ìœ ë¡œ ë¸”ë¡ì²´ì¸ì— ì „ì†¡ë˜ì—ˆì„ ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì˜¤ë¥˜ì˜ ê°€ëŠ¥ì„±ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‘ë™í•©ë‹ˆë‹¤.

### ì›”ë › v3ì™€ ì›”ë › v4ì˜ ì°¨ì´ì 

ì›”ë › v3ì™€ ì›”ë › v4ì˜ ìœ ì¼í•œ ì°¨ì´ì ì€ ì›”ë › v4ëŠ” ì„¤ì¹˜ ë° ì‚­ì œê°€ ê°€ëŠ¥í•œ 'í”ŒëŸ¬ê·¸ì¸'ì„ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŸ¬í•œ í”ŒëŸ¬ê·¸ì¸ì€ ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ íŠ¹ì • ì‹œê°„ì— íŠ¹ì • ìˆ˜ì˜ TONì„ ìš”ì²­í•  ìˆ˜ ìˆëŠ” íŠ¹ìˆ˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì…ë‹ˆë‹¤.

ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ì†Œìœ ìê°€ ì°¸ì—¬í•  í•„ìš” ì—†ì´ í•„ìš”í•œ ë§Œí¼ì˜ TONì„ ì „ì†¡í•©ë‹ˆë‹¤. ì´ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ ìƒì„±ë˜ëŠ” **êµ¬ë… ëª¨ë¸**ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ ì´ íŠœí† ë¦¬ì–¼ì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë‹¤ë£¨ì§€ ì•Šê² ìŠµë‹ˆë‹¤.

### ì§€ê°‘ì´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì™€ì˜ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ì„ ì´‰ì§„í•˜ëŠ” ë°©ë²•

ì•ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ëŠ” ì™¸ë¶€ íŠ¸ëœì­ì…˜ì„ ìˆ˜ë½í•˜ê³ , ìœ íš¨ì„±ì„ ê²€ì‚¬í•œ í›„ ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í•˜ë©´ íŠ¸ëœì­ì…˜ì„ ìŠ¹ì¸í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ì»¨íŠ¸ë™íŠ¸ëŠ” ì™¸ë¶€ ë©”ì‹œì§€ ë³¸ë¬¸ì—ì„œ ë©”ì‹œì§€ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë£¨í”„ë¥¼ ì‹œì‘í•œ ë‹¤ìŒ ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ìƒì„±í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì´ ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤:

```func
cs~touch();
while (cs.slice_refs()) {
    var mode = cs~load_uint(8); ;; load transaction mode
    send_raw_message(cs~load_ref(), mode); ;; get each new internal message as a cell with the help of load_ref() and send it
}
```

:::tip í„°ì¹˜()
TONì—ì„œ ëª¨ë“  ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ìŠ¤íƒ ê¸°ë°˜ TON ê°€ìƒë¨¸ì‹ (TVM)ì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤. ~ í„°ì¹˜()ëŠ” ìŠ¤íƒ ìœ„ì— ë³€ìˆ˜ `cs`ë¥¼ ë°°ì¹˜í•˜ì—¬ ì½”ë“œ ì‹¤í–‰ì„ ìµœì í™”í•˜ì—¬ ê°€ìŠ¤ë¥¼ ì ê²Œ ì†Œëª¨í•©ë‹ˆë‹¤.
:::

í•˜ë‚˜ì˜ ì…€ì— **ìµœëŒ€ 4ê°œì˜ ì°¸ì¡°**ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì™¸ë¶€ ë©”ì‹œì§€ë‹¹ ìµœëŒ€ 4ê°œì˜ ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ğŸ’¡ ìœ ìš©í•œ ë§í¬:
>
> ["slice_refs()" in docs](/develop/func/stdlib/#slice_refs)
>
> ["send_raw_message() ë° íŠ¸ëœì­ì…˜ ëª¨ë“œ" ë¬¸ì„œ](/develop/func/stdlib/#send_raw_message)
>
> ["load_ref()" in docs](/develop/func/stdlib/#load_ref)

## ğŸ“¬ ì™¸ë¶€ ë° ë‚´ë¶€ ê±°ë˜

ì´ ì„¹ì…˜ì—ì„œëŠ” 'ë‚´ë¶€' ë° 'ì™¸ë¶€' íŠ¸ëœì­ì…˜ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê³ , íŠ¸ëœì­ì…˜ì„ ìƒì„±í•˜ê³  ë„¤íŠ¸ì›Œí¬ì— ì „ì†¡í•˜ì—¬ ë¯¸ë¦¬ ì¤€ë¹„ëœ í•¨ìˆ˜ ì‚¬ìš©ì„ ìµœì†Œí™”í•˜ê² ìŠµë‹ˆë‹¤.

ì´ í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆ˜í–‰í•˜ë ¤ë©´ ê¸°ì„±í’ˆ ì§€ê°‘ì„ ì‚¬ìš©í•˜ì—¬ ì‘ì—…ì„ ë” ì‰½ê²Œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´

1. ì§€ê°‘ ì•±](/ì°¸ì—¬/ì§€ê°‘/ì•±)ì„ ì„¤ì¹˜í•©ë‹ˆë‹¤(ì˜ˆ: ê¸€ì“´ì´ê°€ ì‚¬ìš©í•˜ëŠ” í†¤í‚¤í¼).
2. ì§€ê°‘ ì•±ì„ v3r2 ì£¼ì†Œ ë²„ì „ìœ¼ë¡œ ì „í™˜í•˜ê¸°
3. ì§€ê°‘ì— 1í†¤ ì…ê¸ˆí•˜ê¸°
4. ë‹¤ë¥¸ ì£¼ì†Œë¡œ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•©ë‹ˆë‹¤(ë™ì¼í•œ ì§€ê°‘ìœ¼ë¡œ ë³¸ì¸ì—ê²Œ ì „ì†¡í•  ìˆ˜ ìˆìŒ).

ì´ë ‡ê²Œ í•˜ë©´ í†¤í‚¤í¼ ì§€ê°‘ ì•±ì´ ì§€ê°‘ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë°°í¬í•˜ê³  ë‹¤ìŒ ë‹¨ê³„ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

:::note
ì´ ê¸€ì„ ì‘ì„±í•˜ëŠ” ì‹œì ì— TONì˜ ëŒ€ë¶€ë¶„ì˜ ì§€ê°‘ ì•±ì€ ê¸°ë³¸ì ìœ¼ë¡œ ì§€ê°‘ v4 ë²„ì „ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” í”ŒëŸ¬ê·¸ì¸ì´ í•„ìš”í•˜ì§€ ì•Šìœ¼ë©° ì§€ê°‘ v3ì—ì„œ ì œê³µí•˜ëŠ” ê¸°ëŠ¥ì„ í™œìš©í•˜ê² ìŠµë‹ˆë‹¤. í†¤í‚¤í¼ë¥¼ ì‚¬ìš©í•˜ëŠ” ë™ì•ˆ ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ì§€ê°‘ ë²„ì „ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì§€ê°‘ ë²„ì „ 3(ì§€ê°‘ v3)ì„ ë°°í¬í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
:::

### TL-B

ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´, í†¤ ë¸”ë¡ì²´ì¸ì˜ ëª¨ë“  ê²ƒì€ ì…€ë¡œ êµ¬ì„±ëœ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì…ë‹ˆë‹¤. ë°ì´í„°ë¥¼ ì œëŒ€ë¡œ ì§ë ¬í™” ë° ì—­ì§ë ¬í™”í•˜ë ¤ë©´ í‘œì¤€ì´ í•„ìš”í•©ë‹ˆë‹¤. ì§ë ¬í™” ë° ì—­ì§ë ¬í™” í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ 'TL-B'ëŠ” ì…€ ë‚´ë¶€ì—ì„œ ì„œë¡œ ë‹¤ë¥¸ ì‹œí€€ìŠ¤ë¡œ ì„œë¡œ ë‹¤ë¥¸ ë°ì´í„° ìœ í˜•ì„ ì„œë¡œ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì„¤ëª…í•  ìˆ˜ ìˆëŠ” ë²”ìš© ë„êµ¬ë¡œ ë§Œë“¤ì–´ì¡ŒìŠµë‹ˆë‹¤.

ì´ ì„¹ì…˜ì—ì„œëŠ” [block.tlb](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb)ë¥¼ ì‚´í´ë´…ë‹ˆë‹¤. ì´ íŒŒì¼ì€ ë‹¤ì–‘í•œ ì…€ì„ ì¡°ë¦½í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ê¸° ë•Œë¬¸ì— í–¥í›„ ê°œë°œ ê³¼ì •ì—ì„œ ë§¤ìš° ìœ ìš©í•  ê²ƒì…ë‹ˆë‹¤. íŠ¹íˆ ì €í¬ì˜ ê²½ìš° ë‚´ë¶€ ë° ì™¸ë¶€ íŠ¸ëœì­ì…˜ì˜ ë³µì¡ì„±ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

:::info
ì´ ê°€ì´ë“œì—ì„œëŠ” ê¸°ë³¸ì ì¸ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ TL-B [ë¬¸ì„œ](/ê°œë°œ/ë°ì´í„°-í¬ë§·/tl-b-language)ë¥¼ ì°¸ì¡°í•˜ì—¬ TL-Bì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ì„¸ìš”.
:::

### ê³µí†µë©”ì‹œì§€ì •ë³´

ì²˜ìŒì— ê° ë©”ì‹œì§€ëŠ” ë¨¼ì € `CommonMsgInfo`([TL-B](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L123-L130)) ë˜ëŠ” `CommonMsgInfoRelaxed`([TL-B](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L132-L137))ë¥¼ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ íŠ¸ëœì­ì…˜ ìœ í˜•, íŠ¸ëœì­ì…˜ ì‹œê°„, ìˆ˜ì‹ ì ì£¼ì†Œ, ê¸°ìˆ  í”Œë˜ê·¸ ë° ìˆ˜ìˆ˜ë£Œì™€ ê´€ë ¨ëœ ê¸°ìˆ ì  ì„¸ë¶€ ì •ë³´ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

block.tlb`íŒŒì¼ì„ ì½ìœ¼ë©´`int_msg_info$0`, `ext_in_msg_info$10`, `ext_out_msg_info$11`ì˜ ì„¸ ê°€ì§€ ìœ í˜•ì˜ CommonMsgInfoë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” `ext_out_msg_info\` TL-B êµ¬ì¡°ì˜ íŠ¹ìˆ˜ì„±ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•˜ì§€ ì•Šê² ìŠµë‹ˆë‹¤. ì¦‰, ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ê°€ ì™¸ë¶€ ë¡œê·¸ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì „ì†¡í•  ìˆ˜ ìˆëŠ” ì™¸ë¶€ íŠ¸ëœì­ì…˜ ìœ í˜•ì…ë‹ˆë‹¤. ì´ í˜•ì‹ì˜ ì˜ˆì‹œë¥¼ ë³´ì‹œë ¤ë©´ [Elector](\(https://tonscan.org/address/Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF\)) ì»¨íŠ¸ë™íŠ¸ë¥¼ ìì„¸íˆ ì‚´í´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤.

[TL-B](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L127-L128)ë¥¼ ë³´ë©´, **í™•ì¥_in_msg_info íƒ€ì…ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ CommonMsgInfoë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤**. ì´ëŠ” íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ì¤‘ì— `src`, `created_lt`, `created_at` ë“±ê³¼ ê°™ì€ íŠ¸ëœì­ì…˜ íƒ€ì… í•„ë“œê°€ ê²€ì¦ìì— ì˜í•´ ì¬ì‘ì„±ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ ê²½ìš° íŠ¸ëœì­ì…˜ì´ ì „ì†¡ë  ë•Œ ë°œì‹ ìë¥¼ ì•Œ ìˆ˜ ì—†ê³  ê²€ì¦ ì¤‘ì— ìœ íš¨ì„± ê²€ì‚¬ê¸°ì— ì˜í•´ ì‘ì„±ë˜ê¸° ë•Œë¬¸ì— `src` íŠ¸ëœì­ì…˜ ìœ í˜•ì´ ê°€ì¥ ì¤‘ìš”í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ `src` í•„ë“œì˜ ì£¼ì†Œê°€ ì •í™•í•˜ê³  ì¡°ì‘í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤.

ê·¸ëŸ¬ë‚˜ `CommonMsgInfo` êµ¬ì¡°ì²´ëŠ” `MsgAddress` ì‚¬ì–‘ë§Œ ì§€ì›í•˜ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë°œì‹ ìì˜ ì£¼ì†Œë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš° `addr_none`(0ë¹„íŠ¸ `00` 2ê°œ)ì„ ì¨ì•¼ í•©ë‹ˆë‹¤. ì´ ê²½ìš° `addr_none` ì£¼ì†Œë¥¼ ì§€ì›í•˜ëŠ” `CommonMsgInfoRelaxed` êµ¬ì¡°ì²´ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤. ìˆ˜ì‹  ì™¸ë¶€ ë©”ì‹œì§€ì— ì‚¬ìš©ë˜ëŠ” `ext_in_msg_info`ì˜ ê²½ìš°, ì´ëŸ¬í•œ ë©”ì‹œì§€ ìœ í˜•ì€ ë°œì‹ ìë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  í•­ìƒ [MsgAddressExt](https://hub.com/ton/ton.blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L100) êµ¬ì¡°ì²´(`addr_none$00`ì€ 0ë¹„íŠ¸ 2ê°œ)ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë°ì´í„°ë¥¼ ë®ì–´ì“¸ í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ `CommonMsgInfo` êµ¬ì¡°ì²´ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤.

:::note
'$' ê¸°í˜¸ ë’¤ì˜ ìˆ«ìëŠ” íŠ¹ì • êµ¬ì¡°ì˜ ì‹œì‘ ë¶€ë¶„ì— ì €ì¥í•´ì•¼ í•˜ëŠ” ë¹„íŠ¸ë¡œ, ì½ê¸°(ì—­ì§ë ¬í™”) ì¤‘ì— ì´ëŸ¬í•œ êµ¬ì¡°ë¥¼ ì¶”ê°€ë¡œ ì‹ë³„í•˜ê¸° ìœ„í•´ í•„ìš”í•©ë‹ˆë‹¤.
:::

### ë‚´ë¶€ ê±°ë˜ ìƒì„±

ë‚´ë¶€ íŠ¸ëœì­ì…˜ì€ ì»¨íŠ¸ë™íŠ¸ ê°„ì— ë©”ì‹œì§€ë¥¼ ì „ì†¡í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. NFT](https://github.com/ton-blockchain/token-contract/blob/f2253cb0f0e1ae0974d7dc0cef3a62cb6e19f806/nft/nft-item.fc#L51-L56), [ì œí†¤](https://github.com/ton-blockchain/token-contract/blob/f2253cb0f0e1ae0974d7dc0cef3a62cb6e19f806/ft/jetton-wallet.fc#L139-L144) ë“± ì»¨íŠ¸ë™íŠ¸ ì‘ì„±ì„ ê³ ë ¤í•˜ëŠ” ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ë‹¤ì–‘í•œ ì»¨íŠ¸ë™íŠ¸ ìœ í˜•ì„ ë¶„ì„í•  ë•Œ, ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ ìì£¼ ì‚¬ìš©ë©ë‹ˆë‹¤:

```func
var msg = begin_cell()
  .store_uint(0x18, 6) ;; or 0x10 for non-bounce
  .store_slice(to_address)
  .store_coins(amount)
  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
  ;; store something as a body
```

ë¨¼ì € ë‹¤ìŒê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë°°ì—´ëœ 16ì§„ìˆ˜ì¸ `0x18`ê³¼ `0x10`(x - 16ì§„ìˆ˜)ì„ ê³ ë ¤í•´ ë³´ê² ìŠµë‹ˆë‹¤(6ë¹„íŠ¸ë¥¼ í• ë‹¹í•œë‹¤ëŠ” ê°€ì • í•˜ì—): 011000`ê³¼ `010000\`ì…ë‹ˆë‹¤. ì¦‰, ìœ„ì˜ ì½”ë“œë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ë®ì–´ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```func
var msg = begin_cell()
  .store_uint(0, 1) ;; this bit indicates that we send an internal message according to int_msg_info$0  
  .store_uint(1, 1) ;; IHR Disabled
  .store_uint(1, 1) ;; or .store_uint(0, 1) for 0x10 | bounce
  .store_uint(0, 1) ;; bounced
  .store_uint(0, 2) ;; src -> two zero bits for addr_none
  .store_slice(to_address)
  .store_coins(amount)
  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
  ;; store something as a body
```

ì´ì œ ê° ì˜µì…˜ì„ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:

|    ì˜µì…˜   |                                                                                                                                                                                                  ì„¤ëª…                                                                                                                                                                                                  |
| :-----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| IHR ì¥ì• ì¸ |                                  í˜„ì¬ ì´ ì˜µì…˜ì€ ì¸ìŠ¤í„´íŠ¸ í•˜ì´í¼íë¸Œ ë¼ìš°íŒ…ì´ ì™„ì „íˆ êµ¬í˜„ë˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤(ì¦‰, 1ì„ ì €ì¥í•©ë‹ˆë‹¤). ë˜í•œ ë§ì€ ìˆ˜ì˜ [ìƒ¤ë“œì²´ì¸](/í•™ìŠµ/ê°œìš”/í†¤ë¸”ë¡ì²´ì¸#ë§ì€-ê³„ì •ì²´ì¸-ìƒ¤ë“œ)ì´ ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì–´ ìˆì„ ë•Œ ì´ ì˜µì…˜ì´ í•„ìš”í•©ë‹ˆë‹¤. IHR ë¹„í™œì„±í™” ì˜µì…˜ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [tblkch.pdf](https://ton.org/tblkch.pdf)(2ì¥)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.                                 |
|  Bounce | íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•˜ëŠ” ë™ì•ˆ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì²˜ë¦¬ ì¤‘ì— ë‹¤ì–‘í•œ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. TONì„ ìƒì§€ ì•Šìœ¼ë ¤ë©´ ë°˜ì†¡ ì˜µì…˜ì„ 1(true)ë¡œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ê²½ìš° íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ì¤‘ ì»¨íŠ¸ë™íŠ¸ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ íŠ¸ëœì­ì…˜ì€ ë°œì‹ ìì—ê²Œ ë°˜í™˜ë˜ë©°, ìˆ˜ìˆ˜ë£Œë¥¼ ì œì™¸í•œ ë™ì¼í•œ ê¸ˆì•¡ì˜ TONì„ ë°›ê²Œ ë©ë‹ˆë‹¤. ë°˜ì†¡ ë¶ˆê°€ ë©”ì‹œì§€ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [ì—¬ê¸°](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸/ê°€ì´ë“œë¼ì¸/ë°˜ì†¡ ë¶ˆê°€ ë©”ì‹œì§€)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. |
| Bounced |                                                                                                                                   ë°˜ì†¡ëœ íŠ¸ëœì­ì…˜ì€ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¡œ íŠ¸ëœì­ì…˜ì„ ì²˜ë¦¬í•˜ëŠ” ë™ì•ˆ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ ë°œì‹ ìì—ê²Œ ë°˜í™˜ë˜ëŠ” íŠ¸ëœì­ì…˜ì…ë‹ˆë‹¤. ì´ ì˜µì…˜ì€ ìˆ˜ì‹ ëœ íŠ¸ëœì­ì…˜ì´ ë°˜ì†¡ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì•Œë ¤ì¤ë‹ˆë‹¤.                                                                                                                                   |
|   Src   |                                                                                                                                                      SrcëŠ” ë°œì‹ ì ì£¼ì†Œì…ë‹ˆë‹¤. ì´ ê²½ìš° ë‘ ê°œì˜ 0ë¹„íŠ¸ê°€ ê¸°ë¡ë˜ì–´ `addr_none` ì£¼ì†Œë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.                                                                                                                                                      |

ë‹¤ìŒ ë‘ ì¤„ì˜ ì½”ë“œì…ë‹ˆë‹¤:

```func
...
.store_slice(to_address)
.store_coins(amount)
...
```

- ìˆ˜ì‹ ìì™€ ì „ì†¡í•  TONì˜ ê°œìˆ˜ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ìœ¼ë¡œ ë‚˜ë¨¸ì§€ ì½”ë“œ ì¤„ì„ ì‚´í´ë´…ì‹œë‹¤:

```func
...
  .store_uint(0, 1) ;; Extra currency
  .store_uint(0, 4) ;; IHR fee
  .store_uint(0, 4) ;; Forwarding fee
  .store_uint(0, 64) ;; Logical time of creation
  .store_uint(0, 32) ;; UNIX time of creation
  .store_uint(0, 1) ;; State Init
  .store_uint(0, 1) ;; Message body
  ;; store something as a body
```

|     ì˜µì…˜     |                                                                                                                              ì„¤ëª…                                                                                                                             |
| :--------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|    ì¶”ê°€ í†µí™”   |                                                                                                       ì´ëŠ” ê¸°ì¡´ ì œí†¤ì˜ ê¸°ë³¸ êµ¬í˜„ì´ë©° í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.                                                                                                       |
|   IHR ìˆ˜ìˆ˜ë£Œ  |                  ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´ IHRì€ í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì´ ìˆ˜ìˆ˜ë£ŒëŠ” í•­ìƒ 0ì…ë‹ˆë‹¤. ì´ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [tblkch.pdf](https://ton.org/tblkch.pdf)(3.1.8)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.                  |
|   í¬ì›Œë”© ìˆ˜ìˆ˜ë£Œ  |                                                                            ì „ë‹¬ ë©”ì‹œì§€ ìˆ˜ìˆ˜ë£Œ. ì´ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [ìˆ˜ìˆ˜ë£Œ ë¬¸ì„œ](/ê°œë°œ/ë°©ë²•/ìˆ˜ìˆ˜ë£Œ-ì €ìˆ˜ì¤€#ê±°ë˜-ë‹¨ê³„)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.                                                                           |
|  ë…¼ë¦¬ì  ìƒì„± ì‹œê°„ |                                                                                                        ì˜¬ë°”ë¥¸ íŠ¸ëœì­ì…˜ ëŒ€ê¸°ì—´ì„ ë§Œë“œëŠ” ë° ì‚¬ìš©ëœ ì‹œê°„ì…ë‹ˆë‹¤.                                                                                                       |
| UNIX ì°½ì¡°ì˜ ì„œ |                                                                                                           íŠ¸ëœì­ì…˜ì´ UNIXì—ì„œ ìƒì„±ëœ ì‹œê°„ì…ë‹ˆë‹¤.                                                                                                           |
|   ìƒíƒœ ì´ˆê¸°í™”   | ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë°°í¬ë¥¼ ìœ„í•œ ì½”ë“œ ë° ì†ŒìŠ¤ ë°ì´í„°ì…ë‹ˆë‹¤. ë¹„íŠ¸ê°€ `0`ìœ¼ë¡œ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ State Initì´ ì—†ìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ `1`ë¡œ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´ State Initì´ ê°™ì€ ì…€ì— ì €ì¥ë˜ì–´ ìˆëŠ”ì§€(0), ì•„ë‹ˆë©´ ì°¸ì¡°ë¡œ ê¸°ë¡ë˜ì–´ ìˆëŠ”ì§€(1)ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë‹¤ë¥¸ ë¹„íŠ¸ë¥¼ ê¸°ë¡í•´ì•¼ í•©ë‹ˆë‹¤. |
|   ë©”ì‹œì§€ ë³¸ë¬¸   |            ì´ ë¶€ë¶„ì€ ë©”ì‹œì§€ ë³¸ë¬¸ì´ ì €ì¥ë˜ëŠ” ë°©ì‹ì„ ì •ì˜í•©ë‹ˆë‹¤. ë•Œë•Œë¡œ ë©”ì‹œì§€ ë³¸ë¬¸ì´ ë„ˆë¬´ ì»¤ì„œ ë©”ì‹œì§€ ìì²´ì— ë“¤ì–´ê°ˆ ìˆ˜ ì—†ëŠ” ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš°, ë³¸ë¬¸ì´ ì°¸ì¡°ë¡œ ì‚¬ìš©ë¨ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ë¹„íŠ¸ê°€ `1`ë¡œ ì„¤ì •ëœ **ì°¸ì¡°**ë¡œ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤. ë¹„íŠ¸ê°€ `0`ì´ë©´ ë³¸ë¬¸ì´ ë©”ì‹œì§€ì™€ ê°™ì€ ì…€ì— ìˆëŠ” ê²ƒì…ë‹ˆë‹¤.           |

ìœ„ì— ì„¤ëª…ëœ ê°’(src í¬í•¨)ì€ State Init ë° Message Body ë¹„íŠ¸ë¥¼ ì œì™¸í•˜ê³  ìœ íš¨ì„± ê²€ì‚¬ê¸°ì— ì˜í•´ ì¬ì‘ì„±ë©ë‹ˆë‹¤.

:::note
ìˆ«ì ê°’ì´ ì§€ì •í•œ ê²ƒë³´ë‹¤ ì ì€ ë¹„íŠ¸ ë‚´ì— ë§ëŠ” ê²½ìš° ëˆ„ë½ëœ 0ì´ ê°’ì˜ ì™¼ìª½ì— ì¶”ê°€ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 0x18ì€ 5ë¹„íŠ¸ ì´ë‚´ -> `11000`ì— ë§ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ 6ë¹„íŠ¸ë¥¼ ì§€ì •í–ˆê¸° ë•Œë¬¸ì— ìµœì¢… ê²°ê³¼ëŠ” `011000`ì´ ë©ë‹ˆë‹¤.
:::

ë‹¤ìŒìœ¼ë¡œ, ë‹¤ë¥¸ ì§€ê°‘ v3ìœ¼ë¡œ í†¤ì½”ì¸ì„ ì „ì†¡í•˜ëŠ” íŠ¸ëœì­ì…˜ ì¤€ë¹„ë¥¼ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤.
ë¨¼ì € ì‚¬ìš©ìê°€ "\*\*ì•ˆë…•, í†¤!"ì´ë¼ëŠ” í…ìŠ¤íŠ¸ë¡œ 0.5í†¤ì„ ìì‹ ì—ê²Œ ë³´ë‚´ê³  ì‹¶ë‹¤ê³  ê°€ì •í•˜ê³ , ì´ ë¬¸ì„œ ì„¹ì…˜ì„ ì°¸ì¡°í•˜ì—¬ ë°°ìš°ê² ìŠµë‹ˆë‹¤([ëŒ“ê¸€ë¡œ ë©”ì‹œì§€ ë³´ë‚´ëŠ” ë°©ë²•](/develop/func/cookbook#how-to-simple-message)).

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { beginCell } from '@ton/core';

let internalMessageBody = beginCell()
  .storeUint(0, 32) // write 32 zero bits to indicate that a text comment will follow
  .storeStringTail("Hello, TON!") // write our text comment
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
	"github.com/xssnick/tonutils-go/tvm/cell"
)

internalMessageBody := cell.BeginCell().
  MustStoreUInt(0, 32). // write 32 zero bits to indicate that a text comment will follow
  MustStoreStringSnake("Hello, TON!"). // write our text comment
  EndCell()
```

</TabItem>
</Tabs>

ìœ„ì—ì„œ ë©”ì‹œì§€ ë³¸ë¬¸ì´ ì €ì¥ë˜ëŠ” `InternalMessageBody`ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. í•˜ë‚˜ì˜ ì…€(1023ë¹„íŠ¸)ì— ë§ì§€ ì•ŠëŠ” í…ìŠ¤íŠ¸ë¥¼ ì €ì¥í•  ë•ŒëŠ” [ë‹¤ìŒ ë¬¸ì„œ](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ê³„ì•½/ì§€ì¹¨/ë‚´ë¶€-ë©”ì‹œì§€)ì— ë”°ë¼ **ë°ì´í„°ë¥¼ ì—¬ëŸ¬ ì…€ë¡œ ë¶„í• **í•´ì•¼ í•œë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”. í•˜ì§€ë§Œ ì´ ê²½ìš° ìƒìœ„ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ì…€ì„ ìƒì„±í•˜ë¯€ë¡œ ì´ ë‹¨ê³„ì—ì„œëŠ” ê±±ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.

ë‹¤ìŒìœ¼ë¡œ, ì•ì„œ í•™ìŠµí•œ ì •ë³´ì— ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì´ `InternalMessage`ë¥¼ ìƒì„±í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { toNano, Address } from '@ton/ton';

const walletAddress = Address.parse('put your wallet address');

let internalMessage = beginCell()
  .storeUint(0, 1) // indicate that it is an internal message -> int_msg_info$0
  .storeBit(1) // IHR Disabled
  .storeBit(1) // bounce
  .storeBit(0) // bounced
  .storeUint(0, 2) // src -> addr_none
  .storeAddress(walletAddress)
  .storeCoins(toNano("0.2")) // amount
  .storeBit(0) // Extra currency
  .storeCoins(0) // IHR Fee
  .storeCoins(0) // Forwarding Fee
  .storeUint(0, 64) // Logical time of creation
  .storeUint(0, 32) // UNIX time of creation
  .storeBit(0) // No State Init
  .storeBit(1) // We store Message Body as a reference
  .storeRef(internalMessageBody) // Store Message Body as a reference
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/address"
  "github.com/xssnick/tonutils-go/tlb"
)

walletAddress := address.MustParseAddr("put your address")

internalMessage := cell.BeginCell().
  MustStoreUInt(0, 1). // indicate that it is an internal message -> int_msg_info$0
  MustStoreBoolBit(true). // IHR Disabled
  MustStoreBoolBit(true). // bounce
  MustStoreBoolBit(false). // bounced
  MustStoreUInt(0, 2). // src -> addr_none
  MustStoreAddr(walletAddress).
  MustStoreCoins(tlb.MustFromTON("0.2").NanoTON().Uint64()).   // amount
  MustStoreBoolBit(false). // Extra currency
  MustStoreCoins(0). // IHR Fee
  MustStoreCoins(0). // Forwarding Fee
  MustStoreUInt(0, 64). // Logical time of creation
  MustStoreUInt(0, 32). // UNIX time of creation
  MustStoreBoolBit(false). // No State Init
  MustStoreBoolBit(true). // We store Message Body as a reference
  MustStoreRef(internalMessageBody). // Store Message Body as a reference
  EndCell()
```

</TabItem>
</Tabs>

### ë©”ì‹œì§€ ë§Œë“¤ê¸°

ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ `seqno`(ì‹œí€€ìŠ¤ ë²ˆí˜¸)ë¥¼ ê²€ìƒ‰í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ 'í´ë¼ì´ì–¸íŠ¸'ê°€ ìƒì„±ë˜ë©°, ì´ í´ë¼ì´ì–¸íŠ¸ëŠ” ì§€ê°‘ì˜ "seqno" ê°€ì ¸ì˜¤ê¸° ë©”ì„œë“œ ì‹¤í–‰ ìš”ì²­ì„ ì „ì†¡í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ë˜í•œ ë‹¤ìŒ ë‹¨ê³„ë¥¼ í†µí•´ íŠ¸ëœì­ì…˜ì— ì„œëª…í•˜ê¸° ìœ„í•´ ì‹œë“œ ë¬¸êµ¬(ì§€ê°‘ì„ ë§Œë“¤ ë•Œ ì €ì¥í•œ [ì—¬ê¸°](#--ì™¸ë¶€ ë° ë‚´ë¶€ íŠ¸ëœì­ì…˜))ë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { TonClient } from '@ton/ton';
import { mnemonicToWalletKey } from '@ton/crypto';

const client = new TonClient({
  endpoint: "https://toncenter.com/api/v2/jsonRPC",
  apiKey: "put your api key" // you can get an api key from @tonapibot bot in Telegram
});

const mnemonic = 'put your mnemonic'; // word1 word2 word3
let getMethodResult = await client.runMethod(walletAddress, "seqno"); // run "seqno" GET method from your wallet contract
let seqno = getMethodResult.stack.readNumber(); // get seqno from response

const mnemonicArray = mnemonic.split(' '); // get array from string
const keyPair = await mnemonicToWalletKey(mnemonicArray); // get Secret and Public keys from mnemonic 
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "context"
  "crypto/ed25519"
  "crypto/hmac"
  "crypto/sha512"
  "github.com/xssnick/tonutils-go/liteclient"
  "github.com/xssnick/tonutils-go/ton"
  "golang.org/x/crypto/pbkdf2"
  "log"
  "strings"
)

mnemonic := strings.Split("put your mnemonic", " ") // get our mnemonic as array

connection := liteclient.NewConnectionPool()
configUrl := "https://ton-blockchain.github.io/global.config.json"
err := connection.AddConnectionsFromConfigUrl(context.Background(), configUrl)
if err != nil {
  panic(err)
}
client := ton.NewAPIClient(connection) // create client

block, err := client.CurrentMasterchainInfo(context.Background()) // get current block, we will need it in requests to LiteServer
if err != nil {
  log.Fatalln("CurrentMasterchainInfo err:", err.Error())
  return
}

getMethodResult, err := client.RunGetMethod(context.Background(), block, walletAddress, "seqno") // run "seqno" GET method from your wallet contract
if err != nil {
  log.Fatalln("RunGetMethod err:", err.Error())
  return
}
seqno := getMethodResult.MustInt(0) // get seqno from response

// The next three lines will extract the private key using the mnemonic phrase. We will not go into cryptographic details. With the tonutils-go library, this is all implemented, but weâ€™re doing it again to get a full understanding.
mac := hmac.New(sha512.New, []byte(strings.Join(mnemonic, " ")))
hash := mac.Sum(nil)
k := pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys

privateKey := ed25519.NewKeyFromSeed(k)
```

</TabItem>
</Tabs>

ë”°ë¼ì„œ `seqno`, `í‚¤`, `ë‚´ë¶€ ë©”ì‹œì§€`ë¥¼ ì „ì†¡í•´ì•¼ í•©ë‹ˆë‹¤. ì´ì œ ì§€ê°‘ì— ëŒ€í•œ [ë©”ì‹œì§€](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸/ë©”ì‹œì§€)ë¥¼ ìƒì„±í•˜ê³  íŠœí† ë¦¬ì–¼ì˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ ì‚¬ìš©í•œ ìˆœì„œëŒ€ë¡œ ì´ ë©”ì‹œì§€ì— ë°ì´í„°ë¥¼ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ìˆ˜í–‰ë©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { sign } from '@ton/crypto';

let toSign = beginCell()
  .storeUint(698983191, 32) // subwallet_id | We consider this further
  .storeUint(Math.floor(Date.now() / 1e3) + 60, 32) // Transaction expiration time, +60 = 1 minute
  .storeUint(seqno, 32) // store seqno
  .storeUint(3, 8) // store mode of our internal transaction
  .storeRef(internalMessage); // store our internalMessage as a reference

let signature = sign(toSign.endCell().hash(), keyPair.secretKey); // get the hash of our message to wallet smart contract and sign it to get signature

let body = beginCell()
  .storeBuffer(signature) // store signature
  .storeBuilder(toSign) // store our message
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "time"
)

toSign := cell.BeginCell().
  MustStoreUInt(698983191, 32). // subwallet_id | We consider this further
  MustStoreUInt(uint64(time.Now().UTC().Unix()+60), 32). // Transaction expiration time, +60 = 1 minute
  MustStoreUInt(seqno.Uint64(), 32). // store seqno
  MustStoreUInt(uint64(3), 8). // store mode of our internal transaction
  MustStoreRef(internalMessage) // store our internalMessage as a reference

signature := ed25519.Sign(privateKey, toSign.EndCell().Hash()) // get the hash of our message to wallet smart contract and sign it to get signature

body := cell.BeginCell().
  MustStoreSlice(signature, 512). // store signature
  MustStoreBuilder(toSign). // store our message
  EndCell()
```

</TabItem>
</Tabs>

ì—¬ê¸°ì„œëŠ” `toSign`ì˜ ì •ì˜ì— '.endCell()\`ì´ ì‚¬ìš©ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ì‹¤ ì´ ê²½ìš°ì—ëŠ” **toSign ì½˜í…ì¸ ë¥¼ ë©”ì‹œì§€ ë³¸ë¬¸ìœ¼ë¡œ ì§ì ‘ ì „ì†¡í•´ì•¼ í•©ë‹ˆë‹¤**. ì…€ì„ ì‘ì„±í•´ì•¼ í•œë‹¤ë©´ ì°¸ì¡°ë¡œ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤.

:::tip ì›”ë › V4
ì›”ë › V3ì˜ ê²½ìš° ì•„ë˜ì—ì„œ ë°°ìš´ ê¸°ë³¸ ì¸ì¦ í”„ë¡œì„¸ìŠ¤ ì™¸ì—ë„ ì›”ë › V4 ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸(ë‹¨ìˆœ ë²ˆì—­ì¸ì§€ í”ŒëŸ¬ê·¸ì¸ê³¼ ê´€ë ¨ëœ íŠ¸ëœì­ì…˜ì¸ì§€ íŒë‹¨í•˜ê¸° ìœ„í•´ ì˜µì½”ë“œ ì¶”ì¶œ)(https://github.com/ton-blockchain/wallet-contract/blob/4111fd9e3313ec17d99ca9b5b1656445b5b49d8f/func/wallet-v4-code.fc#L94-L100)ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì´ ë²„ì „ê³¼ ì¼ì¹˜í•˜ë ¤ë©´ seqno(ì‹œí€€ìŠ¤ ë²ˆí˜¸) ì‘ì„± í›„ íŠ¸ëœì­ì…˜ ëª¨ë“œë¥¼ ì§€ì •í•˜ê¸° ì „ì— `storeUint(0, 8).`(JS/TS), `MustStoreUInt(0, 8).`(Golang) í•¨ìˆ˜ë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
:::

### ì™¸ë¶€ ê±°ë˜ ìƒì„±

ì™¸ë¶€ì—ì„œ ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•˜ë ¤ë©´, ì™¸ë¶€ íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•´ì•¼ í•©ë‹ˆë‹¤. ì•ì„œ ì‚´í´ë³¸ ê²ƒì²˜ëŸ¼, ì»¨íŠ¸ë™íŠ¸ì— ì™¸ë¶€ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ê²ƒì´ ëª©í‘œì´ë¯€ë¡œ `ext_in_msg_info$10` êµ¬ì¡°ë§Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ì´ì œ ì§€ê°‘ìœ¼ë¡œ ì „ì†¡í•  ì™¸ë¶€ ë©”ì‹œì§€ë¥¼ ìƒì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
let externalMessage = beginCell()
  .storeUint(0b10, 2) // 0b10 -> 10 in binary
  .storeUint(0, 2) // src -> addr_none
  .storeAddress(walletAddress) // Destination address
  .storeCoins(0) // Import Fee
  .storeBit(0) // No State Init
  .storeBit(1) // We store Message Body as a reference
  .storeRef(body) // Store Message Body as a reference
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
externalMessage := cell.BeginCell().
  MustStoreUInt(0b10, 2). // 0b10 -> 10 in binary
  MustStoreUInt(0, 2). // src -> addr_none
  MustStoreAddr(walletAddress). // Destination address
  MustStoreCoins(0). // Import Fee
  MustStoreBoolBit(false). // No State Init
  MustStoreBoolBit(true). // We store Message Body as a reference
  MustStoreRef(body). // Store Message Body as a reference
  EndCell()
```

</TabItem>
</Tabs>

|   ì˜µì…˜   |                                                                                                                                 ì„¤ëª…                                                                                                                                 |
| :----: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|   Src  | ë°œì‹ ì ì£¼ì†Œì…ë‹ˆë‹¤. ìˆ˜ì‹  ì™¸ë¶€ ë©”ì‹œì§€ì—ëŠ” ë°œì‹ ìê°€ ìˆì„ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í•­ìƒ 2ê°œì˜ 0ë¹„íŠ¸(addr_none [TL-B](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L100)ê°€ ìˆìŠµë‹ˆë‹¤.) |
| ìˆ˜ì… ìˆ˜ìˆ˜ë£Œ |                                                                                                         ì™¸ë¶€ì—ì„œ ë“¤ì–´ì˜¤ëŠ” ë©”ì‹œì§€ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ì§€ë¶ˆí•˜ëŠ” ìˆ˜ìˆ˜ë£Œì…ë‹ˆë‹¤.                                                                                                        |
| ìƒíƒœ ì´ˆê¸°í™” |                                                       ë‚´ë¶€ ë©”ì‹œì§€ì™€ ë‹¬ë¦¬, ì™¸ë¶€ ë©”ì‹œì§€ ë‚´ì˜ ìƒíƒœ ì´ˆê¸°í™”ëŠ” **ì™¸ë¶€ ì„¸ê³„ì—ì„œ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë°°í¬í•˜ê¸° ìœ„í•´** í•„ìš”í•©ë‹ˆë‹¤. ë‚´ë¶€ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì‚¬ìš©ë˜ëŠ” ìƒíƒœ ì´ˆê¸°í™”ëŠ” í•œ ì»¨íŠ¸ë™íŠ¸ê°€ ë‹¤ë¥¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë°°í¬í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.                                                       |
| ë©”ì‹œì§€ ë³¸ë¬¸ |                                                                                                             ì²˜ë¦¬ë¥¼ ìœ„í•´ ê³„ì•½ì— ì „ì†¡í•´ì•¼ í•˜ëŠ” ë©”ì‹œì§€ì…ë‹ˆë‹¤.                                                                                                             |

:::tip 0b10
0b10(b - ë°”ì´ë„ˆë¦¬)ì€ ë°”ì´ë„ˆë¦¬ ë ˆì½”ë“œë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ ë‘ ë¹„íŠ¸ê°€ ì €ì¥ë©ë‹ˆë‹¤: 1`ê³¼ `0`ì…ë‹ˆë‹¤. ë”°ë¼ì„œ `ext_in_msg_info$10\`ì´ë¼ê³  ì§€ì •í•©ë‹ˆë‹¤.
:::

ì´ì œ ì»¨íŠ¸ë™íŠ¸ë¡œ ì „ì†¡í•  ì¤€ë¹„ê°€ ì™„ë£Œëœ ë©”ì‹œì§€ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ì„œëŠ” ë¨¼ì € `BOC`([Bag of Cells](/develop/data-formats/cell-boc#bag-of-cells))ë¡œ ì§ë ¬í™” í•œ ë‹¤ìŒ ë‹¤ìŒ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ì†¡í•´ì•¼ í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
console.log(externalMessage.toBoc().toString("base64"))

client.sendFile(externalMessage.toBoc());
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "encoding/base64"
  "github.com/xssnick/tonutils-go/tl"
)

log.Println(base64.StdEncoding.EncodeToString(externalMessage.ToBOCWithFlags(false)))

var resp tl.Serializable
err = client.Client().QueryLiteserver(context.Background(), ton.SendMessage{Body: externalMessage.ToBOCWithFlags(false)}, &resp)

if err != nil {
  log.Fatalln(err.Error())
  return
}
```

</TabItem>
</Tabs>

> ğŸ’¡ ìœ ìš©í•œ ë§í¬:
>
> [ë°± ì˜¤ë¸Œ ì…€ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê¸°](/ê°œë°œ/ë°ì´í„° í˜•ì‹/cell-boc#bag-of-cells)

ê·¸ ê²°ê³¼ ì½˜ì†”ì—ì„œ BOCì˜ ì¶œë ¥ê³¼ ì§€ê°‘ìœ¼ë¡œ ì „ì†¡ëœ íŠ¸ëœì­ì…˜ì„ í™•ì¸í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. base64ë¡œ ì¸ì½”ë”©ëœ ë¬¸ìì—´ì„ ë³µì‚¬í•˜ë©´ [ìˆ˜ë™ìœ¼ë¡œ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•˜ê³  í†¤ì„¼í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ì‹œë¥¼ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤](https://toncenter.com/api/v2/#/send/send_boc_return_hash_sendBocReturnHash_post).

## ğŸ‘› ì§€ê°‘ ë°°í¬

ì´ì œ ì§€ê°‘ì„ ë°°í¬í•˜ëŠ” ë° ë„ì›€ì´ ë  ë©”ì‹œì§€ ìƒì„±ì˜ ê¸°ë³¸ì„ ë°°ì› ìŠµë‹ˆë‹¤. ì´ì „ì—ëŠ” ì§€ê°‘ ì•±ì„ í†µí•´ ì§€ê°‘ì„ ë°°í¬í–ˆì§€ë§Œ, ì´ ê²½ìš°ì—ëŠ” ìˆ˜ë™ìœ¼ë¡œ ì§€ê°‘ì„ ë°°í¬í•´ì•¼ í•©ë‹ˆë‹¤.

ì´ ì„¹ì…˜ì—ì„œëŠ” ì§€ê°‘(ì§€ê°‘ v3)ì„ ì²˜ìŒë¶€í„° ë§Œë“œëŠ” ë°©ë²•ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ ì½”ë“œë¥¼ ì»´íŒŒì¼í•˜ê³ , ë‹ˆëª¨ë‹‰ ë¬¸êµ¬ë¥¼ ìƒì„±í•˜ê³ , ì§€ê°‘ ì£¼ì†Œë¥¼ ë°›ê³ , ì™¸ë¶€ íŠ¸ëœì­ì…˜ê³¼ ìƒíƒœ ì´ˆê¸°í™”ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ê°‘ì„ ë°°í¬í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê²Œ ë©ë‹ˆë‹¤.

### ë‹ˆëª¨ë‹‰ ìƒì„±

ì§€ê°‘ì„ ì˜¬ë°”ë¥´ê²Œ ìƒì„±í•˜ê¸° ìœ„í•´ ê°€ì¥ ë¨¼ì € í•„ìš”í•œ ê²ƒì€ 'ê°œì¸' í‚¤ì™€ 'ê³µê°œ' í‚¤ë¥¼ ê²€ìƒ‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ ë‹ˆëª¨ë‹‰ ì‹œë“œ êµ¬ë¬¸ì„ ìƒì„±í•œ ë‹¤ìŒ ì•”í˜¸í™” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°œì¸ í‚¤ì™€ ê³µê°œ í‚¤ë¥¼ ì¶”ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

ì´ ì‘ì—…ì€ ë‹¤ìŒê³¼ ê°™ì´ ìˆ˜í–‰ë©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { mnemonicToWalletKey, mnemonicNew } from '@ton/crypto';

// const mnemonicArray = 'put your mnemonic'.split(' ') // get our mnemonic as array
const mnemonicArray = await mnemonicNew(24); // 24 is the number of words in a seed phrase
const keyPair = await mnemonicToWalletKey(mnemonicArray); // extract private and public keys from mnemonic
console.log(mnemonicArray) // if we want, we can print our mnemonic
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/sha512"
	"log"
	"github.com/xssnick/tonutils-go/ton/wallet"
	"golang.org/x/crypto/pbkdf2"
	"strings"
)

// mnemonic := strings.Split("put your mnemonic", " ") // get our mnemonic as array
mnemonic := wallet.NewSeed() // get new mnemonic

// The following three lines will extract the private key using the mnemonic phrase. We will not go into cryptographic details. It has all been implemented in the tonutils-go library, but it immediately returns the finished object of the wallet with the address and ready methods. So weâ€™ll have to write the lines to get the key separately. Goland IDE will automatically import all required libraries (crypto, pbkdf2 and others).
mac := hmac.New(sha512.New, []byte(strings.Join(mnemonic, " "))) 
hash := mac.Sum(nil)
k := pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys
// 32 is a key len 

privateKey := ed25519.NewKeyFromSeed(k) // get private key
publicKey := privateKey.Public().(ed25519.PublicKey) // get public key from private key
log.Println(publicKey) // print publicKey so that at this stage the compiler does not complain that we do not use our variable
log.Println(mnemonic) // if we want, we can print our mnemonic
```

</TabItem>
</Tabs>

íŠ¸ëœì­ì…˜ì— ì„œëª…í•˜ë ¤ë©´ ê°œì¸ í‚¤ê°€ í•„ìš”í•˜ë©°, ê³µê°œ í‚¤ëŠ” ì§€ê°‘ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì— ì €ì¥ë©ë‹ˆë‹¤.

:::danger ì¤‘ìš”
ì§€ê°‘ ì½”ë“œë¥¼ ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ë™ì¼í•œ í‚¤ ìŒì„ ì‚¬ìš©í•˜ë ¤ë©´ ìƒì„±ëœ ë‹ˆëª¨ë‹‰ ì‹œë“œ ë¬¸êµ¬ë¥¼ ì½˜ì†”ì— ì¶œë ¥í•œ ë‹¤ìŒ ì €ì¥í•˜ê³  ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤(ì´ì „ ì„¹ì…˜ì—ì„œ ì„¤ëª…í•œ ëŒ€ë¡œ).
:::

### í•˜ìœ„ ì§€ê°‘ ID

ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì§€ê°‘ì˜ ê°€ì¥ ì£¼ëª©í•  ë§Œí•œ ì¥ì  ì¤‘ í•˜ë‚˜ëŠ” ë‹¨ í•˜ë‚˜ì˜ ê°œì¸ í‚¤ë¡œ **ë°©ëŒ€í•œ ìˆ˜ì˜ ì§€ê°‘**ì„ ìƒì„±í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì…ë‹ˆë‹¤. ì´ëŠ” TON ë¸”ë¡ì²´ì¸ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œê°€ 'stateInit'ì„ í¬í•¨í•œ ì—¬ëŸ¬ ìš”ì†Œë¥¼ ì‚¬ìš©í•˜ì—¬ ê³„ì‚°ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. stateInitì—ëŠ” ë¸”ë¡ì²´ì¸ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì €ì¥ì†Œì— ì €ì¥ë˜ëŠ” `ì½”ë“œ`ì™€ `ì´ˆê¸° ë°ì´í„°`ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

stateInit ë‚´ì—ì„œ í•œ ë¹„íŠ¸ë§Œ ë³€ê²½í•˜ë©´ ë‹¤ë¥¸ ì£¼ì†Œê°€ ìƒì„±ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì´ ë°”ë¡œ `subwallet_id`ê°€ ì²˜ìŒì— ìƒì„±ëœ ì´ìœ ì…ë‹ˆë‹¤. ì„œë¸Œì›”ë ›_id\`ëŠ” ì»¨íŠ¸ë™íŠ¸ ì €ì¥ì†Œì— ì €ì¥ë˜ë©°, í•˜ë‚˜ì˜ ê°œì¸ í‚¤ë¡œ ì—¬ëŸ¬ ê°œì˜ ë‹¤ë¥¸ ì§€ê°‘(ì„œë¸Œì›”ë › IDê°€ ë‹¤ë¥¸)ì„ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì€ ë‹¤ì–‘í•œ ì§€ê°‘ ìœ í˜•ì„ ê±°ë˜ì†Œì™€ ê°™ì€ ì¤‘ì•™í™”ëœ ì„œë¹„ìŠ¤ì™€ í†µí•©í•  ë•Œ ë§¤ìš° ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

TON ë¸”ë¡ì²´ì¸ì˜ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ê°€ì ¸ì˜¨ ì•„ë˜ [ì½”ë“œ ì¤„](https://github.com/ton-blockchain/ton/blob/4b940f8bad9c2d3bf44f196f6995963c7cee9cc3/tonlib/tonlib/TonlibClient.cpp#L2420)ì— ë”°ë¥´ë©´ ê¸°ë³¸ subwallet_id ê°’ì€ `698983191`ì…ë‹ˆë‹¤:

```cpp
res.wallet_id = td::as<td::uint32>(res.config.zero_state_id.root_hash.as_slice().data());
```

êµ¬ì„± íŒŒì¼](https://ton.org/global-config.json)ì—ì„œ ì œë„¤ì‹œìŠ¤ ë¸”ë¡ ì •ë³´(zero_state)ë¥¼ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ì— ëŒ€í•œ ë³µì¡í•˜ê³  ìì„¸í•œ ë‚´ìš©ì„ ì´í•´í•  í•„ìš”ëŠ” ì—†ì§€ë§Œ `subwallet_id`ì˜ ê¸°ë³¸ê°’ì€ `698983191`ì´ë¼ëŠ” ì ì„ ê¸°ì–µí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ê° ì§€ê°‘ ì»¨íŠ¸ë™íŠ¸ëŠ” ë‹¤ë¥¸ IDë¡œ ì§€ê°‘ì— ìš”ì²­ì´ ì „ì†¡ë˜ëŠ” ê²½ìš°ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ì™¸ë¶€ íŠ¸ëœì­ì…˜ì— ëŒ€í•´ subwallet_id í•„ë“œë¥¼ í™•ì¸í•©ë‹ˆë‹¤:

```func
var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
var (stored_seqno, stored_subwallet, public_key) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256));
throw_unless(34, subwallet_id == stored_subwallet);
```

ì»¨íŠ¸ë™íŠ¸ì˜ ì´ˆê¸° ë°ì´í„°ì— ìœ„ì˜ ê°’ì„ ì¶”ê°€í•´ì•¼ í•˜ë¯€ë¡œ ë³€ìˆ˜ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
const subWallet = 698983191;
```

</TabItem>
<TabItem value="go" label="Golang">

```go
var subWallet uint64 = 698983191
```

</TabItem>
</Tabs>

### ì§€ê°‘ ì½”ë“œ ì»´íŒŒì¼í•˜ê¸°

ì´ì œ ê°œì¸ í‚¤ì™€ ê³µê°œ í‚¤, ì„œë¸Œì›”ë › ì•„ì´ë””ê°€ ëª…í™•í•˜ê²Œ ì •ì˜ë˜ì—ˆìœ¼ë¯€ë¡œ ì§€ê°‘ ì½”ë“œë¥¼ ì»´íŒŒì¼í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ê³µì‹ ì €ì¥ì†Œì˜ [ì§€ê°‘ v3 ì½”ë“œ](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc)ë¥¼ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤.

ì§€ê°‘ ì½”ë“œë¥¼ ì»´íŒŒì¼í•˜ë ¤ë©´ [@ton-community/func-js](https://github.com/ton-community/func-js) ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©´ FunC ì½”ë“œë¥¼ ì»´íŒŒì¼í•˜ê³  ì½”ë“œê°€ í¬í•¨ëœ ì…€ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹œì‘í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ì¹˜í•˜ê³  `package.json`ì— ì €ì¥(--save)í•´ì•¼ í•©ë‹ˆë‹¤:

```bash
npm i --save @ton-community/func-js
```

ì½”ë“œ ì»´íŒŒì¼ì„ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ê¸°ë°˜ì´ë¯€ë¡œ ì½”ë“œ ì»´íŒŒì¼ì—ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ë§Œ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤.
í•˜ì§€ë§Œ ì»´íŒŒì¼ì´ ì™„ë£Œëœ í›„ ì…€ì˜ **base64 ì¶œë ¥**ë§Œ ìˆìœ¼ë©´ ì´ ì»´íŒŒì¼ëœ ì½”ë“œë¥¼ Go ë“±ì˜ ì–¸ì–´ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë¨¼ì € ë‘ ê°œì˜ íŒŒì¼ì„ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤: wallet_v3.fc`ì™€ `stdlib.fc`ì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” stdlib.fc ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í•¨ê»˜ ì‘ë™í•©ë‹ˆë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” `asm` ëª…ë ¹ì–´ì— í•´ë‹¹í•˜ëŠ” ëª¨ë“  í•„ìˆ˜ ë° ê¸°ë³¸ í•¨ìˆ˜ê°€ ë§Œë“¤ì–´ì ¸ ìˆìŠµë‹ˆë‹¤. stdlib.fc íŒŒì¼ì€ [ì—¬ê¸°](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc)ì—ì„œ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì§€ê°‘_v3.fc` íŒŒì¼ì— ìœ„ì˜ ì½”ë“œë¥¼ ë³µì‚¬í•´ì•¼ í•©ë‹ˆë‹¤.

ì´ì œ ìš°ë¦¬ê°€ ë§Œë“¤ê³  ìˆëŠ” í”„ë¡œì íŠ¸ì˜ êµ¬ì¡°ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```
.
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts
â”‚   â”œâ”€â”€ wallet_v3.fc
â”‚   â””â”€â”€ stdlib.fc
â”œâ”€â”€ nodemon.json
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

:::info
IDE í”ŒëŸ¬ê·¸ì¸ì´ `stdlib.fc` íŒŒì¼ì— ìˆëŠ” `() set_seed(int) impure asm "SETRAND";`ì™€ ì¶©ëŒí•˜ëŠ” ê²ƒì€ ê´œì°®ìŠµë‹ˆë‹¤.
:::

'wallet_v3.fc' íŒŒì¼ì˜ ì‹œì‘ ë¶€ë¶„ì— ë‹¤ìŒ ì¤„ì„ ì¶”ê°€í•˜ì—¬ ì•„ë˜ì—ì„œ stdlibì˜ í•¨ìˆ˜ê°€ ì‚¬ìš©ë¨ì„ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤:

```func
#include "stdlib.fc";
```

ì´ì œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì»´íŒŒì¼í•˜ê³  `npm run start:dev`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤:

```js
import { compileFunc } from '@ton-community/func-js';
import fs from 'fs'; // we use fs for reading content of files
import { Cell } from '@ton/core';

const result = await compileFunc({
targets: ['wallet_v3.fc'], // targets of your project
sources: {
    "stdlib.fc": fs.readFileSync('./src/stdlib.fc', { encoding: 'utf-8' }),
    "wallet_v3.fc": fs.readFileSync('./src/wallet_v3.fc', { encoding: 'utf-8' }),
}
});

if (result.status === 'error') {
console.error(result.message)
return;
}

const codeCell = Cell.fromBoc(Buffer.from(result.codeBoc, "base64"))[0]; // get buffer from base64 encoded BOC and get cell from this buffer

// now we have base64 encoded BOC with compiled code in result.codeBoc
console.log('Code BOC: ' + result.codeBoc);
console.log('\nHash: ' + codeCell.hash().toString('base64')); // get the hash of cell and convert in to base64 encoded string. We will need it further
```

ê²°ê³¼ëŠ” í„°ë¯¸ë„ì— ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤:

```text
Code BOC: te6ccgEBCAEAhgABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQCW8oMI1xgg0x/TH9MfAvgju/Jj7UTQ0x/TH9P/0VEyuvKhUUS68qIE+QFUEFX5EPKj+ACTINdKltMH1AL7AOgwAaTIyx/LH8v/ye1UAATQMAIBSAYHABe7Oc7UTQ0z8x1wv/gAEbjJftRNDXCx+A==

Hash: idlku00WfSC36ujyK2JVT92sMBEpCNRUXOGO4sJVBPA=
```

ì´ ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ê°‘ ì½”ë“œì™€ ë™ì¼í•œ ì…€(base64ë¡œ ì¸ì½”ë”©ëœ ì¶œë ¥ë¬¼ ì‚¬ìš©)ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="go" label="Golang">

```go
import (
  "encoding/base64"
  "github.com/xssnick/tonutils-go/tvm/cell"
)

base64BOC := "te6ccgEBCAEAhgABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQCW8oMI1xgg0x/TH9MfAvgju/Jj7UTQ0x/TH9P/0VEyuvKhUUS68qIE+QFUEFX5EPKj+ACTINdKltMH1AL7AOgwAaTIyx/LH8v/ye1UAATQMAIBSAYHABe7Oc7UTQ0z8x1wv/gAEbjJftRNDXCx+A==" // save our base64 encoded output from compiler to variable
codeCellBytes, _ := base64.StdEncoding.DecodeString(base64BOC) // decode base64 in order to get byte array
codeCell, err := cell.FromBOC(codeCellBytes) // get cell with code from byte array
if err != nil { // check if there are any error
  panic(err) 
}

log.Println("Hash:", base64.StdEncoding.EncodeToString(codeCell.Hash())) // get the hash of our cell, encode it to base64 because it has []byte type and output to the terminal
```

</TabItem>
</Tabs>

ê²°ê³¼ëŠ” í„°ë¯¸ë„ì— ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤:

```text
idlku00WfSC36ujyK2JVT92sMBEpCNRUXOGO4sJVBPA=
```

ìœ„ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì™„ë£Œë˜ë©´ í•´ì‹œê°€ ì¼ì¹˜í•˜ë¯€ë¡œ ì…€ ë‚´ì—ì„œ ì˜¬ë°”ë¥¸ ì½”ë“œê°€ ì‚¬ìš©ë˜ê³  ìˆìŒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ë°°í¬ë¥¼ ìœ„í•œ ìƒíƒœ ì´ˆê¸°í™” ë§Œë“¤ê¸°

íŠ¸ëœì­ì…˜ì„ êµ¬ì¶•í•˜ê¸° ì „ì— ìŠ¤í…Œì´íŠ¸ ì´ë‹ˆíŠ¸ê°€ ë¬´ì—‡ì¸ì§€ ì´í•´í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ë¨¼ì € [TL-B ì²´ê³„](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L141-L143)ë¥¼ ì‚´í´ë´…ì‹œë‹¤:

|             ì˜µì…˜             |                                                                                                                                                                              ì„¤ëª…                                                                                                                                                                             |
| :------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| ë¶„í• _ëìŠ¤ |                     ì´ ì˜µì…˜ì€ ì—¬ëŸ¬ [ìƒ¤ë“œì²´ì¸](/í•™ìŠµ/ê°œìš”/í†¤ë¸”ë¡ì²´ì¸#ë§ì€-ê³„ì •ì²´ì¸-ìƒ¤ë“œ)ì— ë¶„í• í•˜ì—¬ ìœ„ì¹˜ì‹œí‚¬ ìˆ˜ ìˆëŠ” ê³ ë¶€í•˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤.  ìì„¸í•œ ì‘ë™ ë°©ì‹ì€ [tblkch.pdf](https://ton.org/tblkch.pdf)(4.1.6)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë‚´ì—ì„œë§Œ ì‚¬ìš©ë˜ë¯€ë¡œ `0` ë¹„íŠ¸ë§Œ ì €ì¥ë©ë‹ˆë‹¤.                     |
|             íŠ¹ë³„             | í‹±í†¡ì— ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ëŸ¬í•œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ê° ë¸”ë¡ì— ëŒ€í•´ ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ë©° ì¼ë°˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ëŠ” í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ì— ëŒ€í•œ ì •ë³´ëŠ” [ì´ ì„¹ì…˜](/ê°œë°œ/ë°ì´í„°-í¬ë§·/íŠ¸ëœì­ì…˜-ë ˆì´ì•„ì›ƒ#í‹±í†¡) ë˜ëŠ” [tblkch.pdf](https://ton.org/tblkch.pdf)(4.1.6)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì‚¬ì–‘ì—ì„œëŠ” ì´ëŸ¬í•œ í•¨ìˆ˜ê°€ í•„ìš”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ `0` ë¹„íŠ¸ë§Œ ì €ì¥ë©ë‹ˆë‹¤. |
|             ì½”ë“œ             |                                                                                                                                                     1\` ë¹„íŠ¸ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì½”ë“œê°€ ì°¸ì¡°ë¡œ ì¡´ì¬í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.                                                                                                                                                    |
|             ë°ì´í„°            |                                                                                                                                                    '1' ë¹„íŠ¸ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë°ì´í„°ê°€ ì°¸ì¡°ë¡œ ì¡´ì¬í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.                                                                                                                                                    |
|            ë¼ì´ë¸ŒëŸ¬ë¦¬           |     ë§ˆìŠ¤í„°ì²´ì¸](/í•™ìŠµ/ê°œìš”/í†¤ë¸”ë¡ì²´ì¸#ë§ˆìŠ¤í„°ì²´ì¸-ë¸”ë¡ì²´ì¸-ë¸”ë¡ì²´ì¸)ì—ì„œ ì‘ë™í•˜ë©° ë‹¤ë¥¸ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤. ì§€ê°‘ì—ëŠ” ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë¹„íŠ¸ëŠ” `0`ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤. ì´ì— ëŒ€í•œ ì •ë³´ëŠ” [tblkch.pdf](https://ton.org/tblkch.pdf)(1.8.4)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.    |

ë‹¤ìŒìœ¼ë¡œ ë°°í¬ ì§í›„ ì»¨íŠ¸ë™íŠ¸ì˜ ì €ì¥ì†Œì— ì¡´ì¬í•  'ì´ˆê¸° ë°ì´í„°'ë¥¼ ì¤€ë¹„í•˜ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { beginCell } from '@ton/core';

const dataCell = beginCell()
  .storeUint(0, 32) // Seqno
  .storeUint(698983191, 32) // Subwallet ID
  .storeBuffer(keyPair.publicKey) // Public Key
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
dataCell := cell.BeginCell().
  MustStoreUInt(0, 32). // Seqno
  MustStoreUInt(698983191, 32). // Subwallet ID
  MustStoreSlice(publicKey, 256). // Public Key
  EndCell()
```

</TabItem>
</Tabs>

ì´ ë‹¨ê³„ì—ì„œëŠ” ì»¨íŠ¸ë™íŠ¸ 'ì½”ë“œ'ì™€ 'ì´ˆê¸° ë°ì´í„°'ê°€ ëª¨ë‘ ì¡´ì¬í•©ë‹ˆë‹¤. ì´ ë°ì´í„°ë¡œ **ì§€ê°‘ ì£¼ì†Œ**ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì§€ê°‘ ì£¼ì†ŒëŠ” ì½”ë“œì™€ ì´ˆê¸° ë°ì´í„°ê°€ í¬í•¨ëœ ìƒíƒœ ì´ˆê¸°í™”ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address } from '@ton/core';

const stateInit = beginCell()
  .storeBit(0) // No split_depth
  .storeBit(0) // No special
  .storeBit(1) // We have code
  .storeRef(codeCell)
  .storeBit(1) // We have data
  .storeRef(dataCell)
  .storeBit(0) // No library
  .endCell();

const contractAddress = new Address(0, stateInit.hash()); // get the hash of stateInit to get the address of our smart contract in workchain with ID 0
console.log(`Contract address: ${contractAddress.toString()}`); // Output contract address to console
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/address"
)

stateInit := cell.BeginCell().
  MustStoreBoolBit(false). // No split_depth
  MustStoreBoolBit(false). // No special
  MustStoreBoolBit(true). // We have code
  MustStoreRef(codeCell).
  MustStoreBoolBit(true). // We have data
  MustStoreRef(dataCell).
  MustStoreBoolBit(false). // No library
  EndCell()

contractAddress := address.NewAddress(0, 0, stateInit.Hash()) // get the hash of stateInit to get the address of our smart contract in workchain with ID 0
log.Println("Contract address:", contractAddress.String()) // Output contract address to console
```

</TabItem>
</Tabs>

ì´ì œ ìƒíƒœ ì´ˆê¸°í™”ë¥¼ ì‚¬ìš©í•´ íŠ¸ëœì­ì…˜ì„ ìƒì„±í•˜ê³  ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ì „ì†¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì„ ìˆ˜í–‰í•˜ë ¤ë©´ **ìµœì†Œ 0.1í†¤**ì˜ ì§€ê°‘ ì”ì•¡ì´ í•„ìš”í•©ë‹ˆë‹¤(ì”ì•¡ì€ ë” ì ì„ ìˆ˜ ìˆì§€ë§Œ, ì´ ê¸ˆì•¡ì´ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤). ì´ë¥¼ ìœ„í•´ì„œëŠ” íŠœí† ë¦¬ì–¼ì˜ ì•ë¶€ë¶„ì—ì„œ ì–¸ê¸‰í•œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  ì˜¬ë°”ë¥¸ ì§€ê°‘ ì£¼ì†Œë¥¼ ì–»ì€ ë‹¤ìŒ ì´ ì£¼ì†Œë¡œ 0.1í†¤ì„ ë³´ë‚´ì•¼ í•©ë‹ˆë‹¤.

ì´ì „ ì„¹ì…˜\*\*ì—ì„œ êµ¬ì¶•í•œ íŠ¸ëœì­ì…˜ê³¼ ìœ ì‚¬í•œ íŠ¸ëœì­ì…˜ì„ êµ¬ì¶•í•˜ëŠ” ê²ƒë¶€í„° ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { sign } from '@ton/crypto';
import { toNano } from '@ton/core';

const internalMessageBody = beginCell()
  .storeUint(0, 32)
  .storeStringTail("Hello, TON!")
  .endCell();

const internalMessage = beginCell()
  .storeUint(0x10, 6) // no bounce
  .storeAddress(Address.parse("put your first wallet address from were you sent 0.1 TON"))
  .storeCoins(toNano("0.03"))
  .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) // We store 1 that means we have body as a reference
  .storeRef(internalMessageBody)
  .endCell();

// transaction for our wallet
const toSign = beginCell()
  .storeUint(subWallet, 32)
  .storeUint(Math.floor(Date.now() / 1e3) + 60, 32)
  .storeUint(0, 32) // We put seqno = 0, because after deploying wallet will store 0 as seqno
  .storeUint(3, 8)
  .storeRef(internalMessage);

const signature = sign(toSign.endCell().hash(), keyPair.secretKey);
const body = beginCell()
  .storeBuffer(signature)
  .storeBuilder(toSign)
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/tlb"
  "time"
)

internalMessageBody := cell.BeginCell().
  MustStoreUInt(0, 32).
  MustStoreStringSnake("Hello, TON!").
  EndCell()

internalMessage := cell.BeginCell().
  MustStoreUInt(0x10, 6). // no bounce
  MustStoreAddr(address.MustParseAddr("put your first wallet address from were you sent 0.1 TON")).
  MustStoreBigCoins(tlb.MustFromTON("0.03").NanoTON()).
  MustStoreUInt(1, 1 + 4 + 4 + 64 + 32 + 1 + 1). // We store 1 that means we have body as a reference
  MustStoreRef(internalMessageBody).
  EndCell()

// transaction for our wallet
toSign := cell.BeginCell().
  MustStoreUInt(subWallet, 32).
  MustStoreUInt(uint64(time.Now().UTC().Unix()+60), 32).
  MustStoreUInt(0, 32). // We put seqno = 0, because after deploying wallet will store 0 as seqno
  MustStoreUInt(3, 8).
  MustStoreRef(internalMessage)

signature := ed25519.Sign(privateKey, toSign.EndCell().Hash())
body := cell.BeginCell().
  MustStoreSlice(signature, 512).
  MustStoreBuilder(toSign).
	EndCell()
```

</TabItem>
</Tabs>

ì´ ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ì˜¬ë°”ë¥¸ ìƒíƒœ ì´ˆê¸°í™” ë° ë©”ì‹œì§€ ë³¸ë¬¸ì´ ìƒì„±ë©ë‹ˆë‹¤.

### ì™¸ë¶€ ê±°ë˜ ë³´ë‚´ê¸°

ê°€ì¥ í° ì°¨ì´ì ì€ ì˜¬ë°”ë¥¸ ì»¨íŠ¸ë™íŠ¸ ë°°í¬ë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ State Initì´ ì €ì¥ë˜ê¸° ë•Œë¬¸ì— ì™¸ë¶€ ë©”ì‹œì§€ê°€ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì»¨íŠ¸ë™íŠ¸ì—ëŠ” ì•„ì§ ìì²´ ì½”ë“œê°€ ì—†ìœ¼ë¯€ë¡œ ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë‹¤ìŒìœ¼ë¡œ ì½”ë“œì™€ ì´ˆê¸° ë°ì´í„°ë¥¼ **ì„±ê³µì ìœ¼ë¡œ ë°°í¬ëœ í›„** "Hello, TON!" ì½”ë©˜íŠ¸ì™€ í•¨ê»˜ ì „ì†¡í•˜ì—¬ ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
const externalMessage = beginCell()
  .storeUint(0b10, 2) // indicate that it is an incoming external transaction
  .storeUint(0, 2) // src -> addr_none
  .storeAddress(contractAddress)
  .storeCoins(0) // Import fee
  .storeBit(1) // We have State Init
  .storeBit(1) // We store State Init as a reference
  .storeRef(stateInit) // Store State Init as a reference
  .storeBit(1) // We store Message Body as a reference
  .storeRef(body) // Store Message Body as a reference
  .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
externalMessage := cell.BeginCell().
  MustStoreUInt(0b10, 2). // indicate that it is an incoming external transaction
  MustStoreUInt(0, 2). // src -> addr_none
  MustStoreAddr(contractAddress).
  MustStoreCoins(0). // Import fee
  MustStoreBoolBit(true). // We have State Init
  MustStoreBoolBit(true).  // We store State Init as a reference
  MustStoreRef(stateInit). // Store State Init as a reference
  MustStoreBoolBit(true). // We store Message Body as a reference
  MustStoreRef(body). // Store Message Body as a reference
  EndCell()
```

</TabItem>
</Tabs>

ë§ˆì§€ë§‰ìœ¼ë¡œ íŠ¸ëœì­ì…˜ì„ ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ì „ì†¡í•˜ì—¬ ì§€ê°‘ì„ ë°°í¬í•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { TonClient } from '@ton/ton';

const client = new TonClient({
  endpoint: "https://toncenter.com/api/v2/jsonRPC",
  apiKey: "put your api key" // you can get an api key from @tonapibot bot in Telegram
});

client.sendFile(externalMessage.toBoc());
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "context"
  "github.com/xssnick/tonutils-go/liteclient"
  "github.com/xssnick/tonutils-go/tl"
  "github.com/xssnick/tonutils-go/ton"
)

connection := liteclient.NewConnectionPool()
configUrl := "https://ton-blockchain.github.io/global.config.json"
err := connection.AddConnectionsFromConfigUrl(context.Background(), configUrl)
if err != nil {
  panic(err)
}
client := ton.NewAPIClient(connection)

var resp tl.Serializable
err = client.Client().QueryLiteserver(context.Background(), ton.SendMessage{Body: externalMessage.ToBOCWithFlags(false)}, &resp)
if err != nil {
  log.Fatalln(err.Error())
  return
}
```

</TabItem>
</Tabs>

ëª¨ë“œ `3`ì„ ì‚¬ìš©í•˜ì—¬ ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤. ë™ì¼í•œ ì§€ê°‘ì˜ ë°°í¬ë¥¼ ë°˜ë³µí•´ì•¼ í•˜ëŠ” ê²½ìš° **ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ íŒŒê¸°**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ì„œëŠ” 128(ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì „ì²´ ì”ì•¡ ê°€ì ¸ê°€ê¸°) + 32(ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ íŒŒê¸°)ë¥¼ ë”í•˜ì—¬ `160`ìœ¼ë¡œ ëª¨ë“œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•˜ë©´ ë‚¨ì€ TON ì”ì•¡ì„ ê°€ì ¸ì™€ ì§€ê°‘ì„ ë‹¤ì‹œ ë°°í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìƒˆ íŠ¸ëœì­ì…˜ì´ ë°œìƒí•  ë•Œë§ˆë‹¤ **seqno**ë¥¼ í•˜ë‚˜ì”© ëŠ˜ë ¤ì•¼ í•œë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”.

:::info
ìš°ë¦¬ê°€ ì‚¬ìš©í•œ ê³„ì•½ ì½”ë“œëŠ” [í™•ì¸ë¨](https://tonscan.org/tx/BL9T1i5DjX1JRLUn4z9JOgOWRKWQ80pSNevis26hGvc=)ì´ë©°, [ì—¬ê¸°](https://tonscan.org/address/EQDBjzo_iQCZh3bZSxFnK9ue4hLTOKgsCNKfC8LOUM4SlSCX#source)ì—ì„œ ì˜ˆì‹œë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

## ğŸ’¸ ì›”ë › ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¡œ ì‘ì—…í•˜ê¸°

ì´ íŠœí† ë¦¬ì–¼ì˜ ì „ë°˜ë¶€ë¥¼ ë§ˆì¹œ í›„ì—ëŠ” ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì™€ ê·¸ ê°œë°œ ë° ì‚¬ìš© ë°©ì‹ì— ëŒ€í•´ í›¨ì”¬ ë” ìµìˆ™í•´ì¡ŒìŠµë‹ˆë‹¤. ë¯¸ë¦¬ êµ¬ì„±ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë°°í¬ ë° ì†Œë©¸í•˜ê³  ë©”ì‹œì§€ë¥¼ ì „ì†¡í•˜ëŠ” ë°©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤. ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” ìœ„ì—ì„œ ë°°ìš´ ë‚´ìš©ì„ ë” ë§ì´ ì ìš©í•˜ê¸° ìœ„í•´ ì¢€ ë” ë³µì¡í•œ ë©”ì‹œì§€ë¥¼ êµ¬ì¶•í•˜ê³  ì „ì†¡í•˜ëŠ” ë° ì§‘ì¤‘í•˜ê² ìŠµë‹ˆë‹¤.

### ì—¬ëŸ¬ ê°œì˜ ë©”ì‹œì§€ë¥¼ ë™ì‹œì— ë³´ë‚´ê¸°

ì´ë¯¸ ì•Œê³  ê³„ì‹œê² ì§€ë§Œ, [í•˜ë‚˜ì˜ ì…€ì€ ìµœëŒ€ 1023ë¹„íŠ¸ì˜ ë°ì´í„°ì™€ ìµœëŒ€ 4ê°œì˜ ì°¸ì¡°ë¥¼ ë‹¤ë¥¸ ì…€ì— ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤](/ê°œë°œ/ë°ì´í„°-í¬ë§·/ì…€-boc#ì…€). ì´ íŠœí† ë¦¬ì–¼ì˜ ì²« ë²ˆì§¸ ì„¹ì…˜ì—ì„œëŠ” ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ 'ì „ì²´' ë£¨í”„ë¥¼ í†µí•´ ë§í¬ë¡œ ì „ë‹¬í•˜ê³  ì „ì†¡í•˜ëŠ” ë°©ë²•ì„ ìì„¸íˆ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤. ì¦‰, ì™¸ë¶€\*\* ë©”ì‹œì§€ ì•ˆì— ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ìµœëŒ€ 4ê°œê¹Œì§€ \*\*ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ 4ê°œì˜ íŠ¸ëœì­ì…˜ì„ ë™ì‹œì— ì „ì†¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë¥¼ ìœ„í•´ì„œëŠ” 4ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ ì‘ì—…ì€ ìˆ˜ë™ìœ¼ë¡œ ë˜ëŠ” 'ë£¨í”„'ë¥¼ í†µí•´ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. TON ê¸ˆì•¡ ë°°ì—´, ëŒ“ê¸€ ë°°ì—´, ë©”ì‹œì§€ ë°°ì—´ì˜ ì„¸ ê°€ì§€ ë°°ì—´ì„ ì •ì˜í•´ì•¼ í•©ë‹ˆë‹¤. ë©”ì‹œì§€ì˜ ê²½ìš° ë‚´ë¶€ ë©”ì‹œì§€ë¼ëŠ” ë˜ í•˜ë‚˜ì˜ ë°°ì—´ì„ ì¤€ë¹„í•´ì•¼ í•©ë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Cell } from '@ton/core';

const internalMessagesAmount = ["0.01", "0.02", "0.03", "0.04"];
const internalMessagesComment = [
  "Hello, TON! #1",
  "Hello, TON! #2",
  "", // Let's leave the third transaction without comment
  "Hello, TON! #4" 
]
const destinationAddresses = [
  "Put any address that belongs to you",
  "Put any address that belongs to you",
  "Put any address that belongs to you",
  "Put any address that belongs to you"
] // All 4 addresses can be the same

let internalMessages:Cell[] = []; // array for our internal messages
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/tvm/cell"
)

internalMessagesAmount := [4]string{"0.01", "0.02", "0.03", "0.04"}
internalMessagesComment := [4]string{
  "Hello, TON! #1",
  "Hello, TON! #2",
  "", // Let's leave the third transaction without comment
  "Hello, TON! #4",
}
destinationAddresses := [4]string{
  "Put any address that belongs to you",
  "Put any address that belongs to you",
  "Put any address that belongs to you",
  "Put any address that belongs to you",
} // All 4 addresses can be the same

var internalMessages [len(internalMessagesAmount)]*cell.Cell // array for our internal messages
```

</TabItem>
</Tabs>

ëª¨ë“  ë©”ì‹œì§€ì— ëŒ€í•œ [ì „ì†¡ ëª¨ë“œ](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ê³„ì•½/ë©”ì‹œì§€#ë©”ì‹œì§€-ëª¨ë“œ)ëŠ” 'ëª¨ë“œ 3'ìœ¼ë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  ê·¸ëŸ¬ë‚˜ ë‹¤ë¥¸ ëª¨ë“œê°€ í•„ìš”í•œ ê²½ìš° ë‹¤ë¥¸ ëª©ì ì„ ë‹¬ì„±í•˜ê¸° ìœ„í•´ ë°°ì—´ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, beginCell, toNano } from '@ton/core';

for (let index = 0; index < internalMessagesAmount.length; index++) {
  const amount = internalMessagesAmount[index];
  
  let internalMessage = beginCell()
      .storeUint(0x18, 6) // bounce
      .storeAddress(Address.parse(destinationAddresses[index]))
      .storeCoins(toNano(amount))
      .storeUint(0, 1 + 4 + 4 + 64 + 32 + 1);
      
  /*
      At this stage, it is not clear if we will have a message body. 
      So put a bit only for stateInit, and if we have a comment, in means 
      we have a body message. In that case, set the bit to 1 and store the 
      body as a reference.
  */

  if(internalMessagesComment[index] != "") {
    internalMessage.storeBit(1) // we store Message Body as a reference

    let internalMessageBody = beginCell()
      .storeUint(0, 32)
      .storeStringTail(internalMessagesComment[index])
      .endCell();

    internalMessage.storeRef(internalMessageBody);
  } 
  else 
    /*
        Since we do not have a message body, we indicate that 
        the message body is in this message, but do not write it, 
        which means it is absent. In that case, just set the bit to 0.
    */
    internalMessage.storeBit(0);
  
  internalMessages.push(internalMessage.endCell());
}
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/address"
  "github.com/xssnick/tonutils-go/tlb"
)

for i := 0; i < len(internalMessagesAmount); i++ {
  amount := internalMessagesAmount[i]

  internalMessage := cell.BeginCell().
    MustStoreUInt(0x18, 6). // bounce
    MustStoreAddr(address.MustParseAddr(destinationAddresses[i])).
    MustStoreBigCoins(tlb.MustFromTON(amount).NanoTON()).
    MustStoreUInt(0, 1+4+4+64+32+1)

  /*
      At this stage, it is not clear if we will have a message body. 
      So put a bit only for stateInit, and if we have a comment, in means 
      we have a body message. In that case, set the bit to 1 and store the 
      body as a reference.
  */

  if internalMessagesComment[i] != "" {
    internalMessage.MustStoreBoolBit(true) // we store Message Body as a reference

    internalMessageBody := cell.BeginCell().
      MustStoreUInt(0, 32).
      MustStoreStringSnake(internalMessagesComment[i]).
      EndCell()

    internalMessage.MustStoreRef(internalMessageBody)
  } else {
    /*
        Since we do not have a message body, we indicate that
        the message body is in this message, but do not write it,
        which means it is absent. In that case, just set the bit to 0.
    */
    internalMessage.MustStoreBoolBit(false)
  }
  internalMessages[i] = internalMessage.EndCell()
}
```

</TabItem>
</Tabs>

ì´ì œ [2ì¥](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸/ììŠµì„œ/ì§€ê°‘#-ì§€ê°‘ ë°°í¬í•˜ê¸°)ì—ì„œ ë°°ìš´ ì§€ì‹ì„ í™œìš©í•˜ì—¬ 4ê°œì˜ íŠ¸ëœì­ì…˜ì„ ë™ì‹œì— ì „ì†¡í•  ìˆ˜ ìˆëŠ” ì§€ê°‘ì„ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { TonClient } from '@ton/ton';
import { mnemonicToWalletKey } from '@ton/crypto';

const walletAddress = Address.parse('put your wallet address');
const client = new TonClient({
  endpoint: "https://toncenter.com/api/v2/jsonRPC",
  apiKey: "put your api key" // you can get an api key from @tonapibot bot in Telegram
});

const mnemonic = 'put your mnemonic'; // word1 word2 word3
let getMethodResult = await client.runMethod(walletAddress, "seqno"); // run "seqno" GET method from your wallet contract
let seqno = getMethodResult.stack.readNumber(); // get seqno from response

const mnemonicArray = mnemonic.split(' '); // get array from string
const keyPair = await mnemonicToWalletKey(mnemonicArray); // get Secret and Public keys from mnemonic 

let toSign = beginCell()
  .storeUint(698983191, 32) // subwallet_id
  .storeUint(Math.floor(Date.now() / 1e3) + 60, 32) // Transaction expiration time, +60 = 1 minute
  .storeUint(seqno, 32); // store seqno
  // Do not forget that if we use Wallet V4, we need to add .storeUint(0, 8) 
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
	"context"
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/sha512"
	"github.com/xssnick/tonutils-go/liteclient"
	"github.com/xssnick/tonutils-go/ton"
	"golang.org/x/crypto/pbkdf2"
	"log"
	"strings"
	"time"
)

walletAddress := address.MustParseAddr("put your wallet address")

connection := liteclient.NewConnectionPool()
configUrl := "https://ton-blockchain.github.io/global.config.json"
err := connection.AddConnectionsFromConfigUrl(context.Background(), configUrl)
if err != nil {
  panic(err)
}
client := ton.NewAPIClient(connection)

mnemonic := strings.Split("put your mnemonic", " ") // word1 word2 word3
// The following three lines will extract the private key using the mnemonic phrase.
// We will not go into cryptographic details. In the library tonutils-go, it is all implemented,
// but it immediately returns the finished object of the wallet with the address and ready-made methods.
// So weâ€™ll have to write the lines to get the key separately. Goland IDE will automatically import
// all required libraries (crypto, pbkdf2 and others).
mac := hmac.New(sha512.New, []byte(strings.Join(mnemonic, " ")))
hash := mac.Sum(nil)
k := pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys
// 32 is a key len
privateKey := ed25519.NewKeyFromSeed(k)              // get private key

block, err := client.CurrentMasterchainInfo(context.Background()) // get current block, we will need it in requests to LiteServer
if err != nil {
  log.Fatalln("CurrentMasterchainInfo err:", err.Error())
  return
}

getMethodResult, err := client.RunGetMethod(context.Background(), block, walletAddress, "seqno") // run "seqno" GET method from your wallet contract
if err != nil {
  log.Fatalln("RunGetMethod err:", err.Error())
  return
}
seqno := getMethodResult.MustInt(0) // get seqno from response

toSign := cell.BeginCell().
  MustStoreUInt(698983191, 32). // subwallet_id | We consider this further
  MustStoreUInt(uint64(time.Now().UTC().Unix()+60), 32). // transaction expiration time, +60 = 1 minute
  MustStoreUInt(seqno.Uint64(), 32) // store seqno
  // Do not forget that if we use Wallet V4, we need to add MustStoreUInt(0, 8). 
```

</TabItem>
</Tabs>

ë‹¤ìŒìœ¼ë¡œ ì•ì„œ ë£¨í”„ì—ì„œ ì‘ì„±í•œ ë©”ì‹œì§€ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
for (let index = 0; index < internalMessages.length; index++) {
  const internalMessage = internalMessages[index];
  toSign.storeUint(3, 8) // store mode of our internal transaction
  toSign.storeRef(internalMessage) // store our internalMessage as a reference
}
```

</TabItem>
<TabItem value="go" label="Golang">

```go
for i := 0; i < len(internalMessages); i++ {
		internalMessage := internalMessages[i]
		toSign.MustStoreUInt(3, 8) // store mode of our internal transaction
		toSign.MustStoreRef(internalMessage) // store our internalMessage as a reference
}
```

</TabItem>
</Tabs>

ìœ„ì˜ ê³¼ì •ì´ ì™„ë£Œë˜ì—ˆìœ¼ë¯€ë¡œ ì´ì œ ë©”ì‹œì§€ë¥¼ **ì„œëª…**í•˜ê³ , (ì´ íŠœí† ë¦¬ì–¼ì˜ ì´ì „ ì„¹ì…˜ì—ì„œ ì„¤ëª…í•œ ëŒ€ë¡œ) ì™¸ë¶€ ë©”ì‹œì§€ë¥¼ ì‘ì„±í•˜ì—¬ ë¸”ë¡ì²´ì¸ì— **ì „ì†¡**í•´ ë³´ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { sign } from '@ton/crypto';

let signature = sign(toSign.endCell().hash(), keyPair.secretKey); // get the hash of our message to wallet smart contract and sign it to get signature

let body = beginCell()
    .storeBuffer(signature) // store signature
    .storeBuilder(toSign) // store our message
    .endCell();

let externalMessage = beginCell()
    .storeUint(0b10, 2) // ext_in_msg_info$10
    .storeUint(0, 2) // src -> addr_none
    .storeAddress(walletAddress) // Destination address
    .storeCoins(0) // Import Fee
    .storeBit(0) // No State Init
    .storeBit(1) // We store Message Body as a reference
    .storeRef(body) // Store Message Body as a reference
    .endCell();

client.sendFile(externalMessage.toBoc());
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/tl"
)

signature := ed25519.Sign(privateKey, toSign.EndCell().Hash()) // get the hash of our message to wallet smart contract and sign it to get signature

body := cell.BeginCell().
  MustStoreSlice(signature, 512). // store signature
  MustStoreBuilder(toSign). // store our message
  EndCell()

externalMessage := cell.BeginCell().
  MustStoreUInt(0b10, 2). // ext_in_msg_info$10
  MustStoreUInt(0, 2). // src -> addr_none
  MustStoreAddr(walletAddress). // Destination address
  MustStoreCoins(0). // Import Fee
  MustStoreBoolBit(false). // No State Init
  MustStoreBoolBit(true). // We store Message Body as a reference
  MustStoreRef(body). // Store Message Body as a reference
  EndCell()

var resp tl.Serializable
err = client.Client().QueryLiteserver(context.Background(), ton.SendMessage{Body: externalMessage.ToBOCWithFlags(false)}, &resp)

if err != nil {
  log.Fatalln(err.Error())
  return
}
```

</TabItem>
</Tabs>

:::info ì—°ê²° ì˜¤ë¥˜
ë¼ì´íŠ¸ ì„œë²„ ì—°ê²°(Golang)ê³¼ ê´€ë ¨ëœ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•  ìˆ˜ ìˆì„ ë•Œê¹Œì§€ ì½”ë“œë¥¼ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” í†¤íˆ´ì¦ˆ-ê³  ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì½”ë“œì— ì§€ì •ëœ ì „ì—­ êµ¬ì„±ì„ í†µí•´ ì—¬ëŸ¬ ê°œì˜ ë‹¤ë¥¸ ë¼ì´íŠ¸ ì„œë²„ë¥¼ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ëª¨ë“  ë¼ì´íŠ¸ ì„œë²„ê°€ ì—°ê²°ì„ ìˆ˜ë½í•  ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤.
:::

ì´ í”„ë¡œì„¸ìŠ¤ê°€ ì™„ë£Œë˜ë©´ TON ë¸”ë¡ì²´ì¸ íƒìƒ‰ê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ê°‘ì´ ì´ì „ì— ì§€ì •í•œ ì£¼ì†Œë¡œ 4ê°œì˜ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í–ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### NFT ì „ì†¡

ì¼ë°˜ íŠ¸ëœì­ì…˜ ì™¸ì—ë„ ì‚¬ìš©ìë“¤ì€ ì¢…ì¢… NFTë¥¼ ì„œë¡œì—ê²Œ ì „ì†¡í•˜ê¸°ë„ í•©ë‹ˆë‹¤. ì•ˆíƒ€ê¹ê²Œë„ ëª¨ë“  ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì´ëŸ¬í•œ ìœ í˜•ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë©”ì„œë“œê°€ í¬í•¨ë˜ì–´ ìˆëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. ë”°ë¼ì„œ NFT ì „ì†¡ì„ ìœ„í•œ íŠ¸ëœì­ì…˜ì„ êµ¬ì¶•í•  ìˆ˜ ìˆëŠ” ì½”ë“œë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤. ë¨¼ì € TON NFT [í‘œì¤€](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md)ì— ëŒ€í•´ ë” ìì„¸íˆ ì•Œì•„ë´…ì‹œë‹¤.

íŠ¹íˆ [NFT ì „ì†¡](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#1-transfer)ì„ ìœ„í•œ TL-Bì— ëŒ€í•œ ìì„¸í•œ ì´í•´ê°€ í•„ìš”í•©ë‹ˆë‹¤.

- ì¿¼ë¦¬ ID\`: ì¿¼ë¦¬ IDëŠ” íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ì¸¡ë©´ì—ì„œ ì•„ë¬´ëŸ° ê°€ì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤. NFT ì»¨íŠ¸ë™íŠ¸ëŠ” ì´ë¥¼ ê²€ì¦í•˜ì§€ ì•Šê³  ì½ê¸°ë§Œ í•©ë‹ˆë‹¤. ì´ ê°’ì€ ì„œë¹„ìŠ¤ê°€ ì‹ë³„ ëª©ì ìœ¼ë¡œ ê° íŠ¸ëœì­ì…˜ì— íŠ¹ì • ì¿¼ë¦¬ IDë¥¼ í• ë‹¹í•˜ê³ ì í•  ë•Œ ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ 0ìœ¼ë¡œ ì„¤ì •í•˜ê² ìŠµë‹ˆë‹¤.

- ì‘ë‹µ_ëŒ€ìƒ\`: ì†Œìœ ê¶Œ ë³€ê²½ íŠ¸ëœì­ì…˜ì„ ì²˜ë¦¬í•œ í›„ ì¶”ê°€ TONì´ ë°œìƒí•©ë‹ˆë‹¤. ì§€ì •í•œ ê²½ìš° ì´ ì£¼ì†Œë¡œ ì „ì†¡ë˜ë©°, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ NFT ì”ê³ ì— ë‚¨ì•„ ìˆìŠµë‹ˆë‹¤.

- ì»¤ìŠ¤í…€ í˜ì´ë¡œë“œ\`: custom_payloadëŠ” íŠ¹ì • ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë° í•„ìš”í•˜ë©° ì¼ë°˜ NFTì—ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

- forward_amount\`: forward_amountê°€ 0ì´ ì•„ë‹Œ ê²½ìš°, ì§€ì •ëœ TON ê¸ˆì•¡ì´ ìƒˆ ì†Œìœ ìì—ê²Œ ì „ì†¡ë©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ìƒˆ ì†Œìœ ìëŠ” ë¬´ì–¸ê°€ë¥¼ ë°›ì•˜ë‹¤ëŠ” ì•Œë¦¼ì„ ë°›ê²Œ ë©ë‹ˆë‹¤.

- í¬ì›Œë“œ_í˜ì´ë¡œë“œ\`: forward_payloadëŠ” forward_amountì™€ í•¨ê»˜ ìƒˆ ì†Œìœ ìì—ê²Œ ì „ì†¡í•  ìˆ˜ ìˆëŠ” ì¶”ê°€ ë°ì´í„°ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì•ì„œ íŠœí† ë¦¬ì–¼ì—ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ forward_payloadë¥¼ ì‚¬ìš©í•˜ë©´ [NFT ì „ì†¡ ì¤‘ ì½”ë©˜íŠ¸ë¥¼ ì¶”ê°€](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#forward_payload-format)í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ forward_payloadëŠ” TONì˜ NFT í‘œì¤€ì— ë”°ë¼ ì‘ì„±ë˜ì—ˆì§€ë§Œ, ë¸”ë¡ì²´ì¸ íƒìƒ‰ê¸°ëŠ” ë‹¤ì–‘í•œ ì„¸ë¶€ ì •ë³´ í‘œì‹œë¥¼ ì™„ë²½í•˜ê²Œ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì œí†¤ì„ í‘œì‹œí•  ë•Œë„ ë™ì¼í•œ ë¬¸ì œê°€ ì¡´ì¬í•©ë‹ˆë‹¤.

ì´ì œ íŠ¸ëœì­ì…˜ ìì²´ë¥¼ êµ¬ì¶•í•´ ë³´ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, beginCell, toNano } from '@ton/core';

const destinationAddress = Address.parse("put your wallet where you want to send NFT");
const walletAddress = Address.parse("put your wallet which is the owner of NFT")
const nftAddress = Address.parse("put your nft address");

// We can add a comment, but it will not be displayed in the explorers, 
// as it is not supported by them at the time of writing the tutorial.
const forwardPayload = beginCell()
  .storeUint(0, 32)
  .storeStringTail("Hello, TON!")
  .endCell();

const transferNftBody = beginCell()
  .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
  .storeUint(0, 64) // query_id
  .storeAddress(destinationAddress) // new_owner
  .storeAddress(walletAddress) // response_destination for excesses
  .storeBit(0) // we do not have custom_payload
  .storeCoins(toNano("0.01")) // forward_amount
  .storeBit(1) // we store forward_payload as a reference
  .storeRef(forwardPayload) // store forward_payload as a .reference
  .endCell();

const internalMessage = beginCell().
  storeUint(0x18, 6). // bounce
  storeAddress(nftAddress).
  storeCoins(toNano("0.05")).
  storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1). // We store 1 that means we have body as a reference
  storeRef(transferNftBody).
  endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/address"
  "github.com/xssnick/tonutils-go/tlb"
  "github.com/xssnick/tonutils-go/tvm/cell"
)

destinationAddress := address.MustParseAddr("put your wallet where you want to send NFT")
walletAddress := address.MustParseAddr("put your wallet which is the owner of NFT")
nftAddress := address.MustParseAddr("put your nft address")

// We can add a comment, but it will not be displayed in the explorers,
// as it is not supported by them at the time of writing the tutorial.
forwardPayload := cell.BeginCell().
  MustStoreUInt(0, 32).
  MustStoreStringSnake("Hello, TON!").
  EndCell()

transferNftBody := cell.BeginCell().
  MustStoreUInt(0x5fcc3d14, 32). // Opcode for NFT transfer
  MustStoreUInt(0, 64). // query_id
  MustStoreAddr(destinationAddress). // new_owner
  MustStoreAddr(walletAddress). // response_destination for excesses
  MustStoreBoolBit(false). // we do not have custom_payload
  MustStoreBigCoins(tlb.MustFromTON("0.01").NanoTON()). // forward_amount
  MustStoreBoolBit(true). // we store forward_payload as a reference
  MustStoreRef(forwardPayload). // store forward_payload as a reference
  EndCell()

internalMessage := cell.BeginCell().
  MustStoreUInt(0x18, 6). // bounce
  MustStoreAddr(nftAddress).
  MustStoreBigCoins(tlb.MustFromTON("0.05").NanoTON()).
  MustStoreUInt(1, 1 + 4 + 4 + 64 + 32 + 1 + 1). // We store 1 that means we have body as a reference
  MustStoreRef(transferNftBody).
  EndCell()
```

</TabItem>
</Tabs>

NFT ì „ì†¡ ì˜µì½”ë“œëŠ” [ë™ì¼í•œ í‘œì¤€](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#tl-b-schema)ì—ì„œ ê°€ì ¸ì˜¨ ê²ƒì…ë‹ˆë‹¤.
ì´ì œ ì´ íŠœí† ë¦¬ì–¼ì˜ ì´ì „ ì„¹ì…˜ì—ì„œ ì„¤ëª…í•œ ëŒ€ë¡œ íŠ¸ëœì­ì…˜ì„ ì™„ë£Œí•´ ë³´ê² ìŠµë‹ˆë‹¤. íŠ¸ëœì­ì…˜ì„ ì™„ë£Œí•˜ëŠ” ë° í•„ìš”í•œ ì˜¬ë°”ë¥¸ ì½”ë“œëŠ” [GitHub ë¦¬í¬ì§€í† ë¦¬](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸/ììŠµì„œ/ì›”ë ›#ì†ŒìŠ¤ ì½”ë“œ)ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì œí†¤ì„ ì‚¬ìš©í•˜ì—¬ ë™ì¼í•œ ì ˆì°¨ë¥¼ ì™„ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì ˆì°¨ë¥¼ ìˆ˜í–‰í•˜ë ¤ë©´ ì œí†¤ ì „ì†¡ì— ëŒ€í•œ TL-B [í‘œì¤€](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md)ì„ ì°¸ì¡°í•˜ì„¸ìš”. íŠ¹íˆ ì´ ì‹œì ê¹Œì§€ëŠ” NFTì™€ ì œí†¤ ì „ì†¡ ê°„ì— ì•½ê°„ì˜ ì°¨ì´ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.

### ì›”ë › v3 ë° ì›”ë › v4 ê°€ì ¸ì˜¤ê¸° ë©”ì„œë“œ

ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ëŠ” ì¢…ì¢… [GET ë©”ì„œë“œ](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸/ê°€ì´ë“œë¼ì¸/get-methods)ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, ë¸”ë¡ì²´ì¸ ë‚´ë¶€ì—ì„œ ì‹¤í–‰ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤. GET ë©”ì„œë“œëŠ” ë‹¤ì–‘í•œ ìš©ë„ë¡œ ì‚¬ìš©ë˜ë©° ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ì— ë‹¤ì–‘í•œ ë°ì´í„° ìœ í˜•ì— ëŒ€í•œ ì ‘ê·¼ì„±ì„ ì œê³µí•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, NFT ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ [get_nft_data()] ë©”ì„œë“œ(https://github.com/ton-blockchain/token-contract/blob/991bdb4925653c51b0b53ab212c53143f71f5476/nft/nft-item.fc#L142-L145)ë¥¼ ì‚¬ìš©í•˜ë©´ íŠ¹ì • ì½˜í…ì¸ , ì†Œìœ ì, NFT ìˆ˜ì§‘ ì •ë³´ë¥¼ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•„ë˜ì—ì„œëŠ” [V3](https://github.com/ton-blockchain/ton/blob/e37583e5e6e8cd0aebf5142ef7d8db282f10692b/crypto/smartcont/wallet3-code.fc#L31-L41) ë° [V4](https://github.com/ton-blockchain/wallet-contract/blob/4111fd9e3313ec17d99ca9b5b1656445b5b49d8f/func/wallet-v4-code.fc#L164-L198)ì—ì„œ ì‚¬ìš©ë˜ëŠ” GET ë©”ì„œë“œì˜ ê¸°ë³¸ ì‚¬í•­ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ë‘ ì§€ê°‘ ë²„ì „ì— ëª¨ë‘ ë™ì¼í•œ ë©”ì„œë“œë¶€í„° ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤:

|                                         ë°©ë²•                                        |                                                                                                                           ì„¤ëª…                                                                                                                           |
| :-------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|                           int seqno()                          |                                                                  ì´ ë©”ì„œë“œëŠ” í˜„ì¬ seqnoë¥¼ ìˆ˜ì‹ í•˜ê³  ì˜¬ë°”ë¥¸ ê°’ìœ¼ë¡œ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•˜ëŠ” ë° í•„ìš”í•©ë‹ˆë‹¤. ì´ íŠœí† ë¦¬ì–¼ì˜ ì´ì „ ì„¹ì…˜ì—ì„œëŠ” ì´ ë©”ì„œë“œë¥¼ ìì£¼ í˜¸ì¶œí–ˆìŠµë‹ˆë‹¤.                                                                  |
| int get_public_key() | ì´ ë©”ì„œë“œëŠ” ê³µê°œí‚¤ë¥¼ ë‹¤ì‹œ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. get_public_key()ëŠ” ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©ë˜ì§€ëŠ” ì•Šìœ¼ë©°, ì—¬ëŸ¬ ì„œë¹„ìŠ¤ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì¼ë¶€ API ì„œë¹„ìŠ¤ì—ì„œëŠ” ë™ì¼í•œ ê³µê°œ í‚¤ë¥¼ ê°€ì§„ ì—¬ëŸ¬ ì§€ê°‘ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. |

ì´ì œ V4 ì§€ê°‘ì—ì„œë§Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ì´ë™í•´ ë³´ê² ìŠµë‹ˆë‹¤:

|                                                                ë°©ë²•                                                                |                                                                        ì„¤ëª…                                                                        |
| :------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------: |
|                        int get_subwallet_id()                       |                íŠœí† ë¦¬ì–¼ ì•ë¶€ë¶„ì—ì„œ ì´ë¥¼ ê³ ë ¤í–ˆìŠµë‹ˆë‹¤. ì´ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ subwallet_idë¥¼ ë‹¤ì‹œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.               |
| int is_plugin_installed(int wc, int addr_hash) | í”ŒëŸ¬ê·¸ì¸ì´ ì„¤ì¹˜ë˜ì—ˆëŠ”ì§€ ì•Œë ¤ì£¼ì„¸ìš”. ì´ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë ¤ë©´ [workchain](/í•™ìŠµ/ì˜¤ë²„ë·°/í†¤ë¸”ë¡ì²´ì¸#ì›Œí¬ì²´ì¸-ë¸”ë¡ì²´ì¸-with-your-own-rules)ê³¼ í”ŒëŸ¬ê·¸ì¸ ì£¼ì†Œ í•´ì‹œë¥¼ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤. |
|                         íŠœí”Œ get_plugin_list()                        |                                                    ì´ ë©”ì„œë“œëŠ” ì„¤ì¹˜ëœ í”ŒëŸ¬ê·¸ì¸ì˜ ì£¼ì†Œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.                                                   |

get_public_key`ì™€ `is_plugin_installed\` ë©”ì„œë“œë¥¼ ê³ ë ¤í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ ë‘ ë©”ì„œë“œëŠ” ì²˜ìŒì—ëŠ” 256ë¹„íŠ¸ ë°ì´í„°ì—ì„œ ê³µê°œ í‚¤ë¥¼ ê°€ì ¸ì™€ì•¼ í•˜ê³ , ê·¸ í›„ì—ëŠ” ìŠ¬ë¼ì´ìŠ¤ì™€ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë°ì´í„°ë¥¼ GET ë©”ì„œë“œì— ì „ë‹¬í•˜ëŠ” ë°©ë²•ì„ ë°°ì›Œì•¼ í•˜ê¸° ë•Œë¬¸ì— ì„ íƒí–ˆìŠµë‹ˆë‹¤. ì´ëŠ” ì´ëŸ¬í•œ ë©”ì„œë“œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ëŠ” ë° ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤.

ë¨¼ì € ìš”ì²­ì„ ë³´ë‚¼ ìˆ˜ ìˆëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤. ë”°ë¼ì„œ íŠ¹ì • ì§€ê°‘ ì£¼ì†Œ([EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF](https://tonscan.org/address/EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF))ë¥¼ ì˜ˆë¡œ ë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { TonClient } from '@ton/ton';
import { Address } from '@ton/core';

const client = new TonClient({
    endpoint: "https://toncenter.com/api/v2/jsonRPC",
    apiKey: "put your api key" // you can get an api key from @tonapibot bot in Telegram
});

const walletAddress = Address.parse("EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF"); // my wallet address as an example
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "context"
  "github.com/xssnick/tonutils-go/address"
  "github.com/xssnick/tonutils-go/liteclient"
  "github.com/xssnick/tonutils-go/ton"
  "log"
)

connection := liteclient.NewConnectionPool()
configUrl := "https://ton-blockchain.github.io/global.config.json"
err := connection.AddConnectionsFromConfigUrl(context.Background(), configUrl)
if err != nil {
  panic(err)
}
client := ton.NewAPIClient(connection)

block, err := client.CurrentMasterchainInfo(context.Background()) // get current block, we will need it in requests to LiteServer
if err != nil {
  log.Fatalln("CurrentMasterchainInfo err:", err.Error())
  return
}

walletAddress := address.MustParseAddr("EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF") // my wallet address as an example
```

</TabItem>
</Tabs>

ì´ì œ GET ë©”ì„œë“œ ì§€ê°‘ì„ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
// I always call runMethodWithError instead of runMethod to be able to check the exit_code of the called method. 
let getResult = await client.runMethodWithError(walletAddress, "get_public_key"); // run get_public_key GET Method
const publicKeyUInt = getResult.stack.readBigNumber(); // read answer that contains uint256
const publicKey = publicKeyUInt.toString(16); // get hex string from bigint (uint256)
console.log(publicKey)
```

</TabItem>
<TabItem value="go" label="Golang">

```go
getResult, err := client.RunGetMethod(context.Background(), block, walletAddress, "get_public_key") // run get_public_key GET Method
if err != nil {
	log.Fatalln("RunGetMethod err:", err.Error())
	return
}

// We have a response as an array with values and should specify the index when reading it
// In the case of get_public_key, we have only one returned value that is stored at 0 index
publicKeyUInt := getResult.MustInt(0) // read answer that contains uint256
publicKey := publicKeyUInt.Text(16)   // get hex string from bigint (uint256)
log.Println(publicKey)
```

</TabItem>
</Tabs>

í˜¸ì¶œì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ë©´ ìµœì¢… ê²°ê³¼ëŠ” ë§¤ìš° í° 256ë¹„íŠ¸ ìˆ«ìê°€ ë˜ë©°, ì´ë¥¼ 16ì§„ìˆ˜ë¡œ ë³€í™˜í•´ì•¼ í•©ë‹ˆë‹¤. ìœ„ì—ì„œ ì œê³µí•œ ì§€ê°‘ ì£¼ì†Œì˜ ê²°ê³¼ 16ì§„ìˆ˜ ë¬¸ìì—´ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤: `430db39b13cf3cb76bfa818b6b13417b82be2c6c389170fbe06795c71996b1f8`.
ë‹¤ìŒìœ¼ë¡œ, [TonAPI](https://tonapi.io/swagger-ui) (/v1/wallet/findByPubkey ë©”ì„œë“œ)ë¥¼ í™œìš©í•˜ì—¬ ì–»ì€ 16ì§„ìˆ˜ë¥¼ ì‹œìŠ¤í…œì— ì…ë ¥í•˜ë©´ ë‹µë³€ ë‚´ ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œê°€ ë‚´ ì§€ê°‘ì„ ì‹ë³„í•œë‹¤ëŠ” ê²ƒì„ ì¦‰ì‹œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê·¸ëŸ° ë‹¤ìŒ `is_plugin_installed` ë©”ì„œë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì•ì„œ ì‚¬ìš©í•œ ì§€ê°‘([EQAM7M--HGyfxlErAIUODrxBA3yj5roBeYiTuy6BHgJ3Sx8k](https://tonscan.org/address/EQAM7M--HGyfxlErAIUODrxBA3yj5roBeYiTuy6BHgJ3Sx8k))ê³¼ í”ŒëŸ¬ê·¸ì¸([EQBTKTis-SWYdupy99ozeOvnEBu8LRrQP_N9qwOTSAy3sQSZ](https://tonscan.org/address/EQBTKTis-SWYdupy99ozeOvnEBu8LRrQP_N9qwOTSAy3sQSZ)) ì§€ê°‘ì„ ë‹¤ì‹œ ì‚¬ìš©í•´ë³´ë„ë¡ í•˜ì£ :

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
const oldWalletAddress = Address.parse("EQAM7M--HGyfxlErAIUODrxBA3yj5roBeYiTuy6BHgJ3Sx8k"); // my old wallet address
const subscriptionAddress = Address.parseFriendly("EQBTKTis-SWYdupy99ozeOvnEBu8LRrQP_N9qwOTSAy3sQSZ"); // subscription plugin address which is already installed on the wallet
```

</TabItem>
<TabItem value="go" label="Golang">

```go
oldWalletAddress := address.MustParseAddr("EQAM7M--HGyfxlErAIUODrxBA3yj5roBeYiTuy6BHgJ3Sx8k")
subscriptionAddress := address.MustParseAddr("EQBTKTis-SWYdupy99ozeOvnEBu8LRrQP_N9qwOTSAy3sQSZ") // subscription plugin address which is already installed on the wallet
```

</TabItem>
</Tabs>

ì´ì œ í”ŒëŸ¬ê·¸ì¸ì˜ í•´ì‹œ ì£¼ì†Œë¥¼ ê²€ìƒ‰í•˜ì—¬ ì£¼ì†Œë¥¼ ìˆ«ìë¡œ ë³€í™˜í•˜ê³  GET ë©”ì„œë“œë¡œ ì „ì†¡í•  ìˆ˜ ìˆë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
const hash = BigInt(`0x${subscriptionAddress.address.hash.toString("hex")}`) ;

getResult = await client.runMethodWithError(oldWalletAddress, "is_plugin_installed", 
[
    {type: "int", value: BigInt("0")}, // pass workchain as int
    {type: "int", value: hash} // pass plugin address hash as int
]);
console.log(getResult.stack.readNumber()); // -1
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "math/big"
)

hash := big.NewInt(0).SetBytes(subscriptionAddress.Data())
// runGetMethod will automatically identify types of passed values
getResult, err = client.RunGetMethod(context.Background(), block, oldWalletAddress,
  "is_plugin_installed",
  0,    // pass workchain
  hash) // pass plugin address
if err != nil {
  log.Fatalln("RunGetMethod err:", err.Error())
  return
}

log.Println(getResult.MustInt(0)) // -1
```

</TabItem>
</Tabs>

ì‘ë‹µì€ ê²°ê³¼ê°€ ì°¸ì„ì„ ì˜ë¯¸í•˜ëŠ” `-1`ì´ì–´ì•¼ í•©ë‹ˆë‹¤. í•„ìš”í•œ ê²½ìš° ìŠ¬ë¼ì´ìŠ¤ì™€ ì…€ì„ ì „ì†¡í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë¹…ì¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ëŒ€ì‹  ìŠ¬ë¼ì´ìŠ¤ë‚˜ ì…€ì„ ìƒì„±í•˜ê³  ì ì ˆí•œ ìœ í˜•ì„ ì§€ì •í•˜ì—¬ ì „ì†¡í•˜ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤.

### ì›”ë ›ì„ í†µí•œ ê³„ì•½ ë°°í¬

3ì¥ì—ì„œëŠ” ì§€ê°‘ì„ ë°°í¬í–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ì²˜ìŒì—ëŠ” TONì„ ì „ì†¡í•œ ë‹¤ìŒ ì§€ê°‘ì—ì„œ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•˜ì—¬ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë°°í¬í–ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ í”„ë¡œì„¸ìŠ¤ëŠ” ì™¸ë¶€ íŠ¸ëœì­ì…˜ì—ëŠ” ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë©° ì£¼ë¡œ ì§€ê°‘ì—ë§Œ ì£¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. ì»¨íŠ¸ë™íŠ¸ë¥¼ ê°œë°œí•˜ëŠ” ë™ì•ˆ ë°°í¬ í”„ë¡œì„¸ìŠ¤ëŠ” ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•˜ì—¬ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.

ì´ë¥¼ ìœ„í•´ [ì„¸ ë²ˆì§¸ ì±•í„°]ì—ì„œ ì‚¬ìš©í•œ V3R2 ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤(/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸/ììŠµì„œ/ì›”ë ›#ì»´íŒŒì¼-ìš°ë¦¬-ì›”ë ›-ì½”ë“œ).
ì´ ê²½ìš°, ë™ì¼í•œ ê°œì¸ í‚¤ë¥¼ ì‚¬ìš©í•  ë•Œ ë‹¤ë¥¸ ì£¼ì†Œë¥¼ ê²€ìƒ‰í•˜ëŠ” ë° í•„ìš”í•œ `subwallet_id`ë¥¼ `3` ë˜ëŠ” ë‹¤ë¥¸ ìˆ«ìë¡œ ì„¤ì •í•©ë‹ˆë‹¤(ë³€ê²½ ê°€ëŠ¥):

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { beginCell, Cell } from '@ton/core';
import { mnemonicToWalletKey } from '@ton/crypto';

const mnemonicArray = 'put your mnemonic'.split(" ");
const keyPair = await mnemonicToWalletKey(mnemonicArray); // extract private and public keys from mnemonic

const codeCell = Cell.fromBase64('te6ccgEBCAEAhgABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQCW8oMI1xgg0x/TH9MfAvgju/Jj7UTQ0x/TH9P/0VEyuvKhUUS68qIE+QFUEFX5EPKj+ACTINdKltMH1AL7AOgwAaTIyx/LH8v/ye1UAATQMAIBSAYHABe7Oc7UTQ0z8x1wv/gAEbjJftRNDXCx+A==');
const dataCell = beginCell()
    .storeUint(0, 32) // Seqno
    .storeUint(3, 32) // Subwallet ID
    .storeBuffer(keyPair.publicKey) // Public Key
    .endCell();

const stateInit = beginCell()
    .storeBit(0) // No split_depth
    .storeBit(0) // No special
    .storeBit(1) // We have code
    .storeRef(codeCell)
    .storeBit(1) // We have data
    .storeRef(dataCell)
    .storeBit(0) // No library
    .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "crypto/ed25519"
  "crypto/hmac"
  "crypto/sha512"
  "encoding/base64"
  "github.com/xssnick/tonutils-go/tvm/cell"
  "golang.org/x/crypto/pbkdf2"
  "strings"
)

mnemonicArray := strings.Split("put your mnemonic", " ")
// The following three lines will extract the private key using the mnemonic phrase.
// We will not go into cryptographic details. In the library tonutils-go, it is all implemented,
// but it immediately returns the finished object of the wallet with the address and ready-made methods.
// So weâ€™ll have to write the lines to get the key separately. Goland IDE will automatically import
// all required libraries (crypto, pbkdf2 and others).
mac := hmac.New(sha512.New, []byte(strings.Join(mnemonicArray, " ")))
hash := mac.Sum(nil)
k := pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys
// 32 is a key len
privateKey := ed25519.NewKeyFromSeed(k)              // get private key
publicKey := privateKey.Public().(ed25519.PublicKey) // get public key from private key

BOCBytes, _ := base64.StdEncoding.DecodeString("te6ccgEBCAEAhgABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQCW8oMI1xgg0x/TH9MfAvgju/Jj7UTQ0x/TH9P/0VEyuvKhUUS68qIE+QFUEFX5EPKj+ACTINdKltMH1AL7AOgwAaTIyx/LH8v/ye1UAATQMAIBSAYHABe7Oc7UTQ0z8x1wv/gAEbjJftRNDXCx+A==")
codeCell, _ := cell.FromBOC(BOCBytes)
dataCell := cell.BeginCell().
  MustStoreUInt(0, 32).           // Seqno
  MustStoreUInt(3, 32).           // Subwallet ID
  MustStoreSlice(publicKey, 256). // Public Key
  EndCell()

stateInit := cell.BeginCell().
  MustStoreBoolBit(false). // No split_depth
  MustStoreBoolBit(false). // No special
  MustStoreBoolBit(true).  // We have code
  MustStoreRef(codeCell).
  MustStoreBoolBit(true). // We have data
  MustStoreRef(dataCell).
  MustStoreBoolBit(false). // No library
  EndCell()
```

</TabItem>
</Tabs>

ë‹¤ìŒìœ¼ë¡œ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì£¼ì†Œë¥¼ ê²€ìƒ‰í•˜ê³  InternalMessageë¥¼ ë¹Œë“œí•˜ê² ìŠµë‹ˆë‹¤. ë˜í•œ íŠ¸ëœì­ì…˜ì— "ë°°í¬ ì¤‘..." ì½”ë©˜íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, toNano } from '@ton/core';

const contractAddress = new Address(0, stateInit.hash()); // get the hash of stateInit to get the address of our smart contract in workchain with ID 0
console.log(`Contract address: ${contractAddress.toString()}`); // Output contract address to console

const internalMessageBody = beginCell()
    .storeUint(0, 32)
    .storeStringTail('Deploying...')
    .endCell();

const internalMessage = beginCell()
    .storeUint(0x10, 6) // no bounce
    .storeAddress(contractAddress)
    .storeCoins(toNano('0.01'))
    .storeUint(0, 1 + 4 + 4 + 64 + 32)
    .storeBit(1) // We have State Init
    .storeBit(1) // We store State Init as a reference
    .storeRef(stateInit) // Store State Init as a reference
    .storeBit(1) // We store Message Body as a reference
    .storeRef(internalMessageBody) // Store Message Body Init as a reference
    .endCell();
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "github.com/xssnick/tonutils-go/address"
  "github.com/xssnick/tonutils-go/tlb"
  "log"
)

contractAddress := address.NewAddress(0, 0, stateInit.Hash()) // get the hash of stateInit to get the address of our smart contract in workchain with ID 0
log.Println("Contract address:", contractAddress.String())   // Output contract address to console

internalMessageBody := cell.BeginCell().
  MustStoreUInt(0, 32).
  MustStoreStringSnake("Deploying...").
  EndCell()

internalMessage := cell.BeginCell().
  MustStoreUInt(0x10, 6). // no bounce
  MustStoreAddr(contractAddress).
  MustStoreBigCoins(tlb.MustFromTON("0.01").NanoTON()).
  MustStoreUInt(0, 1+4+4+64+32).
  MustStoreBoolBit(true).            // We have State Init
  MustStoreBoolBit(true).            // We store State Init as a reference
  MustStoreRef(stateInit).           // Store State Init as a reference
  MustStoreBoolBit(true).            // We store Message Body as a reference
  MustStoreRef(internalMessageBody). // Store Message Body Init as a reference
  EndCell()
```

</TabItem>
</Tabs>

:::info
ìœ„ì—ì„œ ë¹„íŠ¸ê°€ ì§€ì •ë˜ì—ˆê³  stateInitê³¼ internalMessageBodyê°€ ì°¸ì¡°ë¡œ ì €ì¥ë˜ì—ˆë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”. ë§í¬ê°€ ë³„ë„ë¡œ ì €ì¥ë˜ë¯€ë¡œ 4 (0b100) + 2 (0b10) + 1 (0b1) -> (4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1), ì¦‰ (0b111, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)ì„ ì‘ì„±í•œ ë‹¤ìŒ ë‘ ì°¸ì¡°ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

ë‹¤ìŒìœ¼ë¡œ ì§€ê°‘ì— ë³´ë‚¼ ë©”ì‹œì§€ë¥¼ ì¤€ë¹„í•˜ì—¬ ì „ì†¡í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { TonClient } from '@ton/ton';
import { sign } from '@ton/crypto';

const client = new TonClient({
    endpoint: 'https://toncenter.com/api/v2/jsonRPC',
    apiKey: 'put your api key' // you can get an api key from @tonapibot bot in Telegram
});

const walletMnemonicArray = 'put your mnemonic'.split(' ');
const walletKeyPair = await mnemonicToWalletKey(walletMnemonicArray); // extract private and public keys from mnemonic
const walletAddress = Address.parse('put your wallet address with which you will deploy');
const getMethodResult = await client.runMethod(walletAddress, 'seqno'); // run "seqno" GET method from your wallet contract
const seqno = getMethodResult.stack.readNumber(); // get seqno from response

// transaction for our wallet
const toSign = beginCell()
    .storeUint(698983191, 32) // subwallet_id
    .storeUint(Math.floor(Date.now() / 1e3) + 60, 32) // Transaction expiration time, +60 = 1 minute
    .storeUint(seqno, 32) // store seqno
    // Do not forget that if we use Wallet V4, we need to add .storeUint(0, 8) 
    .storeUint(3, 8)
    .storeRef(internalMessage);

const signature = sign(toSign.endCell().hash(), walletKeyPair.secretKey); // get the hash of our message to wallet smart contract and sign it to get signature
const body = beginCell()
    .storeBuffer(signature) // store signature
    .storeBuilder(toSign) // store our message
    .endCell();

const external = beginCell()
    .storeUint(0b10, 2) // indicate that it is an incoming external transaction
    .storeUint(0, 2) // src -> addr_none
    .storeAddress(walletAddress)
    .storeCoins(0) // Import fee
    .storeBit(0) // We do not have State Init
    .storeBit(1) // We store Message Body as a reference
    .storeRef(body) // Store Message Body as a reference
    .endCell();

console.log(external.toBoc().toString('base64'));
client.sendFile(external.toBoc());
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "context"
  "github.com/xssnick/tonutils-go/liteclient"
  "github.com/xssnick/tonutils-go/tl"
  "github.com/xssnick/tonutils-go/ton"
  "time"
)

connection := liteclient.NewConnectionPool()
configUrl := "https://ton-blockchain.github.io/global.config.json"
err := connection.AddConnectionsFromConfigUrl(context.Background(), configUrl)
if err != nil {
  panic(err)
}
client := ton.NewAPIClient(connection)

block, err := client.CurrentMasterchainInfo(context.Background()) // get current block, we will need it in requests to LiteServer
if err != nil {
  log.Fatalln("CurrentMasterchainInfo err:", err.Error())
  return
}

walletMnemonicArray := strings.Split("put your mnemonic", " ")
mac = hmac.New(sha512.New, []byte(strings.Join(walletMnemonicArray, " ")))
hash = mac.Sum(nil)
k = pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys
// 32 is a key len
walletPrivateKey := ed25519.NewKeyFromSeed(k) // get private key
walletAddress := address.MustParseAddr("put your wallet address with which you will deploy")

getMethodResult, err := client.RunGetMethod(context.Background(), block, walletAddress, "seqno") // run "seqno" GET method from your wallet contract
if err != nil {
  log.Fatalln("RunGetMethod err:", err.Error())
  return
}
seqno := getMethodResult.MustInt(0) // get seqno from response

toSign := cell.BeginCell().
  MustStoreUInt(698983191, 32).                          // subwallet_id | We consider this further
  MustStoreUInt(uint64(time.Now().UTC().Unix()+60), 32). // transaction expiration time, +60 = 1 minute
  MustStoreUInt(seqno.Uint64(), 32).                     // store seqno
  // Do not forget that if we use Wallet V4, we need to add MustStoreUInt(0, 8).
  MustStoreUInt(3, 8).          // store mode of our internal transaction
  MustStoreRef(internalMessage) // store our internalMessage as a reference

signature := ed25519.Sign(walletPrivateKey, toSign.EndCell().Hash()) // get the hash of our message to wallet smart contract and sign it to get signature

body := cell.BeginCell().
  MustStoreSlice(signature, 512). // store signature
  MustStoreBuilder(toSign).       // store our message
  EndCell()

externalMessage := cell.BeginCell().
  MustStoreUInt(0b10, 2).       // ext_in_msg_info$10
  MustStoreUInt(0, 2).          // src -> addr_none
  MustStoreAddr(walletAddress). // Destination address
  MustStoreCoins(0).            // Import Fee
  MustStoreBoolBit(false).      // No State Init
  MustStoreBoolBit(true).       // We store Message Body as a reference
  MustStoreRef(body).           // Store Message Body as a reference
  EndCell()

var resp tl.Serializable
err = client.Client().QueryLiteserver(context.Background(), ton.SendMessage{Body: externalMessage.ToBOCWithFlags(false)}, &resp)

if err != nil {
  log.Fatalln(err.Error())
  return
}
```

</TabItem>
</Tabs>

ì´ê²ƒìœ¼ë¡œ ì¼ë°˜ ì§€ê°‘ì— ëŒ€í•œ ì‘ì—…ì„ ë§ˆì¹©ë‹ˆë‹¤. ì´ ë‹¨ê³„ì—ì„œëŠ” ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì™€ ìƒí˜¸ì‘ìš©í•˜ê³  íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•˜ëŠ” ë°©ë²•ì„ ì˜ ì´í•´í•˜ê³  ë‹¤ì–‘í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìœ í˜•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

## ğŸ”¥ ê³ ìš©ëŸ‰ ì§€ê°‘

ê²½ìš°ì— ë”°ë¼ ë©”ì‹œì§€ë‹¹ ë§ì€ ìˆ˜ì˜ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´ ì¼ë°˜ ì§€ê°‘ì€ í•˜ë‚˜ì˜ ì…€ì— [ìµœëŒ€ 4ê°œì˜ ì°¸ì¡°](/ê°œë°œ/ë°ì´í„°-í¬ë§·/ì…€-boc#ì…€)ë¥¼ ì €ì¥í•˜ì—¬ í•œ ë²ˆì— ìµœëŒ€ 4ê°œì˜ íŠ¸ëœì­ì…˜ ì „ì†¡ì„ ì§€ì›í•©ë‹ˆë‹¤. ë¶€í•˜ê°€ ë†’ì€ ì§€ê°‘ì€ í•œ ë²ˆì— 255ê°œì˜ íŠ¸ëœì­ì…˜ë§Œ ì „ì†¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ì œí•œì€ ë¸”ë¡ì²´ì¸ì˜ êµ¬ì„± ì„¤ì •ì—ì„œ ë°œì‹  ë©”ì‹œì§€(ì‘ì—…)ì˜ ìµœëŒ€ ê°œìˆ˜ê°€ 255ê°œë¡œ ì„¤ì •ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— ì¡´ì¬í•©ë‹ˆë‹¤.

ê±°ë˜ì†ŒëŠ” ê³ ë¶€í•˜ ì§€ê°‘ì´ ëŒ€ê·œëª¨ë¡œ ì‚¬ìš©ë˜ëŠ” ê°€ì¥ ì¢‹ì€ ì˜ˆì¼ ê²ƒì…ë‹ˆë‹¤. ë°”ì´ë‚¸ìŠ¤ì™€ ê°™ì€ ê¸°ì¡´ ê±°ë˜ì†ŒëŠ” ì‚¬ìš©ì ê¸°ë°˜ì´ ë§¤ìš° í¬ê¸° ë•Œë¬¸ì— ë‹¨ê¸°ê°„ì— ë§ì€ ìˆ˜ì˜ ê±°ë˜ ì¶œê¸ˆì´ ì²˜ë¦¬ë©ë‹ˆë‹¤. ê³ ë¶€í•˜ ì§€ê°‘ì€ ì´ëŸ¬í•œ ì¶œê¸ˆ ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.

### ê³ ë¶€í•˜ ì§€ê°‘ FunC ì½”ë“œ

ë¨¼ì €, [ê³ ë¶€í•˜ ì§€ê°‘ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ ì½”ë“œ êµ¬ì¡°](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet-v2-code.fc)ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:

```func
() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512); ;; get signature from the message body
  var cs = in_msg;
  var (subwallet_id, query_id) = (cs~load_uint(32), cs~load_uint(64)); ;; get rest values from the message body
  var bound = (now() << 32); ;; bitwise left shift operation
  throw_if(35, query_id < bound); ;; throw an error if transaction has expired
  var ds = get_data().begin_parse();
  var (stored_subwallet, last_cleaned, public_key, old_queries) = (ds~load_uint(32), ds~load_uint(64), ds~load_uint(256), ds~load_dict()); ;; read values from storage
  ds.end_parse(); ;; make sure we do not have anything in ds
  (_, var found?) = old_queries.udict_get?(64, query_id); ;; check if we have already had such a request
  throw_if(32, found?); ;; if yes throw an error
  throw_unless(34, subwallet_id == stored_subwallet);
  throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));
  var dict = cs~load_dict(); ;; get dictionary with messages
  cs.end_parse(); ;; make sure we do not have anything in cs
  accept_message();
```

> ğŸ’¡ ìœ ìš©í•œ ë§í¬:
>
> ["ë¬¸ì„œì—ì„œ ë¹„íŠ¸ ì—°ì‚°"](/develop/func/stdlib/#dict_get)
>
> ["load_dict()" in docs](/develop/func/stdlib/#load_dict)
>
> ["udict_get?()" in docs](/develop/func/stdlib/#dict_get)

ì¼ë°˜ ì§€ê°‘ê³¼ ëª‡ ê°€ì§€ ì°¨ì´ì ì´ ìˆìŠµë‹ˆë‹¤. ì´ì œ TONì—ì„œ ê³ ìš©ëŸ‰ ì§€ê°‘ì´ ì‘ë™í•˜ëŠ” ë°©ì‹ì— ëŒ€í•´ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤(ì„œë¸Œ ì§€ê°‘ì€ ì•ì„œ ì‚´í´ë³¸ ê²ƒì²˜ëŸ¼ ì œì™¸).

### ì‹œí€€ìŠ¤ ë²ˆí˜¸ ëŒ€ì‹  ì¿¼ë¦¬ ID ì‚¬ìš©

ì•ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ ì¼ë°˜ ì§€ê°‘ ì‹œí€€ìŠ¤ëŠ” íŠ¸ëœì­ì…˜ì´ ë°œìƒí•  ë•Œë§ˆë‹¤ '1'ì”© ì¦ê°€í•©ë‹ˆë‹¤. ì§€ê°‘ ì‹œí€€ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ë™ì•ˆ ì´ ê°’ì´ ì—…ë°ì´íŠ¸ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€ GET ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ ê°’ì„ ê°€ì ¸ì™€ ìƒˆ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•´ì•¼ í–ˆìŠµë‹ˆë‹¤.
ì´ ê³¼ì •ì—ëŠ” ìƒë‹¹í•œ ì‹œê°„ì´ ì†Œìš”ë˜ëŠ”ë°, ì´ëŠ” ê³ ìš©ëŸ‰ ì§€ê°‘ì´ ì„¤ê³„ë˜ì§€ ì•Šì€ ê²ƒì…ë‹ˆë‹¤(ìœ„ì—ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ ê³ ìš©ëŸ‰ ì§€ê°‘ì€ ëŒ€ëŸ‰ì˜ íŠ¸ëœì­ì…˜ì„ ë§¤ìš° ë¹ ë¥´ê²Œ ì „ì†¡í•˜ê¸° ìœ„í•œ ê²ƒì…ë‹ˆë‹¤). ë”°ë¼ì„œ TONì˜ ê³ ë¶€í•˜ ì§€ê°‘ì€ `query_id`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

ë™ì¼í•œ ê±°ë˜ ìš”ì²­ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°, ì´ë¯¸ ì²˜ë¦¬ë˜ì—ˆìœ¼ë¯€ë¡œ ê³„ì•½ì´ ìˆ˜ë½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:

```func
var (stored_subwallet, last_cleaned, public_key, old_queries) = (ds~load_uint(32), ds~load_uint(64), ds~load_uint(256), ds~load_dict()); ;; read values from storage
ds.end_parse(); ;; make sure we do not have anything in ds
(_, var found?) = old_queries.udict_get?(64, query_id); ;; check if we have already had such a request
throw_if(32, found?); ;; if yes throw an error
```

ì´ë ‡ê²Œ í•˜ë©´ ì¼ë°˜ ì§€ê°‘ì—ì„œ ì„¹ë…¸ì˜ ì—­í• ì´ì—ˆë˜ ë°˜ë³µ ê±°ë˜\*\*ë¡œë¶€í„° ë³´í˜¸ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ê±°ë˜ ë³´ë‚´ê¸°

ì»¨íŠ¸ë™íŠ¸ê°€ ì™¸ë¶€ ë©”ì‹œì§€ë¥¼ ìˆ˜ë½í•˜ë©´ ë£¨í”„ê°€ ì‹œì‘ë˜ê³ , ì´ ë£¨í”„ëŠ” ì‚¬ì „ì— ì €ì¥ëœ 'ìŠ¬ë¼ì´ìŠ¤'ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. ì´ ìŠ¬ë¼ì´ìŠ¤ëŠ” íŠ¸ëœì­ì…˜ ëª¨ë“œì™€ íŠ¸ëœì­ì…˜ ìì²´ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ ì „ì†¡ì€ ì‚¬ì „ì´ ë¹„ì›Œì§ˆ ë•Œê¹Œì§€ ì§„í–‰ë©ë‹ˆë‹¤.

```func
int i = -1; ;; we write -1 because it will be the smallest value among all dictionary keys
do {
  (i, var cs, var f) = dict.idict_get_next?(16, i); ;; get the key and its corresponding value with the smallest key, which is greater than i
  if (f) { ;; check if any value was found
    var mode = cs~load_uint(8); ;; load transaction mode
    send_raw_message(cs~load_ref(), mode); ;; load transaction itself and send it
  }
} until (~ f); ;; if any value was found continue
```

> ğŸ’¡ ìœ ìš©í•œ ë§í¬:
>
> ["idict_get_next()" in docs](/develop/func/stdlib/#dict_get_next)

ê°’ì´ ë°œê²¬ë˜ë©´ `f`ëŠ” í•­ìƒ -1(ì°¸)ê³¼ ê°™ë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”. ë¹„íŠ¸ ë‹¨ìœ„ë¡œ `~ -1` ì—°ì‚°ì€ í•­ìƒ 0ì˜ ê°’ì„ ë°˜í™˜í•˜ë©°, ì´ëŠ” ë£¨í”„ë¥¼ ê³„ì†í•´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ë™ì‹œì— ì‚¬ì „ì´ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ê°€ë“ ì°¨ë©´ -1\*\*ë³´ë‹¤ í° ê°’(ì˜ˆ: 0)ìœ¼ë¡œ \*\*ê³„ì‚°ì„ ì‹œì‘í•˜ê³  ê° íŠ¸ëœì­ì…˜ë§ˆë‹¤ ê°’ì„ 1ì”© ê³„ì† ëŠ˜ë ¤ì•¼ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ êµ¬ì¡°ë¥¼ í†µí•´ íŠ¸ëœì­ì…˜ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ì „ì†¡ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ë§Œë£Œëœ ì¿¼ë¦¬ ì œê±°í•˜ê¸°

ì¼ë°˜ì ìœ¼ë¡œ [í†¤ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ìì²´ ìŠ¤í† ë¦¬ì§€ ë¹„ìš©ì„ ì§€ë¶ˆí•©ë‹ˆë‹¤](/ê°œë°œ/ë°©ë²•/ìˆ˜ìˆ˜ë£Œ-ì €ìˆ˜ì¤€#ìŠ¤í† ë¦¬ì§€-ìˆ˜ìˆ˜ë£Œ). ì¦‰, ë†’ì€ ë„¤íŠ¸ì›Œí¬ íŠ¸ëœì­ì…˜ ìˆ˜ìˆ˜ë£Œë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ê°€ ì €ì¥í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ì˜ ì–‘ì´ ì œí•œë©ë‹ˆë‹¤. ì‹œìŠ¤í…œì˜ íš¨ìœ¨ì„±ì„ ë†’ì´ê¸° ìœ„í•´ 64ì´ˆ ì´ìƒ ì§€ë‚œ íŠ¸ëœì­ì…˜ì€ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì œê±°ë©ë‹ˆë‹¤. ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì§„í–‰ë©ë‹ˆë‹¤:

```func
bound -= (64 << 32);   ;; clean up records that have expired more than 64 seconds ago
old_queries~udict_set_builder(64, query_id, begin_cell()); ;; add current query to dictionary
var queries = old_queries; ;; copy dictionary to another variable
do {
  var (old_queries', i, _, f) = old_queries.udict_delete_get_min(64);
  f~touch();
  if (f) { ;; check if any value was found
    f = (i < bound); ;; check if more than 64 seconds have elapsed after expiration
  }
  if (f) { 
    old_queries = old_queries'; ;; if yes save changes in our dictionary
    last_cleaned = i; ;; save last removed query
  }
} until (~ f);
```

> ğŸ’¡ ìœ ìš©í•œ ë§í¬:
>
> ["udict_delete_get_min()" in docs](/develop/func/stdlib/#dict_delete_get_min)

f`ë³€ìˆ˜ì™€ ì—¬ëŸ¬ ë²ˆ ìƒí˜¸ì‘ìš©í•´ì•¼ í•œë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”. TVMì€ ìŠ¤íƒ ë¨¸ì‹ ì´ë¯€ë¡œ](/learn/tvm-instruction/tvm-overview#tvm-is-a-stack-machine),`f` ë³€ìˆ˜ì™€ ìƒí˜¸ì‘ìš©í•  ë•Œë§ˆë‹¤ ì›í•˜ëŠ” ë³€ìˆ˜ë¥¼ ì–»ê¸° ìœ„í•´ ëª¨ë“  ê°’ì„ íŒí•´ì•¼ í•©ë‹ˆë‹¤. f~touch()` ì—°ì‚°ì€ ì½”ë“œ ì‹¤í–‰ì„ ìµœì í™”í•˜ê¸° ìœ„í•´ f ë³€ìˆ˜ë¥¼ ìŠ¤íƒì˜ ë§¨ ìœ„ì— ë°°ì¹˜í•©ë‹ˆë‹¤.

### ë¹„íŠ¸ ë‹¨ìœ„ ì—°ì‚°

ì´ ì„¹ì…˜ì€ ë¹„íŠ¸ ì—°ì‚°ì— ìµìˆ™í•˜ì§€ ì•Šì€ ë¶„ë“¤ì—ê²ŒëŠ” ë‹¤ì†Œ ë³µì¡í•´ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì½”ë“œì—ì„œ ë‹¤ìŒ ì½”ë“œ ì¤„ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```func
var bound = (now() << 32); ;; bitwise left shift operation
```

ê²°ê³¼ì ìœ¼ë¡œ ì˜¤ë¥¸ìª½ì˜ ìˆ«ìì— 32ë¹„íŠ¸ê°€ ì¶”ê°€ë©ë‹ˆë‹¤. ì¦‰, **ê¸°ì¡´ ê°’ì´ ì™¼ìª½ìœ¼ë¡œ 32ë¹„íŠ¸ ì´ë™**í•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ìˆ«ì 3ì„ 2ì§„ìˆ˜ í˜•íƒœë¡œ ë³€í™˜í•˜ë©´ ê²°ê³¼ëŠ” 11ì´ ë©ë‹ˆë‹¤. '3 << 2' ì—°ì‚°ì„ ì ìš©í•˜ë©´ 11ì€ 2ë¹„íŠ¸ ì´ë™í•©ë‹ˆë‹¤. ì¦‰, ë¬¸ìì—´ì˜ ì˜¤ë¥¸ìª½ì— 2ë¹„íŠ¸ê°€ ì¶”ê°€ë©ë‹ˆë‹¤. ê²°êµ­ 1100ì€ 12ê°€ ë©ë‹ˆë‹¤.

ì´ í”„ë¡œì„¸ìŠ¤ì— ëŒ€í•´ ê°€ì¥ ë¨¼ì € ì´í•´í•´ì•¼ í•  ê²ƒì€ `now()` í•¨ìˆ˜ëŠ” ê²°ê³¼ê°’ì´ 32ë¹„íŠ¸ë¼ëŠ” ì˜ë¯¸ì˜ uint32 ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. 32ë¹„íŠ¸ë¥¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë©´ ë‹¤ë¥¸ uint32ë¥¼ ìœ„í•œ ê³µê°„ì´ í™•ë³´ë˜ì–´ ì˜¬ë°”ë¥¸ query_idê°€ ìƒì„±ë©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ **íƒ€ì„ìŠ¤íƒ¬í”„ì™€ ì¿¼ë¦¬ ì•„ì´ë””ë¥¼ í•˜ë‚˜ì˜ ë³€ìˆ˜ ë‚´ì—ì„œ ê²°í•©**í•˜ì—¬ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë‹¤ìŒìœ¼ë¡œ ë‹¤ìŒ ì½”ë“œ ì¤„ì„ ê³ ë ¤í•´ ë³´ê² ìŠµë‹ˆë‹¤:

```func
bound -= (64 << 32); ;; clean up the records that have expired more than 64 seconds ago
```

ìœ„ì—ì„œëŠ” ìˆ«ì 64ë¥¼ 32ë¹„íŠ¸ì”© ì´ë™í•˜ì—¬ íƒ€ì„ìŠ¤íƒ¬í”„ì—ì„œ **64ì´ˆ**ë¥¼ ë¹¼ëŠ” ì—°ì‚°ì„ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ê³¼ê±°ì˜ ì¿¼ë¦¬ IDë¥¼ ë¹„êµí•˜ì—¬ ìˆ˜ì‹ ëœ ê°’ë³´ë‹¤ ì‘ì€ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ 64ì´ˆ ì´ìƒ ì „ì— ë§Œë£Œëœ ê²ƒì…ë‹ˆë‹¤:

```func
if (f) { ;; check if any value has been found
  f = (i < bound); ;; check if more than 64 seconds have elapsed after expiration
}
```

ì´ë¥¼ ë” ì˜ ì´í•´í•˜ê¸° ìœ„í•´ `1625918400`ì´ë¼ëŠ” ìˆ«ìë¥¼ íƒ€ì„ìŠ¤íƒ¬í”„ì˜ ì˜ˆë¡œ ë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤. ì´ ìˆ«ìì˜ ì´ì§„ í‘œí˜„(32ë¹„íŠ¸ì— 0ì„ ì™¼ìª½ìœ¼ë¡œ ë”í•œ ê²ƒ)ì€ 01100000111010011000101111000000 ì…ë‹ˆë‹¤. 32ë¹„íŠ¸ ì™¼ìª½ ì‹œí”„íŠ¸ë¥¼ ìˆ˜í–‰í•˜ë©´ ìˆ«ìì˜ ì´ì§„ í‘œí˜„ ëì— 0ì´ 32ê°œê°€ ë©ë‹ˆë‹¤.

ì´ ì‘ì—…ì´ ì™„ë£Œë˜ë©´ \*\*ì–´ë–¤ ì¿¼ë¦¬ ì•„ì´ë””(uint32)\*\*ë„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ `64 << 32`ë¥¼ ë¹¼ë©´ 64ì´ˆ ì „ì— ë™ì¼í•œ query_idë¥¼ ê°€ì¡Œë˜ íƒ€ì„ìŠ¤íƒ¬í”„ê°€ ìƒì„±ë©ë‹ˆë‹¤. ì´ ì‚¬ì‹¤ì€ ë‹¤ìŒ ê³„ì‚° `((1625918400 << 32) - (64 << 32)) >> 32`ë¥¼ ìˆ˜í–‰í•˜ì—¬ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë²ˆí˜¸ì˜ í•„ìš”í•œ ë¶€ë¶„(íƒ€ì„ìŠ¤íƒ¬í”„)ì„ ë¹„êµí•˜ëŠ” ë™ì‹œì— ì¿¼ë¦¬_idê°€ ê°„ì„­í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

### ìŠ¤í† ë¦¬ì§€ ì—…ë°ì´íŠ¸

ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ë‚¨ì€ ì‘ì—…ì€ ì €ì¥ì†Œì— ìƒˆ ê°’ì„ ì €ì¥í•˜ëŠ” ê²ƒë¿ì…ë‹ˆë‹¤:

```func
  set_data(begin_cell()
    .store_uint(stored_subwallet, 32)
    .store_uint(last_cleaned, 64)
    .store_uint(public_key, 256)
    .store_dict(old_queries)
    .end_cell());
}
```

### GET ë©”ì„œë“œ

ì§€ê°‘ ë°°í¬ì™€ íŠ¸ëœì­ì…˜ ìƒì„±ì— ëŒ€í•´ ì•Œì•„ë³´ê¸° ì „ì— ë§ˆì§€ë§‰ìœ¼ë¡œ ê³ ë ¤í•´ì•¼ í•  ê²ƒì€ ë¶€í•˜ê°€ ë†’ì€ ì§€ê°‘ GET ë©”ì„œë“œì…ë‹ˆë‹¤:

|                                         ë°©ë²•                                        |                                                                                                 ì„¤ëª…                                                                                                 |
| :-------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|        int processed?(int QUERY_ID)       | íŠ¹ì • ìš”ì²­ì´ ì²˜ë¦¬ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì‚¬ìš©ìì—ê²Œ ì•Œë¦½ë‹ˆë‹¤. ì¦‰, ìš”ì²­ì´ ì²˜ë¦¬ëœ ê²½ìš° `-1`ì„ ë°˜í™˜í•˜ê³  ì²˜ë¦¬ë˜ì§€ ì•Šì€ ê²½ìš° `0`ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ë˜í•œ ìš”ì²­ì´ ì˜¤ë˜ë˜ì–´ ë” ì´ìƒ ì»¨íŠ¸ë™íŠ¸ì— ì €ì¥ë˜ì§€ ì•Šì•„ ì‘ë‹µì„ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš° ì´ ë©”ì„œë“œëŠ” `1`ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. |
| int get_public_key() |                                                               ê³µê°œ í‚¤ë¥¼ ë‹¤ì‹œ ìƒì„±í•©ë‹ˆë‹¤. ì´ì „ì—ë„ ì´ ë°©ë²•ì„ ê³ ë ¤í•œ ì ì´ ìˆìŠµë‹ˆë‹¤.                                                              |

ë§ˆì§€ë§‰_í´ë¦°ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ì´ìœ ë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ `int processed?(int query_id)` ë©”ì„œë“œë¥¼ ìì„¸íˆ ì‚´í´ë´…ì‹œë‹¤:

```func
int processed?(int query_id) method_id {
  var ds = get_data().begin_parse();
  var (_, last_cleaned, _, old_queries) = (ds~load_uint(32), ds~load_uint(64), ds~load_uint(256), ds~load_dict());
  ds.end_parse();
  (_, var found) = old_queries.udict_get?(64, query_id);
  return found ? true : - (query_id <= last_cleaned);
}
```

last_cleaned`ëŠ” ì»¨íŠ¸ë™íŠ¸ ì €ì¥ì†Œì™€ ì´ì „ ì¿¼ë¦¬ ì‚¬ì „ì—ì„œ ê²€ìƒ‰ë©ë‹ˆë‹¤. ì¿¼ë¦¬ê°€ ë°œê²¬ë˜ë©´ ì°¸ì„ ë°˜í™˜í•˜ê³ , ë°œê²¬ë˜ì§€ ì•Šìœ¼ë©´ `- (query_id <= last_cleaned)\` í‘œí˜„ì‹ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ìš”ì²­ì„ ì‚­ì œí•  ë•Œ ìµœì†Œ íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ ì‹œì‘í•˜ê¸° ë•Œë¬¸ì— last_cleanedì—ëŠ” **ê°€ì¥ ë†’ì€ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ê°€ì§„** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚­ì œëœ ìš”ì²­ì´ í¬í•¨ë©ë‹ˆë‹¤.

ì¦‰, ë©”ì„œë“œì— ì „ë‹¬ëœ query_idê°€ ë§ˆì§€ë§‰ last_cleaned ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ì»¨íŠ¸ë™íŠ¸ì— ìˆì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ `query_id <= last_cleaned`ëŠ” -1ì„ ë°˜í™˜í•˜ê³ , ì´ í‘œí˜„ì‹ ì•ì— ë§ˆì´ë„ˆìŠ¤ê°€ ìˆìœ¼ë©´ ë‹µì´ 1ë¡œ ë³€ê²½ë©ë‹ˆë‹¤. query_idê°€ last_cleaned ë©”ì„œë“œë³´ë‹¤ í¬ë©´ ì•„ì§ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ê²ƒì…ë‹ˆë‹¤.

### ê³ ë¶€í•˜ ì§€ê°‘ ë°°í¬

ë¶€í•˜ê°€ ë†’ì€ ì§€ê°‘ì„ ë°°í¬í•˜ë ¤ë©´ ì‚¬ìš©ìê°€ ì‚¬ìš©í•  ë‹ˆëª¨ë‹‰ í‚¤ë¥¼ ë¯¸ë¦¬ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤. ì´ íŠœí† ë¦¬ì–¼ì˜ ì´ì „ ì„¹ì…˜ì—ì„œ ì‚¬ìš©í•œ ê²ƒê³¼ ë™ì¼í•œ í‚¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê³ ë¶€í•˜ ì§€ê°‘ì„ ë°°í¬í•˜ëŠ” ë° í•„ìš”í•œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹œì‘í•˜ë ¤ë©´ [ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì½”ë“œ](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet-v2-code.fc)ë¥¼ stdlib.fcì™€ wallet_v3ê°€ ìˆëŠ” ë™ì¼í•œ ë””ë ‰í† ë¦¬ì— ë³µì‚¬í•˜ê³  ì½”ë“œ ì‹œì‘ ë¶€ë¶„ì— `#include "stdlib.fc";`ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì„ ìŠì§€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ [ì„¹ì…˜ 3]ì—ì„œ í–ˆë˜ ê²ƒì²˜ëŸ¼ ê³ ë¶€í•˜ ì§€ê°‘ ì½”ë“œë¥¼ ì»´íŒŒì¼í•©ë‹ˆë‹¤(/ê°œë°œ/ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸/íŠœí† ë¦¬ì–¼/ì›”ë ›#ì»´íŒŒì¼-ì›”ë ›-ì½”ë“œ):

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { compileFunc } from '@ton-community/func-js';
import fs from 'fs'
import { Cell } from '@ton/core';

const result = await compileFunc({
    targets: ['highload_wallet.fc'], // targets of your project
    sources: {
        'stdlib.fc': fs.readFileSync('./src/stdlib.fc', { encoding: 'utf-8' }),
        'highload_wallet.fc': fs.readFileSync('./src/highload_wallet.fc', { encoding: 'utf-8' }),
    }
});

if (result.status === 'error') {
console.error(result.message)
return;
}

const codeCell = Cell.fromBoc(Buffer.from(result.codeBoc, 'base64'))[0];

// now we have base64 encoded BOC with compiled code in result.codeBoc
console.log('Code BOC: ' + result.codeBoc);
console.log('\nHash: ' + codeCell.hash().toString('base64')); // get the hash of cell and convert in to base64 encoded string

```

</TabItem>
</Tabs>

ê²°ê³¼ëŠ” í„°ë¯¸ë„ì— ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤:

```text
Code BOC: te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKz

Hash: lJTRzI7fEvBWcaGpugmSEJbrUIEeGSTsZcPGKfu4CBI=
```

ìœ„ì˜ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ì–¸ì–´ì—ì„œ ì§€ê°‘ ì½”ë“œê°€ í¬í•¨ëœ ì…€ì„ ê²€ìƒ‰í•˜ê¸° ìœ„í•´ base64ë¡œ ì¸ì½”ë”©ëœ ì¶œë ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="go" label="Golang">

```go
import (
  "encoding/base64"
  "github.com/xssnick/tonutils-go/tvm/cell"
  "log"
)

base64BOC := "te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKz" // save our base64 encoded output from compiler to variable
codeCellBytes, _ := base64.StdEncoding.DecodeString(base64BOC) // decode base64 in order to get byte array
codeCell, err := cell.FromBOC(codeCellBytes) // get cell with code from byte array
if err != nil { // check if there is any error
  panic(err) 
}

log.Println("Hash:", base64.StdEncoding.EncodeToString(codeCell.Hash())) // get the hash of our cell, encode it to base64 because it has []byte type and output to the terminal
```

</TabItem>
</Tabs>

ì´ì œ ì´ˆê¸° ë°ì´í„°ë¡œ êµ¬ì„±ëœ ì…€ì„ ê²€ìƒ‰í•˜ê³ , ìƒíƒœ ì´ˆê¸°í™”ë¥¼ ë¹Œë“œí•˜ê³ , ë¶€í•˜ê°€ ë†’ì€ ì§€ê°‘ ì£¼ì†Œë¥¼ ê³„ì‚°í•´ì•¼ í•©ë‹ˆë‹¤. ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì½”ë“œë¥¼ ì‚´í´ë³¸ ê²°ê³¼, í•˜ìœ„ ì§€ê°‘ ì•„ì´ë””, ë§ˆì§€ë§‰ ì²­ì†Œ, ê³µê°œ í‚¤, ì˜¤ë˜ëœ ì¿¼ë¦¬ê°€ ìŠ¤í† ë¦¬ì§€ì— ìˆœì°¨ì ìœ¼ë¡œ ì €ì¥ëœë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, beginCell } from '@ton/core';
import { mnemonicToWalletKey } from '@ton/crypto';

const highloadMnemonicArray = 'put your mnemonic that you have generated and saved before'.split(' ');
const highloadKeyPair = await mnemonicToWalletKey(highloadMnemonicArray); // extract private and public keys from mnemonic

const dataCell = beginCell()
    .storeUint(698983191, 32) // Subwallet ID
    .storeUint(0, 64) // Last cleaned
    .storeBuffer(highloadKeyPair.publicKey) // Public Key
    .storeBit(0) // indicate that the dictionary is empty
    .endCell();

const stateInit = beginCell()
    .storeBit(0) // No split_depth
    .storeBit(0) // No special
    .storeBit(1) // We have code
    .storeRef(codeCell)
    .storeBit(1) // We have data
    .storeRef(dataCell)
    .storeBit(0) // No library
    .endCell();

const contractAddress = new Address(0, stateInit.hash()); // get the hash of stateInit to get the address of our smart contract in workchain with ID 0
console.log(`Contract address: ${contractAddress.toString()}`); // Output contract address to console
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "crypto/ed25519"
  "crypto/hmac"
  "crypto/sha512"
  "github.com/xssnick/tonutils-go/address"
  "golang.org/x/crypto/pbkdf2"
  "strings"
)

highloadMnemonicArray := strings.Split("put your mnemonic that you have generated and saved before", " ") // word1 word2 word3
mac := hmac.New(sha512.New, []byte(strings.Join(highloadMnemonicArray, " ")))
hash := mac.Sum(nil)
k := pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys
// 32 is a key len
highloadPrivateKey := ed25519.NewKeyFromSeed(k)                      // get private key
highloadPublicKey := highloadPrivateKey.Public().(ed25519.PublicKey) // get public key from private key

dataCell := cell.BeginCell().
  MustStoreUInt(698983191, 32).           // Subwallet ID
  MustStoreUInt(0, 64).                   // Last cleaned
  MustStoreSlice(highloadPublicKey, 256). // Public Key
  MustStoreBoolBit(false).                // indicate that the dictionary is empty
  EndCell()

stateInit := cell.BeginCell().
  MustStoreBoolBit(false). // No split_depth
  MustStoreBoolBit(false). // No special
  MustStoreBoolBit(true).  // We have code
  MustStoreRef(codeCell).
  MustStoreBoolBit(true). // We have data
  MustStoreRef(dataCell).
  MustStoreBoolBit(false). // No library
  EndCell()

contractAddress := address.NewAddress(0, 0, stateInit.Hash()) // get the hash of stateInit to get the address of our smart contract in workchain with ID 0
log.Println("Contract address:", contractAddress.String())    // Output contract address to console
```

</TabItem>
</Tabs> 

:::caution
ìœ„ì—ì„œ ì„¤ëª…í•œ ëª¨ë“  ë‚´ìš©ì€ ì»¨íŠ¸ë™íŠ¸ [ì§€ê°‘ì„ í†µí•œ ë°°í¬](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ì»¨íŠ¸ë™íŠ¸/ììŠµì„œ/ì§€ê°‘#ì»¨íŠ¸ë™íŠ¸-ë°°í¬-ë°”ì´-ì›”ë ›) ì„¹ì…˜ê³¼ ë™ì¼í•œ ë‹¨ê³„ë¥¼ ë”°ë¦…ë‹ˆë‹¤. ë” ì˜ ì´í•´í•˜ë ¤ë©´ ì „ì²´ [GitHub ì†ŒìŠ¤ ì½”ë“œ](\(https://github.com/aSpite/wallet-tutorial\))ë¥¼ ì½ì–´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤.
:::

### ê³ ë¶€í•˜ ì§€ê°‘ ê±°ë˜ ë³´ë‚´ê¸°

ì´ì œ ì—¬ëŸ¬ ê°œì˜ ë©”ì‹œì§€ë¥¼ ë™ì‹œì— ë³´ë‚´ë„ë¡ ê³ ë¶€í•˜ ì§€ê°‘ì„ í”„ë¡œê·¸ë˜ë°í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ê°€ìŠ¤ ìš”ê¸ˆì´ ì ê²Œ ë“¤ë„ë¡ ë©”ì‹œì§€ë‹¹ 12ê°œì˜ íŠ¸ëœì­ì…˜ì„ ì „ì†¡í•œë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤.

:::info ë†’ì€ ë¶€í•˜ ê· í˜•
ê±°ë˜ë¥¼ ì™„ë£Œí•˜ë ¤ë©´ ê³„ì•½ ì”ì•¡ì´ 0.5í†¤ ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.
:::

ê° ë©”ì‹œì§€ì—ëŠ” ì½”ë“œê°€ í¬í•¨ëœ ê³ ìœ í•œ ì½”ë©˜íŠ¸ê°€ í¬í•¨ë˜ë©°, ëŒ€ìƒ ì£¼ì†ŒëŠ” ë°°í¬í•œ ì§€ê°‘ì´ ë©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, beginCell, Cell, toNano } from '@ton/core';

let internalMessages:Cell[] = [];
const walletAddress = Address.parse('put your wallet address from which you deployed high-load wallet');

for (let i = 0; i < 12; i++) {
    const internalMessageBody = beginCell()
        .storeUint(0, 32)
        .storeStringTail(`Hello, TON! #${i}`)
        .endCell();

    const internalMessage = beginCell()
        .storeUint(0x18, 6) // bounce
        .storeAddress(walletAddress)
        .storeCoins(toNano('0.01'))
        .storeUint(0, 1 + 4 + 4 + 64 + 32)
        .storeBit(0) // We do not have State Init
        .storeBit(1) // We store Message Body as a reference
        .storeRef(internalMessageBody) // Store Message Body Init as a reference
        .endCell();

    internalMessages.push(internalMessage);
}
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "fmt"
  "github.com/xssnick/tonutils-go/address"
  "github.com/xssnick/tonutils-go/tlb"
  "github.com/xssnick/tonutils-go/tvm/cell"
)

var internalMessages []*cell.Cell
wallletAddress := address.MustParseAddr("put your wallet address from which you deployed high-load wallet")

for i := 0; i < 12; i++ {
  comment := fmt.Sprintf("Hello, TON! #%d", i)
  internalMessageBody := cell.BeginCell().
    MustStoreUInt(0, 32).
    MustStoreBinarySnake([]byte(comment)).
    EndCell()

  internalMessage := cell.BeginCell().
    MustStoreUInt(0x18, 6). // bounce
    MustStoreAddr(wallletAddress).
    MustStoreBigCoins(tlb.MustFromTON("0.001").NanoTON()).
    MustStoreUInt(0, 1+4+4+64+32).
    MustStoreBoolBit(false). // We do not have State Init
    MustStoreBoolBit(true). // We store Message Body as a reference
    MustStoreRef(internalMessageBody). // Store Message Body Init as a reference
    EndCell()

  messageData := cell.BeginCell().
    MustStoreUInt(3, 8). // transaction mode
    MustStoreRef(internalMessage).
    EndCell()

	internalMessages = append(internalMessages, messageData)
}
```

</TabItem>
</Tabs>

ìœ„ì˜ ê³¼ì •ì„ ì™„ë£Œí•˜ë©´ ë‚´ë¶€ ë©”ì‹œì§€ ë°°ì—´ì´ ìƒì„±ë©ë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ ë©”ì‹œì§€ ì €ì¥ìš© ì‚¬ì „ì„ ë§Œë“¤ê³  ë©”ì‹œì§€ ë³¸ë¬¸ì„ ì¤€ë¹„í•˜ê³  ì„œëª…í•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì´ ì™„ë£Œë©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Dictionary } from '@ton/core';
import { mnemonicToWalletKey, sign } from '@ton/crypto';
import * as crypto from 'crypto';

const dictionary = Dictionary.empty<number, Cell>(); // create an empty dictionary with the key as a number and the value as a cell
for (let i = 0; i < internalMessages.length; i++) {
    const internalMessage = internalMessages[i]; // get our message from an array
    dictionary.set(i, internalMessage); // save the message in the dictionary
}

const queryID = crypto.randomBytes(4).readUint32BE(); // create a random uint32 number, 4 bytes = 32 bits
const now = Math.floor(Date.now() / 1000); // get current timestamp
const timeout = 120; // timeout for message expiration, 120 seconds = 2 minutes
const finalQueryID = (BigInt(now + timeout) << 32n) + BigInt(queryID); // get our final query_id
console.log(finalQueryID); // print query_id. With this query_id we can call GET method to check if our request has been processed

const toSign = beginCell()
    .storeUint(698983191, 32) // subwallet_id
    .storeUint(finalQueryID, 64)
    // Here we create our own method that will save the 
    // transaction mode and a reference to the transaction
    .storeDict(dictionary, Dictionary.Keys.Int(16), {
        serialize: (src, buidler) => {
            buidler.storeUint(3, 8); // save transaction mode, mode = 3
            buidler.storeRef(src); // save transaction as reference
        },
        // We won't actually use this, but this method 
        // will help to read our dictionary that we saved
        parse: (src) => {
            let cell = beginCell()
                .storeUint(src.loadUint(8), 8)
                .storeRef(src.loadRef())
                .endCell();
            return cell;
        }
    }
);

const highloadMnemonicArray = 'put your high-load wallet mnemonic'.split(' ');
const highloadKeyPair = await mnemonicToWalletKey(highloadMnemonicArray); // extract private and public keys from mnemonic
const highloadWalletAddress = Address.parse('put your high-load wallet address');

const signature = sign(toSign.endCell().hash(), highloadKeyPair.secretKey); // get the hash of our message to wallet smart contract and sign it to get signature
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "crypto/ed25519"
  "crypto/hmac"
  "crypto/sha512"
  "golang.org/x/crypto/pbkdf2"
  "log"
  "math/big"
  "math/rand"
  "strings"
  "time"
)

dictionary := cell.NewDict(16) // create an empty dictionary with the key as a number and the value as a cell
for i := 0; i < len(internalMessages); i++ {
  internalMessage := internalMessages[i]                             // get our message from an array
  err := dictionary.SetIntKey(big.NewInt(int64(i)), internalMessage) // save the message in the dictionary
  if err != nil {
    return
  }
}

queryID := rand.Uint32()
timeout := 120                                                               // timeout for message expiration, 120 seconds = 2 minutes
now := time.Now().Add(time.Duration(timeout)*time.Second).UTC().Unix() << 32 // get current timestamp + timeout
finalQueryID := uint64(now) + uint64(queryID)                                // get our final query_id
log.Println(finalQueryID)                                                    // print query_id. With this query_id we can call GET method to check if our request has been processed

toSign := cell.BeginCell().
  MustStoreUInt(698983191, 32). // subwallet_id
  MustStoreUInt(finalQueryID, 64).
  MustStoreDict(dictionary)

highloadMnemonicArray := strings.Split("put your high-load wallet mnemonic", " ") // word1 word2 word3
mac := hmac.New(sha512.New, []byte(strings.Join(highloadMnemonicArray, " ")))
hash := mac.Sum(nil)
k := pbkdf2.Key(hash, []byte("TON default seed"), 100000, 32, sha512.New) // In TON libraries "TON default seed" is used as salt when getting keys
// 32 is a key len
highloadPrivateKey := ed25519.NewKeyFromSeed(k) // get private key
highloadWalletAddress := address.MustParseAddr("put your high-load wallet address")

signature := ed25519.Sign(highloadPrivateKey, toSign.EndCell().Hash())
```

</TabItem>
</Tabs>

:::note ì¤‘ìš”
ìë°”ìŠ¤í¬ë¦½íŠ¸ì™€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë™ì•ˆ ì „ì†¡ ëª¨ë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë©”ì‹œì§€ë¥¼ ë°°ì—´ë¡œ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” @ton/ton ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ë™ì•ˆ ê°œë°œìê°€ ì§ì ‘ ì§ë ¬í™” ë° ì—­ì§ë ¬í™” í”„ë¡œì„¸ìŠ¤ë¥¼ êµ¬í˜„í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë˜ê¸° ë•Œë¬¸ì— ë°œìƒí•©ë‹ˆë‹¤. ë”°ë¼ì„œ íŠ¸ëœì­ì…˜ ìì²´ë¥¼ ì €ì¥í•œ í›„ íŠ¸ëœì­ì…˜ ëª¨ë“œë¥¼ ë¨¼ì € ì €ì¥í•˜ëŠ” ë©”ì„œë“œë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤. ê°’ ë©”ì„œë“œì— `Dictionary.Values.Cell()` ì‚¬ì–‘ì„ í™œìš©í•˜ë©´ ëª¨ë“œë¥¼ ë³„ë„ë¡œ ì €ì¥í•˜ì§€ ì•Šê³  ì „ì²´ ë©”ì‹œì§€ë¥¼ ì…€ ì°¸ì¡°ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
:::

ë‹¤ìŒìœ¼ë¡œ ë‹¤ìŒ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì™¸ë¶€ ë©”ì‹œì§€ë¥¼ ìƒì„±í•˜ê³  ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { TonClient } from '@ton/ton';

const body = beginCell()
    .storeBuffer(signature) // store signature
    .storeBuilder(toSign) // store our message
    .endCell();

const externalMessage = beginCell()
    .storeUint(0b10, 2) // indicate that it is an incoming external transaction
    .storeUint(0, 2) // src -> addr_none
    .storeAddress(highloadWalletAddress)
    .storeCoins(0) // Import fee
    .storeBit(0) // We do not have State Init
    .storeBit(1) // We store Message Body as a reference
    .storeRef(body) // Store Message Body as a reference
    .endCell();

// We do not need a key here as we will be sending 1 request per second
const client = new TonClient({
    endpoint: 'https://toncenter.com/api/v2/jsonRPC',
    // apiKey: 'put your api key' // you can get an api key from @tonapibot bot in Telegram
});

client.sendFile(externalMessage.toBoc());
```

</TabItem>
<TabItem value="go" label="Golang">

```go
import (
  "context"
  "github.com/xssnick/tonutils-go/liteclient"
  "github.com/xssnick/tonutils-go/tl"
  "github.com/xssnick/tonutils-go/ton"
)

body := cell.BeginCell().
  MustStoreSlice(signature, 512). // store signature
  MustStoreBuilder(toSign). // store our message
  EndCell()

externalMessage := cell.BeginCell().
  MustStoreUInt(0b10, 2). // ext_in_msg_info$10
  MustStoreUInt(0, 2). // src -> addr_none
  MustStoreAddr(highloadWalletAddress). // Destination address
  MustStoreCoins(0). // Import Fee
  MustStoreBoolBit(false). // No State Init
  MustStoreBoolBit(true). // We store Message Body as a reference
  MustStoreRef(body). // Store Message Body as a reference
  EndCell()

connection := liteclient.NewConnectionPool()
configUrl := "https://ton-blockchain.github.io/global.config.json"
err := connection.AddConnectionsFromConfigUrl(context.Background(), configUrl)
if err != nil {
  panic(err)
}
client := ton.NewAPIClient(connection)

var resp tl.Serializable
err = client.Client().QueryLiteserver(context.Background(), ton.SendMessage{Body: externalMessage.ToBOCWithFlags(false)}, &resp)

if err != nil {
  log.Fatalln(err.Error())
  return
}
```

</TabItem>
</Tabs>

ì´ í”„ë¡œì„¸ìŠ¤ê°€ ì™„ë£Œë˜ë©´ ì§€ê°‘ì„ ì¡°íšŒí•˜ì—¬ ì§€ê°‘ì—ì„œ 12ê°œì˜ ë°œì‹  íŠ¸ëœì­ì…˜ì´ ì „ì†¡ëœ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì½˜ì†”ì—ì„œ ì²˜ìŒì— ì‚¬ìš©í•œ ì¿¼ë¦¬ ì•„ì´ë””ë¥¼ ì‚¬ìš©í•´ `processed?` GET ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ ìš”ì²­ì´ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬ë˜ì—ˆë‹¤ë©´ `-1`(ì°¸)ì˜ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

## ğŸ ê²°ë¡ 

ì´ íŠœí† ë¦¬ì–¼ì„ í†µí•´ TON ë¸”ë¡ì²´ì¸ì—ì„œ ë‹¤ì–‘í•œ ì§€ê°‘ ìœ í˜•ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ì— ëŒ€í•´ ë” ì˜ ì´í•´í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ë˜í•œ ë¯¸ë¦¬ ì •ì˜ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„ ì™¸ë¶€ ë° ë‚´ë¶€ ë©”ì‹œì§€ë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì„ ë°°ìš¸ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

ì´ë¥¼ í†µí•´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©ìœ¼ë¡œë¶€í„° ë…ë¦½í•˜ê³  TON ë¸”ë¡ì²´ì¸ì˜ êµ¬ì¡°ë¥¼ ë³´ë‹¤ ì‹¬ë„ ìˆê²Œ ì´í•´í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ë˜í•œ ê³ ìš©ëŸ‰ ì§€ê°‘ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê³  ë‹¤ì–‘í•œ ë°ì´í„° ìœ í˜•ê³¼ ë‹¤ì–‘í•œ ì‘ì—…ê³¼ ê´€ë ¨ëœ ë§ì€ ì„¸ë¶€ ì‚¬í•­ì„ ë¶„ì„í–ˆìŠµë‹ˆë‹¤.

## ğŸ§© ë‹¤ìŒ ë‹¨ê³„

ìœ„ì— ì œê³µëœ ë¬¸ì„œë¥¼ ì½ëŠ” ê²ƒì€ ë³µì¡í•œ ì‘ì—…ì´ë©° TON í”Œë«í¼ ì „ì²´ë¥¼ ì´í•´í•˜ê¸°ëŠ” ì–´ë µìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ TONì„ ê¸°ë°˜ìœ¼ë¡œ êµ¬ì¶•í•˜ëŠ” ë° ì—´ì •ì„ ê°€ì§„ ë¶„ë“¤ì—ê²ŒëŠ” ì¢‹ì€ ì—°ìŠµì´ ë  ê²ƒì…ë‹ˆë‹¤. ë˜ ë‹¤ë¥¸ ì œì•ˆì€ ë‹¤ìŒ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¸ì¡°í•˜ì—¬ TONì—ì„œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê¸° ì‹œì‘í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤: [FunC ê°œìš”](https://docs.ton.org/develop/func/overview), [ëª¨ë²” ì‚¬ë¡€](https://docs.ton.org/develop/smart-contracts/guidelines), [ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì˜ˆì‹œ](https://docs.ton.org/develop/smart-contracts/examples), [FunC ì¿¡ë¶](https://docs.ton.org/develop/func/cookbook)

ë˜í•œ ë‹¤ìŒ ë¬¸ì„œë¥¼ ìì„¸íˆ ìˆ™ì§€í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤: [ton.pdf](https://docs.ton.org/ton.pdf) ë° [tblkch.pdf](https://ton.org/tblkch.pdf) ë¬¸ì„œ.

## ğŸ“¬ ì €ì ì†Œê°œ

ì§ˆë¬¸, ì˜ê²¬, ì œì•ˆì´ ìˆìœ¼ì‹œë©´ [í…”ë ˆê·¸ë¨](https://t.me/aspite)(@aSpite ë˜ëŠ” @SpiteMoriarty) ë˜ëŠ” [ê¹ƒí—ˆë¸Œ](https://github.com/aSpite)ì—ì„œ ì´ ë¬¸ì„œ ì„¹ì…˜ì˜ ì‘ì„±ìì—ê²Œ ì—°ë½í•´ ì£¼ì„¸ìš”.

## ğŸ“– ì°¸ê³  í•­ëª©

- ì§€ê°‘ì˜ ì†ŒìŠ¤ ì½”ë“œ: [V3](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc), [V4](https://github.com/ton-blockchain/wallet-contract/blob/main/func/wallet-v4-code.fc), [ê³ ë¶€í•˜](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet-v2-code.fc)

- ìœ ìš©í•œ ê°œë… ë¬¸ì„œ(ì˜¤ë˜ëœ ì •ë³´ê°€ í¬í•¨ë  ìˆ˜ ìˆìŒ): [ton.pdf](https://docs.ton.org/ton.pdf), [tblkch.pdf](https://ton.org/tblkch.pdf), [tvm.pdf](https://ton.org/tvm.pdf)

ì£¼ìš” ì½”ë“œ ì†ŒìŠ¤:

- [@í†¤/í†¤(JS/TS)](https://github.com/ton-org/ton)
- [@ton/core (JS/TS)](https://github.com/ton-org/ton-core)
- [@ton/crypto (JS/TS)](https://github.com/ton-org/ton-crypto)
- [tonutils-go (GO)](https://github.com/xssnick/tonutils-go).

ê³µì‹ ë¬¸ì„œ:

- [ë‚´ë¶€ ë©”ì‹œì§€](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ê³„ì•½/ê°€ì´ë“œë¼ì¸/ë‚´ë¶€ ë©”ì‹œì§€)

- [ì™¸ë¶€ ë©”ì‹œì§€](/ê°œë°œ/ìŠ¤ë§ˆíŠ¸-ê³„ì•½/ê°€ì´ë“œë¼ì¸/ì™¸ë¶€ ë©”ì‹œì§€)

- [ì§€ê°‘ ê³„ì•½ ìœ í˜•](/ì°¸ì—¬í•˜ê¸°/ì§€ê°‘/ê³„ì•½#ì§€ê°‘-v4)

- [TL-B](/ê°œë°œ/ë°ì´í„°-í¬ë§·/tl-b-language)

- [ë¸”ë¡ì²´ì¸ì˜ ë¸”ë¡ì²´ì¸](https://docs.ton.org/learn/overviews/ton-blockchain)

ì™¸ë¶€ ì°¸ì¡°:

- [í†¤ ë”¥](https://github.com/xssnick/ton-deep-doc)

- [Block.tlb](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb)

- [í†¤ ë‹¨ìœ„ í‘œì¤€](https://github.com/ton-blockchain/TEPs)
