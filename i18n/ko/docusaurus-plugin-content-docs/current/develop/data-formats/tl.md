# TL

TL(타입 언어)은 데이터 구조를 설명하는 언어입니다.

통신 시 유용한 데이터를 구조화하기 위해 [TL 스키마](https://github.com/ton-blockchain/ton/tree/master/tl/generate/scheme)가 사용됩니다.

TL은 32비트 블록에서 작동합니다. 따라서 TL의 데이터 크기는 4바이트의 배수여야 합니다.
객체의 크기가 4의 배수가 아닌 경우 필요한 수의 0 바이트를 배수까지 더해야 합니다.

숫자는 항상 리틀 엔디안 순서로 인코딩됩니다.

TL에 대한 자세한 내용은 [텔레그램 문서](https://core.telegram.org/mtproto/TL)에서 확인하실 수 있습니다.

## 인코딩 바이트 배열

바이트 배열을 인코딩하려면 먼저 그 크기를 결정해야 합니다.
크기가 254바이트 미만이면 1바이트를 크기로 하는 인코딩이 사용됩니다. 그 이상이면
0xFE가 큰 배열의 표시로 첫 번째 바이트로 쓰여지고 그 뒤에 3바이트의 크기가 이어집니다.

예를 들어 `[0xAA, 0xBB]` 배열을 인코딩하고 그 크기는 2입니다. 1바이트
크기를 사용한 다음 데이터 자체를 쓰면 `[0x02, 0xAA, 0xBB]`가 되고 완료되지만 최종 크기가 4바이트의 배수가 아닌 3이라는 것을
확인하므로 1바이트의 패딩을 추가하여 4가 되도록 해야 합니다. 결과: `[0x02, 0xAA, 0xBB, 0x00]`.

예를 들어 크기가 396인 배열(
)을 인코딩해야 하는 경우 이렇게 합니다: 396 >= 254이므로 크기 인코딩에 3바이트와 1바이트 초과 크기 표시기를 사용하여
을 얻습니다: `[0xFE, 0x8C, 0x01, 0x00, 배열 바이트]`, 396+4 = 400으로, 4의 배수이므로 정렬할 필요가 없습니다.

## 명확하지 않은 직렬화 규칙

스키마 자체 앞에 4바이트 접두사, 즉 ID가 쓰이는 경우가 많습니다. 스키마 ID는 스키마 텍스트에서 `;` 및 대괄호 `()`와 같은 기호는 이전에 텍스트에서 제거된 반면, IEEEE 테이블이 있는 CRC32입니다. ID 접두사가 있는 스키마의 직렬화를 **boxed**라고 하며, 이를 통해 구문 분석기는 여러 옵션이 있는 경우 앞에 오는 스키마를 결정할 수 있습니다.

박스형으로 직렬화할지 여부를 결정하는 방법은 무엇인가요? 스키마가 다른 스키마의 일부인 경우 필드 유형이 명시적으로 지정된 경우 접두사 없이 직렬화하고, 명시적으로 지정되지 않은 경우(이러한 유형이 많이 있음) 박스형으로 직렬화해야 합니다. 예시:

```tlb
pub.unenc data:bytes = PublicKey;
pub.ed25519 key:int256 = PublicKey;
pub.aes key:int256 = PublicKey;
pub.overlay name:bytes = PublicKey;
```

이러한 유형은 스키마에 'PublicKey'가 명시적으로 지정되지 않은 경우, 예를 들어 `adnl.node id:PublicKey addr_list:adnl.addressList = adnl.Node`와 같이 명시적으로 지정되어 있지 않고 ID 접두사(박스형)로 직렬화해야 하는 경우입니다. 그리고 다음과 같이 지정한 경우 `adnl.node id:pub.ed25519 addr_list:adnl.addressList = adnl.Node`와 같이 지정하면 명시적이므로 접두사가 필요하지 않습니다.

## 참조

여기 [Oleg Baranov](https://github.com/xssnick)의 [원본 기사 링크](https://github.com/xssnick/ton-deep-doc/blob/master/TL.md)가 있습니다.
