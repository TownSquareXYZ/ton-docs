import ThemedImage from '@theme/ThemedImage';
import ConceptImage from '@site/src/components/conceptImage'
import Player from '@site/src/components/player'

# TON 시작하기

TON 블록체인에서 첫 번째 애플리케이션을 처음부터 설정하고 속도, 안정성, 비동기식 사고방식의 필수 개념을 알아보세요.

:::tip 신규 이민자 친화적인 가이드
프로그래밍을 완전히 처음 접하는 분이라면 이 가이드가 최고의 선택입니다.
:::

이 학습 경로에는 **5개의 모듈**이 포함되어 있으며 약 \_\_45분 정도 소요됩니다.

## 🛳 학습 내용

이 튜토리얼에서는 자바스크립트를 사용해 블록체인 트랜잭션을 쉽게 만드는 방법을 배우게 됩니다. 이 튜토리얼 없이도 배울 수 있지만, 이 방법은 편리하고 사용자 친화적입니다.

1. 톤키퍼로 나만의 톤 월렛을 만들 수 있습니다.
2. 테스트를 위해 테스트넷 수도꼭지를 사용하여 지갑을 충전하게 됩니다.
3. TON 스마트 컨트랙트의 필수 개념(주소, 셀)을 이해하게 됩니다.
4. TypeScript SDK 및 API 공급자를 사용하여 TON과 상호 작용하는 방법을 배웁니다.
5. NFT 마이너 콘솔 애플리케이션을 사용하여 첫 번째 트랜잭션을 컴파일합니다.

 NFT 로켓 업적을 채굴할 수 있습니다!!!!

TON의 첫 번째 채굴자는 작업 증명 스마트 컨트랙트를 통해 마침내 TON 지갑에 대한 비밀 보상을 채굴하게 됩니다. 확인해 보세요:

```mdx-code-block
<div style={{width: '100%', maxWidth:'250pt',  textAlign: 'center', margin: '0 auto' }}>
  <video width={'300'} style={{width: '100%', maxWidth:'250pt',  borderRadius: '10pt', margin: '15pt auto' }} muted={true} autoPlay={true} loop={true}>
    <source src="/files/onboarding-nft.mp4" type="video/mp4" />
```

브라우저가 동영상 태그를 지원하지 않습니다.

```mdx-code-block
  </video>
</div>
```

오늘의 목표는 NFT를 채굴하는 것입니다! 이 성과는 여러분과 함께 _영원히_ 남을 것입니다.

마지막으로, 메인넷에서도 이 NFT 업적을 채굴할 수 있습니다. (_비용은 0,05톤에 불과합니다!_)

### 동영상 튜토리얼

TON 개발자 커뮤니티 회원이 만든 멋진 동영상 튜토리얼을 확인하세요! 이 유용한 가이드를 참고하면 튜토리얼을 쉽게 완료할 수 있습니다:

<Player url="https://youtu.be/wEEQLwQy30Q" />

### TON 블록체인 채굴

오늘은 예비 빌더들에게 톤 블록체인에서 채굴하는 방법을 알려드리고자 합니다. 이 경험을 통해 여러분 모두 채굴의 중요성과 비트코인 채굴이 업계에 혁명을 일으킨 이유를 이해할 수 있을 것입니다.

TON의 기반을 마련하는 데 도움이 된 초기 채굴 프로세스를 정의한 작업 증명 기버 스마트 컨트랙트 프레임워크는 출시와 동시에 완료되었지만, 2022년 6월에 마지막 TON이 채굴되어 TON의 작업 증명(PoW) 토큰 분배 메커니즘의 정점을 찍었습니다. 하지만 최근 지분 증명(PoS)으로의 전환을 통해 TON의 스테이킹 시대가 막 시작되었습니다.

- [TON의 경제 모델과 채굴에 대해 더 자세히 알아보기](https://ton.org/mining)

이제 **TVM 개발자**가 되기 위한 첫 번째 단계에 집중하여 TON에서 NFT를 채굴하는 방법을 배워보겠습니다! 아래는 우리가 만들고자 하는 것의 예시입니다.

```mdx-code-block
<div style={{ width: '100%', textAlign: 'center', margin: '0 auto' }}>
  <video style={{ width: '100%', borderRadius: '10pt', margin: '15pt auto', maxWidth: '90%' }} muted={true} autoPlay={true}
         loop={true}>
    <source src="/files/onboarding.mp4" type="video/mp4" />
```

브라우저가 동영상 태그를 지원하지 않습니다.

```mdx-code-block
  </video>
</div>
```

당면한 작업에 집중하면 30분 정도면 채굴기를 만들 수 있습니다.

## 🦄 시작하기

시작하기 위해 모든 개발자는 다음 구성 요소를 사용합니다:

- **Wallet**테스트넷 모드에서 NFT를 보관하려면 비위탁형 지갑이 필요합니다.
- **Repository**: 사용자를 위해 특별히 설계된 기성 템플릿을 사용합니다.
- 개발자 환경\_\_:  개발자는 로컬 환경 또는 클라우드 환경을 사용하여 채굴할지 여부를 결정해야 합니다.

### 지갑 다운로드 및 생성

먼저 톤을 수령하고 보관할 수 있는 비위탁 지갑이 필요합니다. 이 가이드에서는 이를 위해 톤키퍼를 사용하고 있습니다. 테스트넷 톤코인을 받으려면 지갑 내에서 테스트넷 모드를 활성화해야 합니다. 이 토큰은 나중에 스마트 컨트랙트에 최종 채굴 트랜잭션을 전송하는 데 사용됩니다.

:::info
비수탁형 지갑을 사용하면 사용자가 지갑을 소유하고 개인 키를 직접 보유하게 됩니다.
:::

TON 지갑을 다운로드하고 생성하려면 다음의 간단한 단계를 따르세요:

1. 스마트폰에 톤키퍼 앱을 설치합니다. 여기에서 다운로드할 수 있습니다(https://Tonkeeper.com/).
2. 다음으로, Tonkeeper 내에서 [테스트 모드 활성화](/참여/지갑/앱#Tonkeeper-test-environment)를 설정해야 합니다.

쉬워요! 이제 개발을 시작해 보겠습니다.

### 프로젝트 설정

사용자의 편의를 돕고 일상적인 낮은 수준의 내용을 건너뛰기 위해 상용구를 사용합니다.

:::tip
추가 작업을 하려면 GitHub에 [로그인](https://github.com/login)해야 합니다.
:::

톤온보딩챌린지](https://github.com/ton-community/ton-onboarding-challenge) 템플릿을 사용하여 아래와 같이 "이 템플릿 사용" 버튼을 클릭하고 "새 리포지토리 만들기" 탭을 선택하여 프로젝트를 생성하세요:

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/1.png?raw=true',
        dark: '/img/tutorials/onboarding/1-dark.png?raw=true',
    }}
/>
<br></br>
```

이 단계를 완료하면 마이너의 코어로 사용할 수 있는 고성능 저장소에 액세스하실 수 있습니다. 축하합니다! ✨

### 개발 환경

다음 단계는 자신의 요구 사항, 경험 수준 및 전반적인 기술 수준에 가장 적합한 개발자 환경을 선택하는 것입니다. 보시다시피 클라우드 기반 또는 로컬 환경을 사용하여 이 프로세스를 수행할 수 있습니다. 클라우드에서 개발하는 것이 더 간단하고 시작하기 쉬운 것으로 간주되는 경우가 많습니다. 아래에서는 두 가지 접근 방식에 필요한 단계를 간략하게 설명합니다.

:::tip
이전 단계의 템플릿에서 생성한 리포지토리를 GitHub 프로필에서 열었는지 확인합니다.
:::

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/3.png?raw=true',
        dark: '/img/tutorials/onboarding/3-dark.png?raw=true',
    }}
/>
<br></br>
```

#### 로컬 및 클라우드 개발 환경

- JavaScript에 익숙하지 않은 사용자의 경우, 특히 컴퓨터와 툴링 시스템이 이 용도로 구성되지 않은 경우 JavaScript IDE를 사용하는 것이 어려울 수 있습니다.

- 하지만 NodeJS와 Git에 익숙하고 'npm'을 사용하는 방법을 알고 있다면 **로컬 환경**을 사용하는 것이 더 편할 수 있습니다.

#### 클라우드 코드스페이스

클라우드 개발 환경을 선택한 경우 먼저 _코드_ 탭을 선택한 다음 아래와 같이 GitHub 리포지토리 내에서 _마스터에 코드스페이스 만들기_ 버튼을 클릭하면 쉽게 시작할 수 있습니다:

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/2.png?raw=true',
        dark: '/img/tutorials/onboarding/2-dark.png?raw=true',
    }}
/>
<br></br>
```

이 단계를 완료하면 GitHub에서 VSCode 온라인 IDE(Visual Code 온라인 통합 개발 환경)에 액세스할 수 있는 특별한 클라우드 작업 공간이 만들어집니다.

액세스 권한이 부여되면(코드스페이스는 일반적으로 약 30초 후에 시작됨) Git, Node.js 또는 기타 개발자 도구를 설치할 필요 없이 시작하는 데 필요한 모든 것을 갖추게 됩니다.

#### 로컬 개발 환경

로컬 개발 환경을 설정하려면 다음 세 가지 필수 도구에 액세스할 수 있어야 합니다:

- **Git**: Git은 모든 개발자가 리포지토리로 작업하는 데 필요한 필수 도구입니다. 여기에서 다운로드할 수 있습니다(https://git-scm.com/downloads).
- **NodeJS**: Node.js는 일반적으로 TON에서 애플리케이션 개발에 사용되는 자바스크립트 및 타입스크립트 런타임 환경입니다. 여기에서 다운로드할 수 있습니다(https://nodejs.org/en/download/).
- **자바스크립트 IDE**. 자바스크립트 IDE는 일반적으로 로컬 개발 환경 내에서 개발하는 데 사용됩니다. 이 경우의 예로는 Visual Studio Code([VSCode](https://code.visualstudio.com/download))가 있습니다.

시작하려면 GitHub 리포지토리 상용구를 복제하고 통합 개발 환경(IDE)에서 올바른 리포지토리를 열어야 합니다.

#### 스크립트 실행

이 가이드에서는 TypeScript 스크립트를 실행해야 합니다. 스크립트 실행이나 모듈 설치와 같은 모든 명령은 IDE의 터미널 작업 영역에 있는 명령줄을 통해 실행됩니다. 이 작업 영역은 일반적으로 IDE 하단에 있습니다.

예를 들어 클라우드 코드스페이스에서 터미널 워크스페이스(아직 열려 있지 않은 경우)를 열어야 합니다:

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/6.png?raw=true',
        dark: '/img/tutorials/onboarding/6-dark.png?raw=true',
    }}
/>
<br></br><br></br>
```

이 창에 명령을 입력하고 _Enter_로 실행합니다:

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/4.png?raw=true',
        dark: '/img/tutorials/onboarding/4-dark.png?raw=true',
    }}
/>
<br></br><br></br>
```

터미널은 별도의 애플리케이션으로도 사용할 수 있습니다. 사용 중인 IDE와 OS에 따라 적절한 버전을 선택하세요.

훌륭합니다! 이 단계를 마치면 톤 블록체인의 비밀에 대해 더 자세히 알아볼 준비가 된 것입니다. 👀

## 🎯 TON에 연결

좋아요, TON 블록체인에 연결하려면 무엇이 필요하나요?

- 스마트 컨트랙트 주소를 목적지로 지정합니다. 우리의 목표는 _작업 증명 스마트 컨트랙트_에서 NFT를 채굴하는 것이므로, 현재 채굴 복잡도를 파악하기 위한 주소가 필요합니다.
- API 제공자\_\_를 통해 TON 블록체인에 요청할 수 있습니다. TON에는 다양한 목적에 따라 여러 [API 유형](/develop/dapps/apis/)이 있습니다. 여기서는 테스트넷 버전의 [toncenter.com](https://toncenter.com/) API를 사용하겠습니다.
- 자바스크립트 SDK\_\_: 사용 중인 스마트 컨트랙트 주소를 구문 분석하고 API 요청을 생성하기 위해 준비하려면 JavaScript SDK(SDK는 소프트웨어 개발 키트라는 점을 기억하세요)가 필요합니다. TON 주소와 이 절차를 수행하기 위해 주소를 파싱해야 하는 이유를 더 잘 이해하려면 이 [리소스](/학습/개요/주소)를 참조하시기 바랍니다. 이 절차를 수행하기 위해 [ton.js](https://github.com/ton-core/ton)를 사용합니다.

다음 섹션에서는 사용자가 작업 증명 스마트 컨트랙트에서 데이터를 받기 위해 TONCenter API와 ton.js를 사용하여 TON 블록체인에 초기 요청을 보내는 방법을 설명하겠습니다.

### 스마트 컨트랙트 주소

마이너가 올바르게 작동하려면 두 가지 다른 스마트 컨트랙트 주소 유형을 추가해야 합니다. 여기에는 다음이 포함됩니다:

1. 지갑 주소\_\_: 채굴자가 채굴 보상을 받기 위해서는 지갑 주소가 필요하므로 지갑 주소가 필요합니다(이 경우 [톤키퍼 테스트넷 모드](/참여/지갑/앱#톤키퍼-테스트-환경)를 사용해야 합니다).
2. 수집 주소\_\_: 수집 주소는 NFT를 올바르게 채굴하기 위한 스마트 컨트랙트로 작동하기 위해 필요합니다(이 과정을 수행하려면 [Getgems 웹사이트](https://testnet.getgems.io/collection/EQDk8N7xM5D669LC2YACrseBJtDyFqwtSPCNhRWXU7kjEptX)에서 TON 언보딩 챌린지 수집 이름 아래에 있는 NFT 수집 주소를 복사하세요).

다음으로, 마이너에서 `index.ts` 파일을 열고 다음과 같이 초기 상수로 구성된 메인 함수를 생성하겠습니다:

```ts title="ton-onboarding-challenge/index.ts"
import {Address} from "ton"

async function main () {

  const wallet = Address.parse('YOUR_WALLET_ADDRESS');
  const collection = Address.parse('COLLECTION_ADDRESS');

}

main()
```

#### 비동기 main() 함수 사용

나중에 TON NFT 채굴기를 생성하는 과정에서 원하는 명령어와 교환하여 올바른 코드 문자열에 대한 응답을 릴레이하기 위해 공용 API에 여러 요청을 실행합니다. 비동기/대기 기능을 활용하면 코드 단순성이 크게 향상됩니다.

#### 주소 구문 분석

TON에서 스마트 컨트랙트 주소는 다양한 플래그 유형을 사용하는 다양한 형태로 제공됩니다. 여기서는 특히 _사용자 친화적인 주소 형식_을 사용하겠습니다. 다양한 스마트 컨트랙트 주소 유형에 대해 더 자세히 알고 싶으시다면, 저희 문서에서 추가 [리소스](https://ton.org/docs/learn/overviews/addresses)를 확인하시기 바랍니다.

마이너가 올바르게 작동하려면 두 가지 다른 스마트 컨트랙트 주소 유형을 추가해야 합니다. 여기에는 다음이 포함됩니다:

개발자는 `ton.js` SDK에 있는 `Address.parse()` 명령을 사용하여 주소 객체를 생성하여 간단한 방식으로 주소를 한 형식에서 다른 형식으로 변환할 수 있습니다.

### API 제공업체에 연결

이 단계에서는 스크립트의 특정 명령을 사용하여 톤센터(toncenter.com에서 호스팅됨) API 제공업체를 통해 톤에 연결합니다.

작동 방식을 알아보는 가장 간단한 방법은 @orbs-network/ton-access를 사용하는 것입니다.

:::tip
가져오기`로 새 모듈을 추가하는 경우, [터미널](/개발/시작하기-톤#실행 스크립트)에서 `npm i @orbs-network/ton-access\` 명령을 실행하여 설치해야 할 수 있다는 점을 기억하세요.
:::

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/5.png?raw=true',
        dark: '/img/tutorials/onboarding/5-dark.png?raw=true',
    }}
/>
<br></br>
```

index.ts`스크립트에서`@orbs-network/ton-access`의 _TonClient_ 및 _getHttpEndpoint_를 사용하여 `client`및`endpoint\`를 추가합니다:

```ts title="ton-onboarding-challenge/index.ts"
import {Address, TonClient} from "ton"
import {getHttpEndpoint} from "@orbs-network/ton-access";

  // ... previous code

  // get the decentralized RPC endpoint in Testnet
  const endpoint = await getHttpEndpoint({
    network: "testnet",
  });

  // initialize ton library
  const client = new TonClient({ endpoint });

```

:::info 프로덕션에서 무엇을 해야 하나요?
RPC 노드 공급자를 사용하거나 자체 톤-http-api 인스턴스를 실행하는 것이 좋습니다. 자세한 내용은 [톤센터 API 페이지](/develop/dapps/apis/toncenter)에서 확인하세요.
:::

### TON 블록체인에서 마이닝 데이터 수신

마지막으로, 프로세스의 다음 단계는 TON 블록체인에서 특정 채굴 데이터를 검색하는 것입니다.

톤 온보딩 챌린지 완료에 필요한 [README 파일](https://github.com/ton-community/ton-onboarding-challenge#mining-process-advanced)을 참고하여 'get_mining_data' 메서드를 실행하면 최신 톤 채굴 데이터를 얻을 수 있습니다. 실행 후 결과는 다음과 같습니다:

결과적으로 이러한 필드가 포함된 배열을 수신해야 합니다:

```bash
(
	int pow_complexity,
	int last_success,
	int seed,
	int target_delta,
	int min_cpl,
	int max_cpl
)
```

#### TON에서 스마트 컨트랙트 가져오기 메서드 실행

ton.js\`를 사용하여 callGetMethod(SMART_CONTRACT_ADDRESS, METHOD) 함수를 실행할 수 있습니다.
이 코드를 실행하면 다음과 같은 콘솔 출력이 나타납니다:

```ts title="ton-onboarding-challenge/index.ts"
  // ... previous code

  const miningData = await client.callGetMethod(collection, 'get_mining_data')

  console.log(miningData)
```

또한 스크립트를 실행하려면 [터미널에서] 다음 명령어를 입력해야 합니다(/develop/get-started-with-ton#running-scripts):

```bash
npm run start
```

:::tip
예상치 못한 문제를 방지하려면 계약 주소 입력을 포함한 모든 이전 단계를 완료했는지 확인하세요.
:::

완료! 위의 프로세스가 올바르게 실행되었다면 API에 성공적으로 연결되고 필요한 데이터가 콘솔에 표시됩니다. 올바른 콘솔 출력은 다음과 같이 시작되어야 합니다:

```bash
{
  gas_used: 2374,
  stack: [
    [
      'num',
      '0x2880000000000000000000000000000000000000000000000000000000000'
    ],
    [ 'num', '0x63984815' ],
    [ 'num', '0x357401cf9b4f2386950faefd6b616264' ],
    [ 'num', '0x1e' ],
    [ 'num', '0xab' ],
    [ 'num', '0xfc' ]
  ]
}
```

위에는 프로세스를 실행하는 데 사용된 가스 양과 숫자(_num_) 값의 합이 16진수 형식으로 표시됩니다. 이때 이 데이터는 16진수 출력 데이터를 보다 쉽게 사용할 수 있는 형태로 변환하는 것이 필요하기 때문에 그다지 중요하지 않습니다.

16진수 출력을 _유용한_ 것으로 변환해야 합니다.

:::info 톤의 가스 매개 변수:

1. TON 가상 머신(TVM)의 작동 방식과 _TON이 트랜잭션을 처리하는 방식_에 대해 자세히 알아보려면 [TVM 개요 섹션](/학습/tvm-지침/tvm-overview)을 확인하세요.
2. 둘째, TON에서 거래 및 가스 수수료가 어떻게 작동하는지에 대해 자세히 알아보고 싶으시다면 [이 섹션](/개발/스마트-계약/수수료) 문서를 참조하세요.
3. 마지막으로, TVM 지침을 수행하는 데 필요한 정확한 가스 값을 더 잘 이해하려면 [이 섹션](/학습/tvm-지침/지침#가스-가격) 문서를 참조하세요.
   :::

이제 튜토리얼로 돌아가 보겠습니다!

#### 사용자 친화적인 형식의 수치 마이닝 데이터

위의 섹션에서 채굴 데이터를 수신하는 데 필요한 16진수 형식의 가스 양과 숫자(_num_) 값에 대해 설명하면서 코드 문자열 내에 존재하는 16진수를 보다 이해하기 쉽고 사용 가능한 형식으로 변환해야 한다는 점에 주목했습니다.

주어진 출력을 살펴보면 알 수 있듯이 16진수는 크기가 상당히 클 수 있습니다. 여기에 설명된 특정 [자바스크립트 제한 사항](https://stackoverflow.com/a/307200) 때문에 변수를 만들어서 사용할 수 없습니다.

이를 변환할 방법이 필요한데, 바로 `bn.js`(자바스크립트의 큰 숫자 구현) 라이브러리가 등장합니다. Bn.js는 개발자가 자바스크립트의 최대 정수 값보다 큰 큰 숫자로 작업할 때 사용하는 라이브러리입니다. 이 예제를 통해 이 프로세스에 필요한 _데이터 마이닝_에 대해 더 잘 이해해 보겠습니다:

```ts title="ton-onboarding-challenge/index.ts"
import {BN} from 'bn.js'

  // ... previous code

  const parseStackNum = (sn: any) => new BN(sn[1].substring(2), 'hex');

  const complexity = parseStackNum(miningData.stack[0]);
  const last_success = parseStackNum(miningData.stack[1]);
  const seed = parseStackNum(miningData.stack[2]);
  const target_delta = parseStackNum(miningData.stack[3]);
  const min_cpl = parseStackNum(miningData.stack[4]);
  const max_cpl = parseStackNum(miningData.stack[5]);

  console.log('complexity', complexity);
  console.log('last_success', last_success.toString());
  console.log('seed', seed);
  console.log('target_delta', target_delta.toString());
  console.log('min_cpl', min_cpl.toString());
  console.log('max_cpl', max_cpl.toString());
```

위에 표시된 것처럼 _miningData_의 여러 구성 요소는 다양한 매개변수에 대해 16진수 기반의 스택 기반 배열을 사용합니다(아래 섹션에서 소개할 예정임). 원하는 값의 결과를 얻기 위해, 16진수에서 BN(큰 숫자) 객체를 생성하는 parseStackNum 함수를 추가했습니다.

이 프로세스가 완료되면 콘솔 내에서 값을 인쇄해야 합니다. 이 경우 일부 값이 BN 객체로 인쇄되므로 프로세스가 더 사용자 친화적으로 만들어집니다. 명령을 실행하여 스크립트를 다시 실행해 보세요:

```bash
npm run start
```

다음은 출력 예시입니다:

```bash
complexity <BN: 2880000000000000000000000000000000000000000000000000000000000>
last_success 1670924309
seed <BN: 357401cf9b4f2386950faefd6b616264>
target_delta 30
min_cpl 171
max_cpl 252
```

마이닝 데이터를 TON 블록체인으로 프로그래밍할 때 다양한 데이터 파라미터를 변환하는 데 사용되는 마이닝 데이터 명령어를 살펴보겠습니다. 여기에는 다음이 포함됩니다:

- '복잡성'은 채굴자에게 가장 중요한 수치입니다. 이는 값에 대한 작업 증명 복잡도입니다. 최종 해시가 복잡도보다 작으면 채굴에 성공한 것입니다.
- 마지막_성공\`은 [유닉스 타임스탬프](https://www.unixtimestamp.com/) 날짜 및 시간 표현으로, TON의 마지막 채굴 트랜잭션을 추적합니다. 마지막_성공 메트릭이 변경될 때마다 마이너를 다시 실행해야 하는데, 이 과정에서 시드도 변경되기 때문입니다.
- '시드'는 스마트 컨트랙트가 원하는 해시를 계산하기 위해 생성한 고유 값을 나타냅니다. 이 과정을 더 잘 이해하고 시드가 어떻게 변경되는지, 왜 변경되는지 자세히 알아보려면 프로젝트 파일 폴더에서 ctx_seed 키워드(키워드 "ctx_seed"와 함께 Ctrl+F)를 사용해서 확인하세요.
- 목표\_델타`, `min_cpl`, `최대\_pl\`은 튜토리얼에서 사용되지 않습니다. 하지만 스마트 콘트랙트에서 작업 증명 복잡성을 계산하기 위해 이 변수들이 어떻게 사용되는지 프로젝트의 컬렉션 소스 파일에서 언제든지 자세히 알아볼 수 있습니다.

이제 위에서 설명한 다양한 파라미터를 이해했으므로, 다음 장에서 NFT 채굴기에 사용할 값(`complicity`, `last_success`, `seed`)을 얻었습니다.

## 🛠 NFT 채굴기 준비하기

정말 잘하고 계세요!

TON에 연결하고 블록체인에서 필요한 채굴 데이터를 검색하여 NFT 마이너를 생성한 후, 목표를 달성하기 위해 이 과정의 다음 단계에 집중해 보겠습니다.

이 장에서는 마이닝 메시지를 _준비_하고 메시지의 해시를 _계산_할 것입니다. 그 후 스마트 콘트랙트에서 얻은 복잡도보다 적은(`<`) 해시를 _찾습니다_.

이것이 바로 마이너입니다! 간단하지 않나요?

### 마이닝 메시지 준비

먼저, 이 프로세스의 유효성과 데이터 무결성을 보장하기 위해 올바른 매개변수를 확보하여 마이닝 메시지를 준비해야 합니다.

다행히도 [README 파일](https://github.com/ton-community/ton-onboarding-challenge#mining-process-advanced)을 통해 이 목표를 달성하는 데 필요한 올바른 지침을 검색할 수 있습니다. 보시다시피, 위의 README 파일은 특정 필드와 셀 유형('작업 증명 셀의 레이아웃'이라는 제목)이 포함된 표로 구성되어 있어 원하는 결과를 얻을 수 있도록 도와줍니다.

:::info 셀이란 무엇인가요?
셀은 네트워크 확장성 및 스마트 컨트랙트 트랜잭션 속도 향상 등 다양한 목적을 달성하는 TON의 데이터 저장 구조입니다. 여기서는 자세히 설명하지 않겠지만, 셀의 복잡성과 작동 방식에 대해 더 자세히 알고 싶으시다면 [이 문서](/학습/개요/셀) 섹션을 참고하시기 바랍니다.
:::

다행히도 이 튜토리얼에서 사용된 모든 데이터 구조는 이미 타입스크립트로 작성되어 있습니다. NftGiver.data.ts_의 `MineMessageParams` 객체를 사용하여 \_Queries_로 트랜잭션을 빌드합니다:

```ts title="ton-onboarding-challenge/index.ts"
  import {unixNow} from "./src/lib/utils";
  import {MineMessageParams, Queries} from "./src/giver/NftGiver.data";

  // ... previous code

  const mineParams : MineMessageParams = {
    expire: unixNow() + 300, // 5 min is enough to make a transaction
    mintTo: wallet, // your wallet
    data1: new BN(0), // temp variable to increment in the miner
    seed // unique seed from get_mining_data
  };

  let msg = Queries.mine(mineParams); // transaction builder
```

아마도 질문이 있으실 겁니다: [table](https://github.com/ton-community/ton-onboarding-challenge#mining-process-advanced)의 _op_과 _data2_는 어디에 있을까요?

- 테이블에서 데이터1의 숫자 값은 데이터2의 숫자 값과 같아야 합니다. data2 값 채우기를 생략하기 위해 트랜잭션 빌더는 저수준 프로세스를 수행합니다(Queries.mine() 소스 참조).
- op`분류는 항상 상수이기 때문에 트랜잭션 빌더 _Queries_와 _OperationCodes_에 이미 구현되어 있습니다. 연산 코드는`mine()\` 메서드의 소스 코드로 이동하여 찾을 수 있습니다.

:::tip
소스 코드(`./src/giver/NftGiver.data`)를 확인하는 것이 흥미로울 수도 있지만, 반드시 그럴 필요는 없습니다.
:::

### TON NFT 채굴자 생성

이제 TON 마이너를 위한 메시지 준비 과정을 완료했으니, 실제로 마이너를 생성하는 초기 과정으로 넘어가 보겠습니다. 먼저 이 코드 줄을 살펴보겠습니다:

```ts
let msg = Queries.mine(mineParams);
```

위에서 `msg` 값을 컴파일했습니다. 마이닝의 개념은 마지막으로 수신한 _get_mining_data()_에서 `complicity`보다 작은 해시 `msg.hash()`를 찾는 것입니다. 데이터1\`은 필요한 만큼 증가시킬 수 있습니다.

순수 채굴기는 `msg.hash()`가 `복잡성`보다 큰 한(메시지 해시가 작업 증명 채굴 복잡성보다 큰 경우) 계속 무한히 실행됩니다.

다음은 TypeScript에서 BigNumbers와 관련된 코드 실행 예시입니다:

```ts title="ton-onboarding-challenge/index.ts"
  let msg = Queries.mine(mineParams);

  while (new BN(msg.hash(), 'be').gt(complexity)) {
    mineParams.expire = unixNow() + 300
    mineParams.data1.iaddn(1)
    msg = Queries.mine(mineParams)
  }

  console.log('Yoo-hoo, you found something!')
```

빅넘버(_BN_) 함수와 관련하여 몇 가지 중요한 고려 사항이 있습니다:

- 'be'`속성을 가진`msg.hash()\`에서 _big-endian_ BN 객체를 생성합니다.
- gt()\`: _BigNumbers_를 비교하기 위해 _변수보다 큰_을 나타냅니다.
- `iaddn(1)`: 증분된 값을 나타냅니다.

위의 단계를 완료하면 채굴기가 제대로 작동하지만, 시각적으로 보기 좋지 않은 모양을 갖게 됩니다(`npm 실행 시작`을 시도해 보세요). 따라서 우리는 이 문제를 해결해야 합니다. 시작해 보겠습니다.

#### 톤 광부 외형 개선 ✨

이제 광부를 섹시하게 만들고 싶어요! 어떻게 하면 될까요?

날 따라오세요, 친구, 날 따라오세요.

목표를 달성하기 위해 다음 명령을 추가하겠습니다:

```ts title="ton-onboarding-challenge/index.ts"
  let msg = Queries.mine(mineParams);
  let progress = 0;

  while (new BN(msg.hash(), 'be').gt(complexity)) {
    progress += 1
    console.clear()
    console.log(`Mining started: please, wait for 30-60 seconds to mine your NFT!`)
    console.log(' ')
    console.log(`⛏ Mined ${progress} hashes! Last: `, new BN(msg.hash(), 'be').toString())

    mineParams.expire = unixNow() + 300
    mineParams.data1.iaddn(1)
    msg = Queries.mine(mineParams)
  }

  console.log(' ')
  console.log('💎 Mission completed: msg_hash less than pow_complexity found!');
  console.log(' ')
  console.log('msg_hash: ', new BN(msg.hash(), 'be').toString())
  console.log('pow_complexity: ', complexity.toString())
  console.log('msg_hash < pow_complexity: ', new BN(msg.hash(), 'be').lt(complexity))
```

한번 확인해 보세요! 명령을 실행해 보겠습니다:

```bash
npm run start
```

```mdx-code-block
<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/tutorials/onboarding/7.png?raw=true',
        dark: '/img/tutorials/onboarding/7-dark.png?raw=true',
    }}
/>
<br></br>
```

멋지지 않나요? \_ 😏

이러한 명령이 올바르게 실행되면 시각적으로 매력적인 NFT 채굴기를 갖게 될 것입니다. 다음 섹션에서는 지갑을 채굴기에 연결하여 TON 블록체인에서 트랜잭션을 받고 받을 수 있는 결제 채널을 만드는 데 집중하겠습니다.

## 🎨 거래 준비

다음으로, 메시지를 컴파일하고 [톤키퍼 지갑](https://Tonkeeper.com/)으로 블록체인에 전송하는 단계를 간략하게 설명하겠습니다.
다음 단계에서는 TON에서 NFT를 **채굴**하는 과정을 완료하는 방법을 안내해드리겠습니다.

### 결제 링크 생성

NFT 채굴 프로세스가 올바르게 수행되고 사용자가 NFT를 올바르게 보관할 수 있도록 하기 위해서는 TON 블록체인과 톤키퍼 지갑과 동시에 상호 작용할 수 있는 결제 링크를 만들어야 합니다.

이 목표를 달성하기 위해 다양한 매개 변수를 사용하여 사용자 지정할 수 있는 `ton://transfer/<address>` 형식을 사용하여 결제 URL(결제 링크) 생성을 시작합니다. 이는 메시지를 생성하고 톤키퍼 지갑을 사용해 스마트 컨트랙트로 전송하고자 하기 때문에 완벽하게 작동합니다:

```ts title="ton-onboarding-challenge/index.ts"
import {toNano} from "ton"

// ... previous code

  console.log(' ');
  console.log("💣 WARNING! As soon as you find the hash, you should quickly send the transaction.");
  console.log("If someone else sends a transaction before you, the seed changes, and you'll have to find the hash again!");
  console.log(' ');

  // flags work only in user-friendly address form
  const collectionAddr = collection.toFriendly({
    urlSafe: true,
    bounceable: true,
  })
  // we must convert TON to nanoTON
  const amountToSend = toNano('0.05').toString()
 // BOC means Bag Of Cells here
  const preparedBodyCell = msg.toBoc().toString('base64url')

  // final method to build a payment URL
  const tonDeepLink = (address: string, amount: string, body: string) => {
    return `ton://transfer/${address}?amount=${amount}&bin=${body}`;
  };

  const link = tonDeepLink(collectionAddr, amountToSend, preparedBodyCell);

  console.log('🚀 Link to receive an NFT:')
  console.log(link);
```

위의 스크립트를 실행하여 새로 생성된 결제 링크를 실행해 보겠습니다. 이제 PC 스마트폰에서 실행 중인 결제 링크가 호환되도록 설정할 차례입니다. 시작해 보겠습니다.

### 스마트폰 호환 결제 링크 생성

이에 대한 해결책으로 세계에서 가장 뛰어난 인재들이 단말기에서 사용할 수 있는 QR코드 생성기를 만들었습니다. 이 도구를 사용하면 Tonkeeper 지갑에서 결제 링크를 스캔하기만 하면 거래를 전송할 수 있습니다.

```bash
npm install qrcode-terminal
```

마지막으로 결제 링크(`링크`)를 QR 코드에 인코딩하고 콘솔에서 인쇄해야 합니다. 이 작업은 아래 단계에 따라 완료됩니다:

```ts title="ton-onboarding-challenge/index.ts"
  const qrcode = require('qrcode-terminal');

  qrcode.generate(link, {small: true}, function (qrcode : any) {
    console.log('🚀 Link to mine your NFT (use Tonkeeper in testnet mode):')
    console.log(qrcode);
    console.log('* If QR is still too big, please run script from the terminal. (or make the font smaller)')
  });
```

'경험'이 느껴지시나요? 바로 여러분이 TVM 개발자가 되는 길에 있습니다.

이제 QR코드 생성기와 결제 링크를 성공적으로 인코딩했으니, 첫 번째 트랜잭션을 전송하기 위해 테스트넷 톤코인을 획득해야 합니다. 이를 위해 TON 블록체인의 TON [토큰 수도꼭지](https://coinmarketcap.com/alexandria/glossary/faucet)(테스트넷 톤코인을 공유하는 텔레그램 봇)를 사용하여 우리가 만든 톤키퍼 지갑으로 보낼 수 있는 일부 토큰을 보유하고 있습니다.

## 지갑으로 NFT 채굴하기

TON에서 NFT를 채굴하는 방법은 크게 두 가지입니다:

- [간편: NFT 테스트넷 채굴](/개발/시작하기-톤#간단한-테스트넷-채굴)
- [정품: NFT 메인넷 채굴](/개발/시작하기-톤#정품-메인넷-채굴)

### 간단합니다: NFT 테스트넷 채굴

다음은 NFT 채굴을 위한 첫 테스트넷 트랜잭션을 시작하는 데 필요한 단계입니다:

1. 톤키퍼 지갑 내 테스트넷 모드 활성화](/참여하기/지갑/앱#톤키퍼-테스트환경)
2. 톤키퍼의 테스트넷 지갑 주소를 `index.ts`의 `wallet` 변수에 입력합니다.
3. 테스트넷의 NFT 컬렉션](https://testnet.getgems.io/collection/EQDk8N7xM5D669LC2YACrseBJtDyFqwtSPCNhRWXU7kjEptX)의 주소를 `index.ts`의 `collection` 변수에 입력합니다.

#### 토큰 수도꼭지를 통한 지갑 잔액 충전

다음 단계로 진행하려면 TON 테스트넷 토큰을 획득해야 합니다. 이는 테스트넷 [수도꼭지](https://t.me/testgiver_ton_bot)를 사용하여 달성할 수 있습니다.

#### 테스트넷 NFT 로켓 채굴

테스트넷에서 NFT 로켓을 성공적으로 채굴하려면 다음 단계를 따라야 합니다:

1. 열기\_ 휴대폰에서 톤키퍼 지갑을 엽니다(새로 받은 톤 테스트넷 토큰이 보관되어 있어야 합니다).
2. 지갑에서 스캔 모드를 _선택_하여 QR 코드를 스캔합니다.
3. 채굴기를 _실행_하여 올바른 해시를 얻습니다(이 과정은 30초에서 60초 정도 소요됩니다).
4. 채굴기에서 생성된 QR 코드를 스캔합니다.

:::tip 마지막 팁
다른 개발자가 자신의 NFT를 채굴하기 위해 동일한 프로세스를 수행할 수 있으므로, 성공하려면 몇 번 시도해야 할 수도 있습니다(다른 사용자가 여러분보다 먼저 다음 NFT를 채굴할 수 있기 때문입니다).
:::

이 과정을 시작하고 얼마 지나지 않아 TON에서 첫 번째 NFT를 성공적으로 채굴하게 될 것입니다(톤키퍼 지갑에 표시되어야 합니다).

![](/img/tutorials/onboarding/8.svg)

진정한 TVM 개발자가 된 것을 환영합니다! 당신이 해냈어요. 🛳

### 정품: NFT 메인넷 채굴

안녕하세요! TON 메인넷에서 NFT를 채굴하고자 하는 분들은 다음 지침을 따라야 합니다:

1. 톤키퍼에서 _메인넷_ 모드를 활성화했습니다(최소 0.1톤을 보유해야 함).
2. 톤키퍼의 _메인넷_ 지갑 주소를 `index.ts`의 `wallet` 변수에 입력합니다.
3. 메인넷의 NFT 컬렉션](https://getgems.io/collection/EQDk8N7xM5D669LC2YACrseBJtDyFqwtSPCNhRWXU7kjEptX)의 주소를 `index.ts`의 `collection` 변수에 입력합니다.
4. **endpoint** 를 _Mainnet_으로 바꾸고, _getHttpEndpoint_에서 테스트넷 인수를 제외하고 활성화하는 오브스 액세스의 경우 _Mainnet_으로 바꿉니다:

```ts title="ton-onboarding-challenge/index.ts"
// get the decentralized RPC endpoint in Mainnet
const endpoint = await getHttpEndpoint();
```

#### 메인넷 NFT 로켓 채굴

테스트넷 NFT 로켓 채굴 프로세스에서 설명한 것처럼, 메인넷에서 NFT 로켓을 성공적으로 채굴하기 위해서는 다음 단계를 따라야 합니다:

1. 휴대폰에서 톤키퍼 지갑을 _열어야_ 합니다(TON 토큰이 들어 있어야 한다는 점을 기억하세요).
2. 지갑에서 스캔 모드를 _선택_하여 QR 코드를 스캔합니다.
3. 채굴기를 _실행_하여 올바른 해시를 얻습니다(이 과정은 30초에서 60초 정도 소요됩니다).
4. 채굴기에서 생성된 QR 코드를 스캔합니다.

:::tip 마지막 팁
다른 개발자가 자신의 NFT를 채굴하기 위해 동일한 프로세스를 수행할 수 있으므로, 성공하려면 몇 번 시도해야 할 수도 있습니다(다른 사용자가 여러분보다 먼저 다음 NFT를 채굴할 수 있기 때문입니다).
:::

얼마 후, 여러분은 NFT를 **채굴**하고 TON 블록체인의 TVM 개발자가 될 것입니다. 의식이 완료되었습니다. 톤키퍼에서 NFT를 확인하세요.

```mdx-code-block
<div style={{ width: '100%', textAlign: 'center', margin: '0 auto' }}>
  <video width={'300'} style={{ width: '100%', borderRadius: '10pt', margin: '15pt auto' }} muted={true} autoPlay={true} loop={true}>
    <source src="/files/onboarding-nft.mp4" type="video/mp4" />
```

브라우저가 동영상 태그를 지원하지 않습니다.

```mdx-code-block
  </video>
</div>
```

TVM 개발자가 된 것을 환영합니다! 당신이 해냈어요. 🛳

## 🧙 다음 단계는 무엇인가요?

\_먼저, 잠시 쉬세요! 큰 일을 하셨군요! 이제 당신은 TVM 개발자입니다. 하지만 긴 여정의 시작일 뿐입니다.

## 참고 항목

NFT를 성공적으로 채굴한 TON 온보딩 챌린지를 마친 후, TON 생태계의 다양한 부분을 자세히 설명하는 자료를 살펴보시기 바랍니다:

- [블록체인이란 무엇인가요? 스마트 컨트랙트란 무엇인가요? 가스란 무엇인가요?](https://blog.ton.org/what-is-blockchain)
- [톤 헬로 월드: 첫 스마트 컨트랙트 작성을 위한 단계별 가이드](https://ton-community.github.io/tutorials/02-contract/)
- [스마트 컨트랙트 개발: 소개](/개발/스마트 컨트랙트/)
- [\[유튜브\] 톤 개발 스터디 - 펀씨와 블루프린트](https://www.youtube.com/playlist?list=PLyDBPwv9EPsDjIMAF3XqNI2XGNwdcB3sg)
- [지갑 스마트 컨트랙트 작업 방법](/개발/스마트 컨트랙트/자습서/월렛)
- [펀씨 여정: 1부](https://blog.ton.org/func-journey)
- [만두 판매용 봇](/개발/앱/튜토리얼/수락-결제-인-텔레그램-봇-js)
- [첫 제톤 채굴하기](/개발/앱/튜토리얼/제톤 채굴기)
- [단계별 NFT 컬렉션 채굴](/개발/앱/튜토리얼/컬렉션 채굴)
- [톤 사이트 실행 방법](/개발/앱/자습서/how-to-run-ton-site)

:::info 피드백이 있으신가요?
여러분은 이곳의 첫 번째 탐험가 중 한 명입니다. 실수를 발견하거나 불편한 점이 있으면 [@SwiftAdviser](https://t.me/SwiftAdviser)로 피드백을 보내주세요. 최대한 빨리 수정하겠습니다! :)
:::
