# Руководство Airdrop Claiming

В этой статье мы рассмотрим вымышленное _решение_ для клейма, попытаемся выявить его проблемы с производительностью и решить их.
Мы сосредоточимся на взаимодействии контрактов и их влиянии на общую производительность и не будем затрагивать код, аспекты безопасности и другие нюансы.

## Claim Machine

:::info
Как работает практически любое решение для клейма?
Давайте подумаем.
:::

Пользователь отправляет некое доказательство, пруф того, что он имеет право на клейм. Разработанный алгоритм решения осуществляет проверку доказательства и при ее успешности отправляет жетоны.
В данном случае `доказательство` подразумевает тип [merkle proof](/v3/documentation/data-formats/tlb/exotic-cells#доказательство-меркла), но это вполне могут быть просто подписанные данные или любой другой метод авторизации.
Отправка жетонов осуществляется с помощью Jetton wallet и Jetton minter.
Также, мы должны убедиться, что хитрые пользователи не смогут клеймить дважды – для этого необходим контракт с защитой от двойного списания.
И мы, к тому же, хотим заработать немного денег, не так ли? Значит потребуется, по меньшей мере, один кошелек для клейма.
Подведем итог:

### Дистрибьютор

Принимает доказательство от пользователя, проверяет его, выпускает жетоны.
State init: `(merkle_root, admin, fee_wallet_address)`.

### Двойное списание

Получает сообщение, возвращает в случае использования, в противном случае передает сообщение дальше.

### Jetton wallet

Jetton wallet, с которого токены будут отправлены _дистрибьютором_.
Jetton minter выходит за рамки этой статьи.

### Кошелек для комиссии

Любой тип контракта кошелька.

## Архитектура

### V1

Первая структура, которая приходит на ум, что-то вроде этого:

- Пользователь отправляет доказательство дистрибьютору
- Дистрибьютор проверяет доказательство и разворачивает смарт-контракт `двойной траты`
- Дистрибьютор передает сообщение контракту двойной траты
- Контракт двойной траты отправляет `claim_ok` дистрибьютору, если он не был развернут ранее
- Дистрибьютор отправляет комиссию за клейм на кошелек для оплаты комиссии
- Дистрибьютор отпускает жетоны пользователю



Что здесь не так? Похоже, что цикл избыточен.

### V2

Линейная структура намного лучше:

- Пользователь разворачивает контракт `двойной траты`, который в свою очередь передает доказательство дистрибьютору
- Дистрибьютор проверяет адрес отправки смарт-контракта `двойной траты` по state init `(distributor_address, user_address?)`
- Дистрибьютор проверяет доказательство, в данном случае индекс пользователя должен быть частью доказательства, и выпускает жетоны
- Дистрибьютор отправляет комиссию на кошелек для оплаты комиссии

## Оптимизация шардов

Хорошо, у нас что-то получается, но что насчет оптимизации шардов?

### Что это такое?

Для того чтобы получить базовое представление, рекомендуется ознакомиться со статьей [Создание кошелька для разных шардов](/v3/guidelines/dapps/asset-processing/payments-processing/#создание-кошелька-для-разных-шардов).
Вкратце, шард – это четырехбитный префикс адреса контракта. Как в сетевых технологиях.
Когда контракт находится в одном сегменте сети, сообщения обрабатываются без маршрутизации, а значит гораздо быстрее.

### Идентификация адресов, которые мы можем контролировать

#### Адрес дистрибьютора

Мы полностью контролируем данные дистрибьютора, поэтому должны иметь возможность поместить их в любой шард.
Как это сделать?
Помните, что адрес смарт-контракта [определяется его состоянием](/v3/documentation/smart-contracts/addresses#идентификатор-аккаунта).
Нужно использовать некоторые поля данных контракта в качестве nonce и продолжать попытки до тех пор, пока не получим желаемый результат.
Примером хорошего nonce в реальных контрактах может быть (subwalletId/publicKey) для смарт-контракта кошелька.
Любое поле, которое можно изменить после развертывания или которое не влияет на логику контракта (как subwalletId), подойдет для этого.
Можно даже создать неиспользуемое поле специально для этой цели, как это делает [vanity-contract](https://github.com/ton-community/vanity-contract).

#### Адрес Jetton wallet

Мы не можем контролировать адрес полученного jetton wallet напрямую.
Однако, если мы контролируем адрес дистрибьютора, то можем подобрать его таким образом, чтобы jetton wallet для дистрибьютора оказался в том же шарде.
Но как это сделать? Для этого существует [lib](https://github.com/Trinketer22/turbo-wallet)!
В настоящее время она поддерживает только кошельки, но добавить поддержку произвольных контрактов достаточно просто.
Посмотрите, как это сделано для [Highload-кошелька V3](https://github.com/Trinketer22/turbo-wallet/blob/44fe7ee4300e37e052871275be8dd41035d45c3a/src/lib/contracts/HighloadWalletV3.ts#L20).

### Смарт-контракт двойная трата

Контракт двойной траты должен быть уникальным для каждого доказательства, сможем ли мы настроить его на шарде? Если подумать, то это зависит от структуры доказательства. Первое, что приходит на ум, это та же структура, что и у [mintless jetton](https://github.com/tonkeeper/TEPs2/blob/mintles/text/0177-mintless-jetton-standard.md#handlers):

```
_ amount:Coins start_from:uint48 expired_at:uint48 = AirdropItem;

_ _(HashMap 267 AirdropItem) = Airdrop;

```

В этом случае его нельзя настроить потому, что распределение адресов происходит случайным образом, а все поля имеют значимые данные.
Но ничто не мешает нам просто сделать это:

```
_ amount:Coins start_from:uint48 expired_at:uint48 nonce:uint64 = AirdropItem;

_ _(HashMap 267 AirdropItem) = Airdrop;
```

или даже:

```
_ amount:Coins start_from:uint48 expired_at:uint48 addr_hash: uint256 = AirdropItem;

_ _(HashMap 64 AirdropItem) = Airdrop;

```

где 64-битный индекс может быть использован в качестве nonce, а адрес становится частью данных для верификации.
Таким образом, если данные смарт-контракта двойной траты строятся из `(distributor_address, index)`, где индекс является частью данных, мы по-прежнему имеем исходную надежность, но теперь шард адреса настраивается с помощью параметра index.

#### Адрес пользователя

Очевидно, что мы не контролируем адреса пользователей, не так ли?
Да, **НО** мы можем сгруппировать их таким образом, чтобы шард пользовательских адресов совпадал с шардом дистрибьюторов.
В таком случае каждый дистрибьютор будет обрабатывать _merkle root_, состоящий исключительно из пользователей его шарда.

#### Резюме

Мы можем поместить `double_spend -> dist -> dist_jetton` часть цепочки в один шард.
Для других шардов останется только `dist_jetton -> user_jetton -> user_wallet`.

### Как развернуть такую установку

Одно из требований заключается в том, чтобы контракт _дистрибьютора_ имел обновляемый _merkle root_. Давайте выполним по шагам:

- Разверните смарт-контракт дистрибьютора в каждом шарде (0-15) – в пределах тех же шардов, что и их jetton wallet, используя начальный `merkle_root` в качестве nonce
- Сгруппируйте пользователей по шардам
- Для каждого пользователя найдите такой индекс, чтобы контракт _двойная трата_ `(distributor, index)` оказался в том же шарде, что и адрес пользователя
- Сгенерируйте _merkle roots_ с индексами из шага выше
- Обновите _дистрибьюторов_ в соответствии с _merkle roots_

Теперь все должно быть в порядке!

### V3

- Пользователь разворачивает контракт _двойная трата_ в одном шарде, используя настройку индекса
- Дистрибьютор в шарде пользователя проверяет адрес отправки `двойной траты` по state init `(distributor_address, index)`
- Дистрибьютор отправляет комиссию на кошелек для оплаты комиссии
- Дистрибьютор проверяет доказательство, в данном случае индекс пользователя должен быть частью доказательства, и выпускает джеттоны через jetton wallet на том же шарде

Что плохого в данной  структуре? Давайте посмотрим внимательно. Правильно! Существует только один кошелек для комиссии, таким образом сборы выстраиваются в очередь в  одном шарде. Это могло бы стать катастрофой! (Интересно, случалось ли такое в реальности?)

### V4

- То же самое, что и в V3, но теперь 16 кошельков для получения комиссии, каждый из которых находится в том же шарде, что и его _дистрибьютор_
- Придется сделать адрес _кошелька для комиссии_ обновляемым.

**Немного искусства**.

Как вам теперь? Выглядит хорошо.

## Что дальше?

Мы всегда можем пойти еще дальше.
Ознакомьтесь с кастомным смарт-контрактом [jetton wallet](https://github.com/ton-community/mintless-jetton/blob/main/contracts/jetton-utils.fc#L142), который имеет встроенную оптимизацию шардов.
В результате пользовательский jetton wallet оказывается на том же шарде, что и пользователь, с вероятностью 87%.
Но это еще довольно-таки неизведанная территория, так что вам придется действовать самостоятельно.
Удачи с TGE!
