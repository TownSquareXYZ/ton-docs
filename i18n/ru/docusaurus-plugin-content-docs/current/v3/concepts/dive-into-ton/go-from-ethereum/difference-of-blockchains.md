# Различия блокчейнов

В этом разделе мы рассмотрим основные различия между блокчейном Ethereum и блокчейном TON. Анализ будет включать обзор сетевых архитектур, описывать их уникальные особенности и оценивать преимущества и недостатки каждого из них.

Начиная с обзора экосистем Ethereum и TON, стоит отметить, что обе платформы предлагают схожую структуру участников и услуг. Структура включает в себя: пользователей, которые совершают транзакции и имеют в наличии активы, валидаторов, которые поддерживают работу и безопасность сети, а также разработчиков приложений, использующих блокчейн как основу для своих продуктов и услуг. Оба экосистемы включают в себя кастодиальные, и некастодиальные сервисы, предоставляющие пользователям различные уровни контроля над их активами.

Более того, стоит отметить, что обе платформы поддерживают создание децентрализованных приложений (DApps), предоставляя разработчикам мощные инструменты и стандарты для разработки.

Однако, несмотря на сходства в общей структуре и предлагаемых функциях, ключевые технологические аспекты и подходы к проектированию сети Ethereum и TON существенно различаются.Эти различия формируют основу для более глубокого понимания уникальных преимуществ, а также и ограничений каждой платформы, что в свою очередь особенно важно для разработчиков, стремящихся максимизировать возможности каждой сети.В следующих подразделах мы подробно изучим эти различия, сосредоточившись на архитектуре сети, моделях, механизмах транзакций и системе расчетов транзакций, что предоставит разработчикам необходимую основу для начала разработки.

## Архитектура блокчейна

Ethereum, наследуя и расширяя фундаментальные принципы Bitcoin, предоставляет разработчикам гибкость, необходимую для создания сложных децентрализованных приложений, DApps. Особенностью Ethereum является его способность предоставлять каждому счету индивидуальное хранилище данных, что позволяет через транзакции не только выполнять переводы токенов, но и изменять состояние блокчейна, взаимодействуя со смарт-контрактами.Эта способность синхронно взаимодействовать между счетами, как мы знаем, имеет большое значение для разработки приложений, однако в свою очередь также вызывает вопрос о масштабируемости. Каждая транзакция на сети Ethereum требует от узлов обновлять и поддерживать полное состояние блокчейна, что приводит к значительной задержке и увеличивает стоимость газа при росте сети.

В ответ на эти вызовы, TON предлагает альтернативный подход, направленный на улучшение масштабируемости и производительности. Будучи разработанным с целью предоставить разработчикам максимальную гибкость при создании различных приложений, TON использует концепцию шардов и мастерчейна для оптимизации процесса создания блоков.В каждом TON шардчейне и мастерчейне создается новый блок примерно каждые 5 секунд, обеспечивая более быстрое выполнение транзакций. В отличие от Ethereum, где обновления состояния синхронны, TON реализует асинхронное взаимодействие между смарт-контрактами, позволяя каждую транзакцию обрабатывать независимо и параллельно, что значительно ускоряет обработку транзакций в сети.Разделы и статьи для ознакомления:

- [Шарды](/v3/documentation/smart-contracts/shards/shards-intro)
- [Документ "Сравнение блокчейнов"](https://ton.org/comparison_of_blockchains.pdf)
- [Таблица сравнения блокчейнов (гораздо менее информативная, чем документ, но более наглядная)](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-comparison)

В заключение, сравнивая архитектуру и технологические основы TON и Ethereum, становится ясно, что TON предлагает значительные преимущества. Используя инновационный подход к обработке асинхронных транзакций и уникальную архитектуру шардов и мастерчейна, TON демонстрирует потенциал для поддержки миллионов транзакций в секунду без наличия компромиссов по безопасности или централизации. Это обеспечивает платформе выдающуюся гибкость и эффективность, что делает ее идеальным выбором для широкого спектра приложений.

## Модель счетов (Ethereum) и Акторная модель (TON)

В первом подразделе мы сравнили Ethereum и TON, описав их ключевые архитектурные различия и основные вызовы, с которыми сталкивается Ethereum.Особого внимания заслуживают различия блокчейнов в рамках подходов к организации взаимодействий и использованию моделей. Эти различия возникают из-за уникальности архитектуры каждой из платформ. Разработчикам привыкшим к Ethereum важно понять эти различия, чтобы эффективно перейти на разработку в TON. Это понимание позволит адаптировать архитектуру и оптимизировать взаимодействие смарт-контрактов в новом окружении.

Давайте вспомним как работает модель счетов в Ethereum. Ethereum использует эту модель для отслеживания балансов. Как и в случае с банковской картой, доступные средства хранятся на счетах, а не отдельными монетами. Существуют два типа счетов:

- Externally-owned accounts (EOAs) – внешние управляемые счета, управляются пользователем с помощью публичных и приватных ключей. Публичный ключ позволяет другим отправлять платежи на этот счет.
- Contract Accounts — это счета, управляемые кодом смарт-контракта, а не приватными ключами. Поскольку у них нет приватного ключа, счета-контракты самостоятельно не могут инициировать транзакции.

Когда пользователь Ethereum создает кошелек, внешний счет добавляется в глобальное состояние на всех узлах децентрализованной сети при проведении первой транзакции или получении средств. Развертывание умного контракта создает счет-контракт, способный хранить и распределять средства программно в зависимости от определенных условий. Все типы счетов имеют балансы, личное хранилище и могут инициировать транзакции, вызывая функции в других счетах. Подобная структура позволяет Ethereum по сути быть программируемой валютой.

В Ethereum реализована синхронная обработка транзакций, где каждая транзакция обрабатывается по очереди, в строгом порядке. Это обеспечивает то, что состояние блокчейна всегда остается консистентным и предсказуемым для всех участников сети.Все транзакции атомарны – либо они полностью успешно завершаются, либо не выполняются вовсе, без какого-либо частичного или неполного выполнения. Более того, когда вызывается смарт-контракт, который затем вызывает другой смарт-контракт, вызов происходит мгновенно в рамках одной транзакции.Однако здесь также есть недостатки: транзакция в таком подходе может вырасти до максимальной допустимой величины. Основной минус синхронности — это перегрузка из-за того, что вычисления не могут выполняться параллельно. Число контрактов и пользователей будет расти, и невозможность параллелизации вычислений станет основным ограничивающим фактором для роста сети.

Теперь давайте разберем, что такое Акторная модель? Акторная моель - это метод параллельной и распределенной обработки, где основным элементом является Актор — независимый исполняемый блок кода. Оригинально разработана для кластерного вычисления, эта модель широко используется в микросерверных архитектурах из-за её способности масштабироваться, обеспечивать параллелизм и надежность при работе с современными распределенными системами. Акторы принимают и обрабатывают сообщения, отвечая на основе логики сообщений либо применив локальные изменения, либо выполняя действия при запросе, создавая других акторов или отправляя сообщения дальше. Они являются потокобезопасными и рекурсивно вызываемыми, что позволяет избежать блокировок и упрощает параллельную обработку задач. Эта модель идеальна для построения масштабируемых и надежных серверных решений, предоставляя эффективный контроль одновременного доступа и поддерживая как синхронные, так и асинхронные сообщения.

В TON все представлено в виде умных контрактов, которые также могут называться акторами в контексте акторной модели. Умный контракт является объектом с такими свойствами, как адрес, код, данные и баланс. Он способен хранить данные и действовать в соответствии с инструкциями, полученными от других умных контрактов. После того как контракт получает сообщение и обрабатывает его, выполняя свой код в TVM, могут возникнуть различные сценарии:

- Контракт изменяет свои свойства `code, data, balance`
- Контракт опционально генерирует исходящие сообщения
- Контракт переходит в режим ожидания до тех пор, пока не произойдет следующее событие

Результат скриптов всегда является созданием транзакции. Сами же транзакции асинхронны, что означает, что система может продолжать обрабатывать другие транзакции, не дожидаясь завершения прошедших транзакций. Это обеспечивает большую гибкость при обработке сложных операций. Иногда для одной транзакции требуется выполнение нескольких вызовов умных контрактов в определенной последовательности. Поскольку эти вызовы асинхронны, разработчики могут легче проектировать и реализовывать сложные потоки транзакций, которые могут включать несколько параллельных операций. Разработчик, переходящий с Ethereum, должен учесть, что умные контракты в блокчейне TON могут обмениваться данными только асинхронным образом, что означает, что если требуется запросить данные из другого контракта и необходим немедленный ответ, это невозможно. Вместо этого get методы должны вызываться клиентами снаружи сети, подобно тому как в Ethereum кошельки используют узлы RPC, такие как Infura, чтобы запросить состояния умных контрактов. Это важное ограничение по нескольким причинам. Например, flash loans — это транзакции, которые должны быть выполнены в одном блоке, опираясь на возможность заема и возврата в рамках одной транзакции. Это упрощено при синхронной природе EVM Ethereum, но в TON асинхронность всех транзакций делает выполнени flash loan невозможным. Также Оракулы, которые предоставляют умным контрактам внешние данные, имеют более сложный процесс проектирования в TON. Что такое Оракулы и как их использовать в TON можно найти [здесь](/v3/documentation/dapps/oracles/about_blockchain_oracles).

## Отличия кошельков

Мы уже обсуждали, что в Ethereum кошелек пользователя генерируется на основе его адреса, который находится в отношении 1 к 1 с его открытым ключом. Но в TON все кошельки являются смарт-контрактами, которые должен развернуть сам пользователь. Поскольку смарт-контракты можно настраивать по-разному и иметь разные функции, существует несколько версий кошельков, о которых вы можете прочитать [здесь](/v3/documentation/smart-contracts/contracts-specs/wallet-contracts). В связи с тем, что кошельки являются смарт-контрактами, у пользователя может быть несколько кошельков с разными адресами и начальными параметрами. Чтобы отправить транзакцию, пользователь должен подписать сообщение своим закрытым ключом и отправить его в свой контракт кошелька, который, в свою очередь, пересылает его в смарт-контракт конкретного приложения DApp. Такой подход значительно повышает гибкость в дизайне кошелька, и разработчики могут добавлять новые версии кошелька в будущем. В Ethereum на данный момент разработчики активно используют мультиподписные кошельки (смарт-контракты) типа gnosis и только начинают внедрять так называемые \\`account-abstractions' типа ERC-4337, где кошельки наполнены таким функционалом, как отправка транзакций без собственного токена, восстановление аккаунта после его потери и т. д., но стоит отметить, что аккаунты кошельков гораздо дороже в использовании с точки зрения комиссий за газ по сравнению с EOA в Ethereum.

## Сообщения и транзакции

Что происходит между двумя контрактами называется сообщением — это небольшое количество токенов и произвольные данные отправляются на указанный адрес. Когда сообщение достигает контракта, оно обрабатывается кодом контракта, состояние контракта обновляется, и он опционально отправляет новое сообщение. Все эти действия в контракте записываются как транзакции. Давайте представим пример: у нас есть цепочка сообщений от контракта `A` к контракту `B`, а затем от контракта `B` к контракту `C`. В этом случае у нас будет два сообщения и три транзакции. Однако изначально, чтобы изменить состояние блокчейна, требуется внешний сигнал. Чтобы вызвать умный контракт, необходимо отправить внешнее сообщение, которое идет к валидаторам и они применяют его к умному контракту. Мы уже обсуждали в последнем подразделе, что кошелек является умным контрактом, поэтому это внешнее сообщение обычно сначала отправляется в умный контракт кошелька, который его записывает как первую транзакцию, и эта первая транзакция обычно содержит внутреннее сообщение для целевого контракта. Когда умный контракт кошелка получает это сообщение, он обрабатывает его и передает его целевому контракту (в нашем примере контракт `A` может быть кошельком, и когда он получает внешнее сообщение, у него будет первая транзакция). Последовательность транзакций образует цепочку. Таким образом, вы можете видеть, что каждый умный контракт имеет свои собственные транзакции, что означает, что каждый контракт имеет свою собственный микро-блокчейн (вы можете узнать больше об этом [здесь](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains)), поэтому сеть может обрабатывать транзакции в полной независимости друг от друга.

## Отличия в системе газа

В Ethereum стоимость транзакции измеряется в `газе`, что отражает количество вычислительных ресурсов, требуемых для выполнения транзакции. Стоимость газа делится на `базовую плату`, установленную протоколом, и `приоритетную плату`, которую пользователь добавляет, чтобы ускорить обработку транзакций валидаторами. `Общая стоимость` будет равна = `использованным единицам газа` \* (`базовая плата` + `приоритетная плата`).
Кроме того, хранение данных на Ethereum по сути бесплатное, что означает, что после того, как данные были сохранены в блокчейне, больше не возникает затрат на их содержание.

В TON расчеты за транзакционные сборы сложны и включают несколько типов сборов: за хранение умных контрактов в блокчейне, за импорт сообщений в блокчейн, за выполнение кода на виртуальной машине, за обработку действий после выполнения кода и за отправку сообщений вне сети TON. Цена газа и некоторые другие параметры могут изменяться путем голосования на основной сети. В отличие от Ethereum TON пользователи не могут самостоятельно устанавливать цену газа. Также разработчику необходимо вручную вернуть оставшиеся средства газа владельцу, иначе они останутся заблокированы. Использование хранилища умных контрактов также влияет на стоимость: если умный контракт кошелька не использовался долго, следующая транзакция будет стоить дороже.
