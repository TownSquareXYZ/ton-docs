# Блокчейн блокчейнов

:::tip
Термины **смарт-контракт**, **аккаунт** и **актор** используются взаимозаменяемо в этом документе для описания сущности блокчейна.
:::

## Отдельный актор

Рассмотрим один смарт-контракт.

В TON это вещь со свойствами, такими как `address`, `code`, `data`, `balance` и другие. Другими словами, это объект, который имеет некоторое хранилище и поведение. Это поведение имеет следующий шаблон:

- что-то происходит (наиболее распространенная ситуация — контракт получает сообщение)
- контракт обрабатывает это событие в соответствии со своими собственными свойствами, выполняя свой `код` в виртуальной машине TON.
- контракт изменяет свои собственные свойства (`код`, `данные` и другие)
- контракт опционально генерирует исходящие сообщения
- контракт переходит в режим ожидания, пока не произойдет следующее событие

Комбинация этих шагов называется \*\*транзакцией--. Важно, чтобы события обрабатывались одно за другим, поэтому *транзакции* строго упорядочены и не могут прерывать друг друга.

Эта модель поведения хорошо известна и называется `Актор`.

### Самый низкий уровень: Цепочка аккаунтов

Последовательность *транзакций* `Tx1 -> Tx2 -> Tx3 -> ....` можно назвать **цепочкой**. А в рассматриваемом случае она называется `AccountChain`, чтобы подчеркнуть, что это *цепочка* транзакций одного аккаунта.

Теперь, поскольку узлы, обрабатывающие транзакции, время от времени должны координировать состояние смарт-контракта (достигать *консенсуса* о состоянии), эти *транзакции* пакетируются: `[Tx1 -> Tx2] -> [Tx3 -> Tx4 -> Tx5] -> [] -> [Tx6]`. Пакетирование не вмешивается в последовательность, каждая транзакция по-прежнему имеет только одну `prev tx` и максимум одну `next tx`, но теперь эта последовательность разбивается на **блоки**.

Также целесообразно включать очереди входящих и исходящих сообщений в *блоки*. В этом случае *блок* будет содержать полный набор информации, которая определяет и описывает, что произошло со смарт-контрактом во время этого блока.

## Множество AccountChains: Шарды

Теперь давайте рассмотрим множество аккаунтов. Мы можем получить несколько *AccountChains* и хранить их вместе, такой набор *AccountChains* называется *Шардчейн*. Таким же образом мы можем разбить **Шардчейн** на **Шардблоки**, которые являются совокупностью отдельных *AccountBlocks*.

### Плавное разделение и объединение шардчейнов

Обратите внимание, что поскольку *Шардчейн* состоит из легко различимых *AccountChains*, мы можем легко разделить его. Таким образом, если у нас есть 1 *Шардчейн*, который описывает события, происходящие с 1 миллионом аккаунтов, и в секунду происходит слишком много транзакций для обработки и хранения в одном узле, мы просто делим (или **разделяем**) эту цепочку на два меньших *Шардчейна*, при этом каждая цепочка учитывает полмиллиона аккаунтов, и каждая цепочка обрабатывается на отдельном подмножестве узлов.

Аналогично, если некоторые шарды стали слишком свободными, их можно **объединить** в один более крупный шард.

Очевидно, есть два предельных случая: когда шард содержит только одну учетную запись (и, следовательно, не может быть разделен дальше) и когда шард содержит все учетные записи.

Учетные записи могут взаимодействовать друг с другом, отправляя сообщения. Существует специальный механизм маршрутизации, который перемещает сообщения из исходящих очередей в соответствующие входящие очереди и гарантирует, что 1) все сообщения будут доставлены 2) сообщения будут доставлены последовательно (сообщение, отправленное раньше, достигнет получателя раньше).

:::info ПРИМЕЧАНИЕ
Чтобы сделать разделение и слияние детерминированными, агрегация AccountChains в шарды основана на битовом представлении адресов учетных записей. Например, адрес выглядит как `(shard prefix, address)`. Таким образом, все учетные записи в шардчейне будут иметь точно такой же двоичный префикс (например, все адреса будут начинаться с `0b00101`).
:::

## Блокчейн

Совокупность всех шардов, которая содержит все учетные записи, ведущие себя по одному набору правил, называется **Блокчейном**.

В TON может быть много наборов правил и, следовательно, много блокчейнов, которые работают одновременно и могут взаимодействовать друг с другом, отправляя сообщения через цепочку таким же образом, как учетные записи одной цепочки могут взаимодействовать друг с другом.

### Воркчейн: Блокчейн с вашими собственными правилами

Если вы хотите настроить правила группы Шардчейнов, вы можете создать **Воркчейн**. Хорошим примером является создание воркчейна, работающего на базе EVM, для запуска на нем смарт-контрактов Solidity.

Теоретически, каждый в сообществе может создать собственный воркчейн. На самом деле, довольно сложно создать его, затем заплатить (дорогую) цену за его создание и получить 2/3 голосов от валидаторов для одобрения создания вашего Воркчейна.

TON позволяет создавать до `2^32` воркчейнов, каждый из которых подразделяется на `2^60` шардов.

В настоящее время в TON есть только 2 воркчейна: Мастерчейн и Бейсчейн.

Бейсчейн используется для повседневных транзакций между участниками, потому что он довольно дешев, в то время как Мастерчейн имеет важнейшую функцию для TON, поэтому давайте рассмотрим, что он делает!

### Мастерчейн: Блокчейн блокчейнов

Необходимо синхронизировать маршрутизацию сообщений и выполнение транзакций. Другими словами, узлам в сети нужен способ зафиксировать некоторую `точку` в состоянии мультичейна и достичь консенсуса относительно этого состояния. В TON для этой цели используется специальная цепочка, называемая **Мастерчейн**. Блоки *мстерчейна* содержат дополнительную информацию (последние хэши блоков) обо всех других цепочках в системе, таким образом, любой наблюдатель однозначно определяет состояние всех систем мультичейна в одном блоке мастерчейна.
