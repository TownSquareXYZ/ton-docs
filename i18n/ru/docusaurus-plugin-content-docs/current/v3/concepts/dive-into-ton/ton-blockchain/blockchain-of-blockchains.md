# Блокчейн блокчейнов

:::tip
Термины **смарт-контракт**, **аккаунт** и **актор** используются взаимозаменяемо в этом документе для описания сущности блокчейна.
:::

## Отдельный актор

Рассмотрим один смарт-контракт.

В TON это *вещь* со свойствами, такими как `address`, `code`, `data`, `balance` и другие. Другими словами, это объект, который имеет некоторое *хранилище* и *поведение*. Это поведение имеет следующий шаблон:

- что-то происходит (наиболее распространенная ситуация — контракт получает сообщение)
- контракт обрабатывает это событие в соответствии со своими собственными свойствами, выполняя свой `код` в виртуальной машине TON.
- контракт изменяет свои собственные свойства (`code`, `data` и другие)
- контракт опционально генерирует исходящие сообщения
- контракт переходит в режим ожидания, пока не произойдет следующее событие

Комбинация этих шагов называется \*\*транзакцией--. Важно, чтобы события обрабатывались одно за другим, поэтому *транзакции* строго упорядочены и не могут прерывать друг друга.

Эта модель поведения хорошо известна и называется `Актор`.

### Самый низкий уровень: AccountChain

Последовательность *транзакций* `Tx1 -> Tx2 -> Tx3 -> ....` можно назвать **цепочкой**. А в рассматриваемом случае она называется `AccountChain`, чтобы подчеркнуть, что это *цепочка* транзакций одного аккаунта.

Теперь, поскольку узлы, обрабатывающие транзакции, время от времени должны координировать состояние смарт-контракта (достигать *консенсуса* о состоянии), эти *транзакции* пакетируются: `[Tx1 -> Tx2] -> [Tx3 -> Tx4 -> Tx5] -> [] -> [Tx6]`. Пакетирование не вмешивается в последовательность, каждая транзакция по-прежнему имеет только одну `prev tx` и максимум одну `next tx`, но теперь эта последовательность разбивается на **блоки**.

Также целесообразно включать очереди входящих и исходящих сообщений в *блоки*. В этом случае *блок* будет содержать полный набор информации, которая определяет и описывает, что произошло со смарт-контрактом во время этого блока.

## Множество AccountChains: Шарды

Теперь давайте рассмотрим множество аккаунтов. Мы можем получить несколько *AccountChains* и хранить их вместе, такой набор *AccountChains* называется *Шардчейн*. Таким же образом мы можем разбить **Шардчейн** на **Шардблоки**, которые являются совокупностью отдельных *AccountBlocks*.

### Плавное разделение и объединение шардчейнов

Обратите внимание, что поскольку *Шардчейн* состоит из легко различимых *AccountChains*, мы можем легко разделить его. Таким образом, если у нас есть 1 *Шардчейн*, который описывает события, происходящие с 1 миллионом аккаунтов, и в секунду происходит слишком много транзакций для обработки и хранения в одном узле, мы просто делим (или **разделяем**) эту цепочку на два меньших *Шардчейна*, при этом каждая цепочка учитывает полмиллиона аккаунтов, и каждая цепочка обрабатывается на отдельном подмножестве узлов.

Аналогично, если некоторые шарды станут слишком свободными, их можно **объединить** в один более крупный шард.

Очевидно, есть два предельных случая: когда шард содержит только одну учетную запись (и, следовательно, не может быть разделен дальше) и когда шард содержит все учетные записи.

Учетные записи могут взаимодействовать друг с другом, отправляя сообщения. Существует специальный механизм маршрутизации, который перемещает сообщения из исходящих очередей в соответствующие входящие очереди и гарантирует, что 1) все сообщения будут доставлены 2) сообщения будут доставлены последовательно (сообщение, отправленное раньше, достигнет получателя раньше).

:::info ПРИМЕЧАНИЕ
Чтобы сделать разделение и слияние детерминированными, агрегация AccountChains в шарды основана на битовом представлении адресов аккаунтов. Например, адрес выглядит как `(shard prefix, address)`. Таким образом, все аккаунты в шарде будут иметь точно такой же двоичный префикс (например, все адреса будут начинаться с `0b00101`).
:::

## Блокчейн

Объединение всех шардов, содержащее все аккаунты, работающие по одному набору правил, называется **Блокчейном**.

В TON может быть много наборов правил и, следовательно, много блокчейнов, которые работают одновременно и могут взаимодействовать друг с другом, отправляя сообщения по всей цепочке таким же образом, как аккаунты одной цепочки могут взаимодействовать друг с другом.

### Воркчейн: Блокчейн с вашими собственными правилами

Если вы хотите настроить правила группы шардчейнов, вы можете создать **Воркчейн**. Хорошим примером является создание воркчейна, которая работает на базе EVM, чтобы запускать на нем смарт-контракты Solidity.

Теоретически, каждый в сообществе может создать собственный воркчейн. На самом деле, довольно сложно создать его, затем заплатить (дорогую) цену за его создание и получить 2/3 голосов от валидаторов для одобрения создания вашего Воркчейна.

TON позволяет создавать до `2^32` воркчейнов, каждый из которых подразделяется на `2^60` шардов.

В настоящее время в TON есть только два воркчейна: Мастерчейн и Бейсчейн.

Бейсчейн используется для повседневных транзакций между участниками, поскольку он довольно дешев, в то время как Мастерчейн выполняет важную функцию для TON.

### Мастерчейн: Блокчейн Блокчейнов

Существует необходимость в синхронизации маршрутизации сообщений и выполнения транзакций. Другими словами, узлам сети нужен способ зафиксировать некоторую "точку" в состоянии мультичейна и достичь консенсуса относительно этого состояния. В TON для этой цели используется специальная цепочка под названием **Мастерчейн**. Блоки *Мастерчейна* содержат дополнительную информацию (последние хэши блоков) обо всех других цепочках в системе, таким образом, любой наблюдатель однозначно определяет состояние всех систем мультичейна в одном блоке Мастерчейна.
