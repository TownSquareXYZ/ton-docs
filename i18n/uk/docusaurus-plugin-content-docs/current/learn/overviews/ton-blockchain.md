# Блокчейн з блокчейнів

:::tip
Терміни "**розумний контракт**", "**рахунок**" і "**актор**" використовуються в цьому документі як взаємозамінні для опису об'єкта блокчейну.
:::

## Один актор

Розглянемо один смарт-контракт.

У ТОН це *речовина* з такими властивостями, як *адреса*, *код*, *дані*, *баланс* та інші. Іншими словами, це об'єкт, який має певне *зберігання* та *поведінку*.
Ця поведінка має наступний шаблон:

- щось трапляється (найпоширеніша ситуація - коли контракт отримує повідомлення)
- контракт обробляє цю подію відповідно до своїх властивостей, виконуючи її "код" у віртуальній машині TON.
- контракт змінює власні властивості (`код`, `дані` та інші)
- контракт опціонально генерує вихідні повідомлення
- контракт переходить у режим очікування до наступної події

Комбінація цих кроків називається **транзакцією**. Важливо, що події обробляються одна за одною, тому *транзакції* суворо впорядковані і не можуть переривати одна одну.

Ця модель поведінки добре відома і називається "актор".

### Найнижчий рівень: Ланцюжок рахунків

Послідовність *транзакцій* `Tx1 -> Tx2 -> Tx3 -> ....` можна назвати **ланцюжком**. А в розглянутому випадку вона називається **AccountChain**, щоб підкреслити, що це *ланцюжок* одного облікового запису транзакцій.

Тепер, оскільки вузлам, які обробляють транзакції, потрібно час від часу координувати стан смарт-контракту (досягати *консенсусу* щодо стану), ці *транзакції* пакетуються:
`[Tx1 -> Tx2] -> [Tx3 -> Tx4 -> Tx5] -> [] -> [Tx6]`.
Пакетна передача не втручається у послідовність, кожна транзакція все ще має лише один 'prev tx' і максимум один 'next tx', але тепер ця послідовність розрізана на **блоки**.

Доцільно також включити до *блоків* черги вхідних та вихідних повідомлень. В такому випадку *блок* буде містити повний набір інформації, яка визначає і описує, що відбувалося зі смарт-контрактом протягом цього блоку.

## Багато ланцюжків акаунтів: Осколки

Тепер розглянемо багато акаунтів. Ми можемо отримати декілька *AccountChains* і зберігати їх разом, такий набір *AccountChains* називається **ShardChain**. Так само ми можемо розрізати **ShardChain** на **ShardBlocks**, які є сукупністю окремих *AccountBlocks*.

### Динамічне розділення та злиття ShardChains

Зауважте, що оскільки *ShardChain* складається з *AccountChains*, які легко розрізнити, ми можемо легко його розділити. Таким чином, якщо у нас є 1 *ShardChain*, який описує події, що відбуваються з 1 мільйоном акаунтів, і кількість транзакцій в секунду занадто велика, щоб обробляти і зберігати їх в одному вузлі, ми просто розділимо (або **розщепимо**) цей ланцюжок на два менших *ShardChains*, кожен з яких відповідає за півмільйона акаунтів, і кожен ланцюжок обробляється на окремій підмножині вузлів.

Аналогічно, якщо деякі осколки стали занадто вільними, їх можна "об'єднати" в один більший осколок.

Очевидно, що існує два граничних випадки: коли шард містить лише один обліковий запис (і тому не може бути розділений далі) і коли шард містить всі облікові записи.

Акаунти можуть взаємодіяти один з одним, надсилаючи повідомлення. Існує спеціальний механізм маршрутизації, який переміщує повідомлення з вихідних черг до відповідних вхідних черг і гарантує, що 1) всі повідомлення будуть доставлені 2) повідомлення будуть доставлені послідовно (повідомлення, відправлене раніше, досягне адресата раніше).

:::info ПРИМІТКА
Щоб зробити розділення та злиття детермінованим, агрегація ланцюжків облікових записів у шарди базується на бітовому представленні адрес облікових записів. Наприклад, адреса має вигляд `(префікс шарда, адреса)`. Таким чином, всі акаунти в шардчейні матимуть однаковий двійковий префікс (наприклад, всі адреси починаються з `0b00101`).
:::

## Блокчейн

Сукупність всіх шардів, яка містить всі облікові записи, що діють за одним набором правил, називається **Блокчейном**.

У TON може бути багато наборів правил і, відповідно, багато блокчейнів, які працюють одночасно і можуть взаємодіяти один з одним, надсилаючи повідомлення між ланцюжками так само, як акаунти одного ланцюжка можуть взаємодіяти один з одним.

### Workchain: Блокчейн з власними правилами

Якщо ви хочете налаштувати правила групи шардчейнів, ви можете створити **Workchain**. Хорошим прикладом є створення ланцюжка, який працює на базі EVM, щоб запускати на ньому смарт-контракти Solidity.

Теоретично, кожен учасник спільноти може створити власний воркчейн. Насправді, це досить складне завдання - побудувати його, потім заплатити (дорогу) ціну за створення і отримати 2/3 голосів від валідаторів, щоб схвалити створення вашого ланцюжка.

TON дозволяє створювати до `2^32` робочих ланцюжків, кожен з яких розбивається на `2^60` осколків.

На сьогоднішній день в TON існує лише 2 робочі ланцюги: MasterChain та BaseChain.

BaseChain використовується для повсякденних транзакцій між учасниками, оскільки він досить дешевий, в той час як MasterChain виконує важливу функцію для TON, тому давайте розглянемо, що він робить!

### Masterchain: Блокчейн з блокчейнів

Існує необхідність синхронізації маршрутизації повідомлень і виконання транзакцій. Іншими словами, вузлам мережі потрібен спосіб зафіксувати певну "точку" в багатоланцюговому стані і досягти консенсусу щодо цього стану. У TON для цього використовується спеціальний ланцюжок, який називається **MasterChain**. Блоки *masterchain* містять додаткову інформацію (останні хеші блоків) про всі інші ланцюжки в системі, таким чином, будь-який спостерігач однозначно визначає стан всіх мультиланцюжкових систем за одним блоком майстер-ланцюга.
